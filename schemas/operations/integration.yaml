# Integration Schema
# Generated: 2025-12-15T1540
# Source: mathhook/docs/src/operations/integration.md

topic: "operations.integration"
title: "Symbolic Integration"

description: |
  MathHook's integration system provides symbolic integration capabilities with an 8-layer strategy architecture from fast heuristics to complete Risch algorithm. Coverage: 93-95% of elementary integrals.

mathematical_definition: |
  **Fundamental Theorem of Calculus:**
  $$\int_a^b f(x) \, dx = F(b) - F(a)$$
  where $F'(x) = f(x)$.

  **Integration by Parts:**
  $$\int u \, dv = uv - \int v \, du$$

  **U-Substitution:**
  $$\int f(g(x)) \cdot g'(x) \, dx = \int f(u) \, du$$
  where $u = g(x)$ and $du = g'(x) \, dx$.

  **Power Rule:**
  $$\int x^n \, dx = \frac{x^{n+1}}{n+1} + C \quad (n \neq -1)$$

  **Logarithm Special Case:**
  $$\int \frac{1}{x} \, dx = \ln|x| + C$$

article:
  content: |
    ## 8-Layer Strategy Dispatcher

    The integration strategy tries techniques in this exact order:

    ```
    Layer 1: Table Lookup             - O(1) hash lookup for common patterns
    Layer 2: Rational Functions       - Partial fraction decomposition
    Layer 3: Function Registry        - Built-in function antiderivatives
    Layer 4: Integration by Parts     - LIATE heuristic for products
    Layer 5: U-Substitution           - Chain rule patterns
    Layer 6: Trigonometric            - Trig identities and reduction
    Layer 7: Risch Algorithm          - Complete algorithm for elementary functions
    Layer 8: Symbolic Fallback        - Return unevaluated integral
    ```

    **Performance Profile:**
    - Layers 1-4: Microseconds to milliseconds (fast path, 90% of integrals)
    - Layer 5-6: Milliseconds (medium complexity, 5-8%)
    - Layer 7: Milliseconds to seconds (hard cases, 2-5%)

code_refs:
  rust: "mathhook_core::calculus::integrals::Integration"
  python: "mathhook.integrate"
  nodejs: "mathhook.integrate"

examples:
  - title: "Basic Integration (Layer 1: Table Lookup)"
    explanation: "Direct table hits for common patterns"
    code:
      rust: |
        use mathhook::prelude::*;
        use integrals::Integration;

        let x = symbol!(x);

        // Polynomial: ∫x^3 dx = x^4/4 + C
        let poly = expr!(x ^ 3);
        let result = poly.integrate(x.clone());
        // Result: x^4/4 + C

        // Rational: ∫1/(x+1) dx = ln|x+1| + C
        let rational = expr!(1 / (x + 1));
        let result = rational.integrate(x.clone());
        // Result: ln|x+1| + C

        // Trigonometric: ∫sin(x) dx = -cos(x) + C
        let trig = expr!(sin(x));
        let result = trig.integrate(x.clone());
        // Result: -cos(x) + C
      python: |
        from mathhook import symbol, integrate

        x = symbol('x')

        # Polynomial
        poly = x**3
        result = integrate(poly, x)
        # Result: x**4/4

        # Rational
        rational = 1/(x+1)
        result = integrate(rational, x)
        # Result: log(x+1)

        # Trigonometric
        trig = sin(x)
        result = integrate(trig, x)
        # Result: -cos(x)
      nodejs: |
        const { symbol, integrate } = require('mathhook');

        const x = symbol('x');

        // Polynomial
        const poly = x.pow(3);
        const result = integrate(poly, x);
        // Result: x^4/4

  - title: "Integration by Parts (Layer 4: LIATE)"
    explanation: "∫u dv = uv - ∫v du using LIATE rule"
    code:
      rust: |
        use mathhook::prelude::*;
        use integrals::Integration;

        let x = symbol!(x);

        // ∫x*e^x dx: u = x (algebraic), dv = e^x (exponential)
        let expr = expr!(x * exp(x));
        let result = expr.integrate(x.clone());
        // Result: x*e^x - e^x + C = e^x(x-1) + C

        // ∫x*sin(x) dx: u = x (algebraic), dv = sin(x) (trig)
        let expr2 = expr!(x * sin(x));
        let result2 = expr2.integrate(x.clone());
        // Result: -x*cos(x) + sin(x) + C
      python: |
        from mathhook import symbol, integrate, exp, sin

        x = symbol('x')

        # ∫x*e^x dx
        expr = x * exp(x)
        result = integrate(expr, x)
        # Result: x*exp(x) - exp(x)

        # ∫x*sin(x) dx
        expr2 = x * sin(x)
        result2 = integrate(expr2, x)
        # Result: -x*cos(x) + sin(x)
      nodejs: |
        const { symbol, integrate, parse } = require('mathhook');

        const x = symbol('x');

        // ∫x*e^x dx
        const expr = parse('x*exp(x)');
        const result = integrate(expr, x);
        // Result: x*exp(x) - exp(x)

  - title: "U-Substitution (Layer 5)"
    explanation: "∫f(g(x))*g'(x) dx = ∫f(u) du"
    code:
      rust: |
        use mathhook::prelude::*;
        use integrals::Integration;

        let x = symbol!(x);

        // ∫2x*sin(x^2) dx: u = x^2, du = 2x dx
        let expr = expr!(2 * x * sin(x ^ 2));
        let result = expr.integrate(x.clone());
        // Result: -cos(x^2) + C

        // ∫2x*e^(x^2) dx: u = x^2, du = 2x dx
        let expr2 = expr!(2 * x * exp(x ^ 2));
        let result2 = expr2.integrate(x.clone());
        // Result: e^(x^2) + C
      python: |
        from mathhook import symbol, integrate, sin, exp

        x = symbol('x')

        # ∫2x*sin(x^2) dx
        expr = 2*x*sin(x**2)
        result = integrate(expr, x)
        # Result: -cos(x^2)

        # ∫2x*e^(x^2) dx
        expr2 = 2*x*exp(x**2)
        result2 = integrate(expr2, x)
        # Result: exp(x^2)
      nodejs: |
        const { symbol, integrate, parse } = require('mathhook');

        const x = symbol('x');

        // ∫2x*sin(x^2) dx
        const expr = parse('2*x*sin(x^2)');
        const result = integrate(expr, x);
        // Result: -cos(x^2)

performance:
  complexity: "Varies by layer: O(1) for table, O(n^3) for rational functions, polynomial for Risch"
  benchmarks: |
    Test Environment: Apple M1, 16GB RAM, Rust 1.75

    Fast Path (Layers 1-4): 90% of common integrals
    - Table lookup: ~10-50 microseconds
    - Rational functions: ~100-500 microseconds
    - Function registry: ~50-200 microseconds
    - Integration by parts: ~200-1000 microseconds

    Medium Path (Layers 5-6): 5-8% of integrals
    - U-substitution: ~500 microseconds - 5 milliseconds
    - Trigonometric: ~1-10 milliseconds

    Slow Path (Layer 7): 2-5% of integrals
    - Risch basic cases: ~10-100 milliseconds
    - Risch hard cases: ~100 milliseconds - 2 seconds

use_cases:
  - "Calculus: Finding antiderivatives"
  - "Physics: Work, energy, displacement calculations"
  - "Probability: Computing probability distributions"
  - "Engineering: Signal integration, transfer functions"

related_topics:
  - "operations.differentiation"
  - "operations.substitution"
  - "operations.limits"

limitations:
  - "Returns symbolic integral for non-elementary functions (erf, Si, Ei, li)"
  - "Risch algorithm basic implementation (no algebraic extensions yet)"
  - "Integration by parts may fail for complex products"

metadata:
  schema_version: "1.0"
  source_file: "operations/integration.md"
  last_updated: "2025-12-14T1430"
  validation_status: "sympy_architecture_similar"
