# Quick Start Guide for MathHook CAS
# Generated: 2025-12-15T00:00:00Z
# Source: mathhook/docs/src/getting-started/quick-start.md

topic: "getting-started.quick-start"
title: "Quick Start"

description: |
  Get up and running with MathHook in 5 minutes. Learn basic expression creation,
  parsing, differentiation, and common operations across Rust, Python, and Node.js.

article:
  content: |
    # Quick Start

    This guide will get you up and running with MathHook in 5 minutes.

    ## Your First Expression

    Create symbolic expressions using the high-level API with ergonomic macros (Rust)
    or method chaining (Python/Node.js).

    ## Common Operations

    - **Parsing LaTeX**: Transform LaTeX notation into symbolic expressions
    - **Computing Derivatives**: Automatic symbolic differentiation
    - **Solving Equations**: Symbolic equation solving
    - **Matrix Operations**: Symbolic linear algebra
    - **Step-by-Step Explanations**: Educational features for learning

    ## Expression Operators

    The `expr!` macro (Rust) supports mathematical operators:
    - Comparison: `==`, `<`, `>`, `<=`, `>=`
    - Method calls: `.abs()`, `.sqrt()`, `.simplify()`
    - Power operations: `^`, `**`, `.pow()`

    ## Common Patterns

    - **Creating Expressions Programmatically**: Use macros for compile-time values,
      explicit API for runtime values
    - **Substitution**: Replace symbols with values using HashMap
    - **Formatting Output**: Standard, LaTeX, and Wolfram notation

    ## Common Mistakes

    - **Runtime Variables in Macros**: Use explicit API for loop variables
    - **Precedence Without Parentheses**: Always use explicit grouping
    - **Floating Point Comparison**: Use epsilon comparison for numerical values

  sections:
    - title: "First Expression"
      content: |
        Create symbols and build expressions using macros (Rust) or method chaining
        (Python/Node.js). Simplify expressions with `.simplify()`.

    - title: "Parsing LaTeX"
      content: |
        Use Parser with ParserConfig to parse LaTeX notation into symbolic expressions.

    - title: "Computing Derivatives"
      content: |
        Use `.derivative()` for first derivatives, `.nth_derivative()` for higher orders.

    - title: "Expression Operators"
      content: |
        Three equivalent power syntaxes: `^` (natural), `**` (Python-style), `.pow()` (method).

    - title: "Solving Equations"
      content: |
        Create equations with `Expression::equation()`, solve with `MathSolver::solve()`.

    - title: "Matrix Operations"
      content: |
        Create matrices with `Expression::matrix()`, perform symbolic linear algebra.

    - title: "Step-by-Step Explanations"
      content: |
        Use `.explain_simplification()` to generate educational step-by-step explanations.

code_refs:
  rust: "mathhook::prelude"
  python: "mathhook.Expression"
  nodejs: "mathhook-node.Expression"

examples:
  - title: "First Expression - Quadratic"
    explanation: "Build and simplify x^2 + 2x + 1"
    code:
      rust: |
        use mathhook::prelude::*;

        fn main() {
            let x = symbol!(x);
            let expr = expr!(add: (x ^ 2), (2 * x), 1);
            let simplified = expr.simplify();

            println!("Original: {}", expr);
            println!("Simplified: {}", simplified);
        }
      python: |
        from mathhook import Expression

        x = Expression.symbol('x')
        expr = x.pow(2).add(x.multiply(2)).add(1)
        simplified = expr.simplify()

        print(f"Original: {expr}")
        print(f"Simplified: {simplified}")
      nodejs: |
        import { Expression } from 'mathhook-node';

        const x = Expression.symbol('x');
        const expr = x.pow(2).add(x.multiply(2)).add(1);
        const simplified = expr.simplify();

        console.log(`Original: ${expr.toString()}`);
        console.log(`Simplified: ${simplified.toString()}`);

  - title: "Parsing LaTeX"
    explanation: "Parse LaTeX notation into symbolic expression"
    code:
      rust: |
        let parser = Parser::new(ParserConfig::default());
        let expr = parser.parse(r"\frac{x^2 + 1}{2}").unwrap();
        println!("{}", expr);
      python: |
        from mathhook import Parser, ParserConfig

        parser = Parser(ParserConfig.default())
        expr = parser.parse(r"\frac{x^2 + 1}{2}")
        print(expr)
      nodejs: |
        import { Parser, ParserConfig } from 'mathhook-node';

        const parser = new Parser(ParserConfig.default());
        const expr = parser.parse(String.raw`\frac{x^2 + 1}{2}`);
        console.log(expr.toString());

  - title: "Computing Derivatives"
    explanation: "Compute first and second derivatives of x^3"
    code:
      rust: |
        use mathhook::prelude::*;

        let x = symbol!(x);
        let expr = expr!(x ^ 3);

        let derivative = expr.derivative(x.clone());
        let second_derivative = expr.nth_derivative(x, 2);

        println!("f(x) = {}", expr);
        println!("f'(x) = {}", derivative);
        println!("f''(x) = {}", second_derivative);
      python: |
        from mathhook import Expression

        x = Expression.symbol('x')
        expr = x.pow(3)

        derivative = expr.derivative(x)
        second_derivative = expr.nth_derivative(x, 2)

        print(f"f(x) = {expr}")
        print(f"f'(x) = {derivative}")
        print(f"f''(x) = {second_derivative}")
      nodejs: |
        import { Expression } from 'mathhook-node';

        const x = Expression.symbol('x');
        const expr = x.pow(3);

        const derivative = expr.derivative(x);
        const secondDerivative = expr.nthDerivative(x, 2);

        console.log(`f(x) = ${expr.toString()}`);
        console.log(`f'(x) = ${derivative.toString()}`);
        console.log(`f''(x) = ${secondDerivative.toString()}`);

  - title: "Solving Equations"
    explanation: "Solve x^2 = 4 symbolically"
    code:
      rust: |
        use mathhook::prelude::*;

        let x = symbol!(x);
        let mut solver = MathSolver::new();
        let equation = Expression::equation(expr!(x ^ 2), expr!(4));
        let solutions = solver.solve(&equation, &x);

        println!("Solutions: {:?}", solutions);
        // Output: [x = 2, x = -2]
      python: |
        from mathhook import Expression, MathSolver

        x = Expression.symbol('x')
        solver = MathSolver()
        equation = Expression.equation(x.pow(2), Expression.integer(4))
        solutions = solver.solve(equation, x)

        print(f"Solutions: {solutions}")
      nodejs: |
        import { Expression, MathSolver } from 'mathhook-node';

        const x = Expression.symbol('x');
        const solver = new MathSolver();
        const equation = Expression.equation(x.pow(2), Expression.integer(4));
        const solutions = solver.solve(equation, x);

        console.log(`Solutions: ${solutions}`);

  - title: "Substitution"
    explanation: "Substitute x = 3 into x^2 + 2x + 1"
    code:
      rust: |
        use mathhook::prelude::*;
        use std::collections::HashMap;

        let x = symbol!(x);
        let expr = expr!(add: (x ^ 2), (2 * x), 1);

        let mut vars = HashMap::new();
        vars.insert("x".to_string(), Expression::integer(3));
        let result = expr.substitute(&vars);
        println!("Result: {}", result);
        // Output: 16
      python: |
        from mathhook import Expression

        x = Expression.symbol('x')
        expr = x.pow(2).add(x.multiply(2)).add(1)

        vars = {'x': Expression.integer(3)}
        result = expr.substitute(vars)
        print(f"Result: {result}")
      nodejs: |
        import { Expression } from 'mathhook-node';

        const x = Expression.symbol('x');
        const expr = x.pow(2).add(x.multiply(2)).add(1);

        const vars = new Map([['x', Expression.integer(3)]]);
        const result = expr.substitute(vars);
        console.log(`Result: ${result.toString()}`);

  - title: "Creating Expressions Programmatically"
    explanation: "Use macros for compile-time values, explicit API for runtime"
    code:
      rust: |
        use mathhook::prelude::*;

        let x = symbol!(x);

        // Compile-time - use macros
        let expr = expr!((x ^ 2) + 3);

        // Runtime - use explicit API
        let mut terms = Vec::new();
        for i in 0..5 {
            terms.push(Expression::mul(vec![
                Expression::integer(i as i64),
                Expression::pow(x.clone().into(), Expression::integer(i as i64))
            ]));
        }
        let polynomial = Expression::add(terms);
      python: |
        from mathhook import Expression

        x = Expression.symbol('x')

        # Direct creation
        expr = x.pow(2).add(3)

        # Runtime creation
        terms = []
        for i in range(5):
            terms.append(
                Expression.mul([
                    Expression.integer(i),
                    x.pow(Expression.integer(i))
                ])
            )
        polynomial = Expression.add(terms)
      nodejs: |
        import { Expression } from 'mathhook-node';

        const x = Expression.symbol('x');

        // Direct creation
        const expr = x.pow(2).add(3);

        // Runtime creation
        const terms = [];
        for (let i = 0; i < 5; i++) {
            terms.push(
                Expression.mul([
                    Expression.integer(i),
                    x.pow(Expression.integer(i))
                ])
            );
        }
        const polynomial = Expression.add(terms);

use_cases:
  - "Quick onboarding for new MathHook users"
  - "5-minute demonstration of core capabilities"
  - "Reference for common operations across languages"
  - "Teaching symbolic computation basics"

related_topics:
  - "getting-started.installation"
  - "getting-started.basic-usage"
  - "getting-started.common-patterns"
  - "core.expressions"
  - "operations.differentiation"

performance:
  typical_time: "5 minutes to productivity"

metadata:
  schema_version: "1.0"
  source_file: "getting-started/quick-start.md"
  generated_at: "2025-12-15T00:00:00Z"
  audience: "beginners"
  time_to_complete: "5 minutes"
