{
  "topic": "getting-started.quick-start",
  "title": "Quick Start",
  "description": "Get up and running with MathHook in 5 minutes. Learn basic expression creation,\nparsing, differentiation, and common operations across Rust, Python, and Node.js.\n",
  "code_refs": {
    "rust": "mathhook::prelude",
    "python": "mathhook.Expression",
    "nodejs": "mathhook-node.Expression"
  },
  "examples": [
    {
      "title": "First Expression - Quadratic",
      "explanation": "Build and simplify x^2 + 2x + 1",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nfn main() {\n    let x = symbol!(x);\n    let expr = expr!(add: (x ^ 2), (2 * x), 1);\n    let simplified = expr.simplify();\n\n    println!(\"Original: {}\", expr);\n    println!(\"Simplified: {}\", simplified);\n}\n",
        "python": "from mathhook import Expression\n\nx = Expression.symbol('x')\nexpr = x.pow(2).add(x.multiply(2)).add(1)\nsimplified = expr.simplify()\n\nprint(f\"Original: {expr}\")\nprint(f\"Simplified: {simplified}\")\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\nconst expr = x.pow(2).add(x.multiply(2)).add(1);\nconst simplified = expr.simplify();\n\nconsole.log(`Original: ${expr.toString()}`);\nconsole.log(`Simplified: ${simplified.toString()}`);\n"
      }
    },
    {
      "title": "Parsing LaTeX",
      "explanation": "Parse LaTeX notation into symbolic expression",
      "code": {
        "rust": "let parser = Parser::new(ParserConfig::default());\nlet expr = parser.parse(r\"\\frac{x^2 + 1}{2}\").unwrap();\nprintln!(\"{}\", expr);\n",
        "python": "from mathhook import Parser, ParserConfig\n\nparser = Parser(ParserConfig.default())\nexpr = parser.parse(r\"\\frac{x^2 + 1}{2}\")\nprint(expr)\n",
        "nodejs": "import { Parser, ParserConfig } from 'mathhook-node';\n\nconst parser = new Parser(ParserConfig.default());\nconst expr = parser.parse(String.raw`\\frac{x^2 + 1}{2}`);\nconsole.log(expr.toString());\n"
      }
    },
    {
      "title": "Computing Derivatives",
      "explanation": "Compute first and second derivatives of x^3",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet expr = expr!(x ^ 3);\n\nlet derivative = expr.derivative(x.clone());\nlet second_derivative = expr.nth_derivative(x, 2);\n\nprintln!(\"f(x) = {}\", expr);\nprintln!(\"f'(x) = {}\", derivative);\nprintln!(\"f''(x) = {}\", second_derivative);\n",
        "python": "from mathhook import Expression\n\nx = Expression.symbol('x')\nexpr = x.pow(3)\n\nderivative = expr.derivative(x)\nsecond_derivative = expr.nth_derivative(x, 2)\n\nprint(f\"f(x) = {expr}\")\nprint(f\"f'(x) = {derivative}\")\nprint(f\"f''(x) = {second_derivative}\")\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\nconst expr = x.pow(3);\n\nconst derivative = expr.derivative(x);\nconst secondDerivative = expr.nthDerivative(x, 2);\n\nconsole.log(`f(x) = ${expr.toString()}`);\nconsole.log(`f'(x) = ${derivative.toString()}`);\nconsole.log(`f''(x) = ${secondDerivative.toString()}`);\n"
      }
    },
    {
      "title": "Solving Equations",
      "explanation": "Solve x^2 = 4 symbolically",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet mut solver = MathSolver::new();\nlet equation = Expression::equation(expr!(x ^ 2), expr!(4));\nlet solutions = solver.solve(&equation, &x);\n\nprintln!(\"Solutions: {:?}\", solutions);\n// Output: [x = 2, x = -2]\n",
        "python": "from mathhook import Expression, MathSolver\n\nx = Expression.symbol('x')\nsolver = MathSolver()\nequation = Expression.equation(x.pow(2), Expression.integer(4))\nsolutions = solver.solve(equation, x)\n\nprint(f\"Solutions: {solutions}\")\n",
        "nodejs": "import { Expression, MathSolver } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\nconst solver = new MathSolver();\nconst equation = Expression.equation(x.pow(2), Expression.integer(4));\nconst solutions = solver.solve(equation, x);\n\nconsole.log(`Solutions: ${solutions}`);\n"
      }
    },
    {
      "title": "Substitution",
      "explanation": "Substitute x = 3 into x^2 + 2x + 1",
      "code": {
        "rust": "use mathhook::prelude::*;\nuse std::collections::HashMap;\n\nlet x = symbol!(x);\nlet expr = expr!(add: (x ^ 2), (2 * x), 1);\n\nlet mut vars = HashMap::new();\nvars.insert(\"x\".to_string(), Expression::integer(3));\nlet result = expr.substitute(&vars);\nprintln!(\"Result: {}\", result);\n// Output: 16\n",
        "python": "from mathhook import Expression\n\nx = Expression.symbol('x')\nexpr = x.pow(2).add(x.multiply(2)).add(1)\n\nvars = {'x': Expression.integer(3)}\nresult = expr.substitute(vars)\nprint(f\"Result: {result}\")\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\nconst expr = x.pow(2).add(x.multiply(2)).add(1);\n\nconst vars = new Map([['x', Expression.integer(3)]]);\nconst result = expr.substitute(vars);\nconsole.log(`Result: ${result.toString()}`);\n"
      }
    },
    {
      "title": "Creating Expressions Programmatically",
      "explanation": "Use macros for compile-time values, explicit API for runtime",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Compile-time - use macros\nlet expr = expr!((x ^ 2) + 3);\n\n// Runtime - use explicit API\nlet mut terms = Vec::new();\nfor i in 0..5 {\n    terms.push(Expression::mul(vec![\n        Expression::integer(i as i64),\n        Expression::pow(x.clone().into(), Expression::integer(i as i64))\n    ]));\n}\nlet polynomial = Expression::add(terms);\n",
        "python": "from mathhook import Expression\n\nx = Expression.symbol('x')\n\n# Direct creation\nexpr = x.pow(2).add(3)\n\n# Runtime creation\nterms = []\nfor i in range(5):\n    terms.append(\n        Expression.mul([\n            Expression.integer(i),\n            x.pow(Expression.integer(i))\n        ])\n    )\npolynomial = Expression.add(terms)\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\n\n// Direct creation\nconst expr = x.pow(2).add(3);\n\n// Runtime creation\nconst terms = [];\nfor (let i = 0; i < 5; i++) {\n    terms.push(\n        Expression.mul([\n            Expression.integer(i),\n            x.pow(Expression.integer(i))\n        ])\n    );\n}\nconst polynomial = Expression.add(terms);\n"
      }
    }
  ],
  "article": {
    "content": "# Quick Start\n\nThis guide will get you up and running with MathHook in 5 minutes.\n\n## Your First Expression\n\nCreate symbolic expressions using the high-level API with ergonomic macros (Rust)\nor method chaining (Python/Node.js).\n\n## Common Operations\n\n- **Parsing LaTeX**: Transform LaTeX notation into symbolic expressions\n- **Computing Derivatives**: Automatic symbolic differentiation\n- **Solving Equations**: Symbolic equation solving\n- **Matrix Operations**: Symbolic linear algebra\n- **Step-by-Step Explanations**: Educational features for learning\n\n## Expression Operators\n\nThe `expr!` macro (Rust) supports mathematical operators:\n- Comparison: `==`, `<`, `>`, `<=`, `>=`\n- Method calls: `.abs()`, `.sqrt()`, `.simplify()`\n- Power operations: `^`, `**`, `.pow()`\n\n## Common Patterns\n\n- **Creating Expressions Programmatically**: Use macros for compile-time values,\n  explicit API for runtime values\n- **Substitution**: Replace symbols with values using HashMap\n- **Formatting Output**: Standard, LaTeX, and Wolfram notation\n\n## Common Mistakes\n\n- **Runtime Variables in Macros**: Use explicit API for loop variables\n- **Precedence Without Parentheses**: Always use explicit grouping\n- **Floating Point Comparison**: Use epsilon comparison for numerical values\n"
  },
  "use_cases": [
    "Quick onboarding for new MathHook users",
    "5-minute demonstration of core capabilities",
    "Reference for common operations across languages",
    "Teaching symbolic computation basics"
  ],
  "related_topics": [
    "getting-started.installation",
    "getting-started.basic-usage",
    "getting-started.common-patterns",
    "core.expressions",
    "operations.differentiation"
  ],
  "performance": {
    "typical_time": "5 minutes to productivity"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}