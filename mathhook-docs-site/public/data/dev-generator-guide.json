{
  "topic": "dev.generator-guide",
  "title": "Generator Guide",
  "description": "Step-by-step guide for implementing new output generators in the MathHook Knowledge Base Engine. Learn to create generators for any documentation format.",
  "mathematical_definition": "\\text{Generator}: \\text{Schema} \\rightarrow \\text{OutputFormat}",
  "examples": [
    {
      "title": "Implementing OutputGenerator Trait",
      "explanation": "Every generator implements the `OutputGenerator` trait, providing a consistent interface for the generation pipeline.\n\n**Required methods**:\n- `name()`: Generator identifier\n- `file_extension()`: Output file extension\n- `generate()`: Transform schema to output\n- `validate_output()`: Verify output correctness",
      "code": {
        "python": "from abc import ABC, abstractmethod\nfrom typing import Dict, Any\nimport json\n\nclass OutputGenerator(ABC):\n    \"\"\"Base class for all documentation generators\"\"\"\n    \n    @property\n    @abstractmethod\n    def name(self) -> str:\n        pass\n    \n    @property\n    @abstractmethod\n    def file_extension(self) -> str:\n        pass\n    \n    @abstractmethod\n    def generate(self, schema: Dict[str, Any]) -> str:\n        pass\n    \n    @abstractmethod\n    def validate_output(self, output: str) -> None:\n        pass\n\n\nclass MarkdownGenerator(OutputGenerator):\n    \"\"\"Example: Markdown documentation generator\"\"\"\n    \n    @property\n    def name(self) -> str:\n        return 'markdown'\n    \n    @property\n    def file_extension(self) -> str:\n        return 'md'\n    \n    def generate(self, schema: Dict[str, Any]) -> str:\n        lines = [\n            f\"# {schema['title']}\",\n            \"\",\n            schema['description'],\n            \"\",\n        ]\n        \n        if schema.get('mathematical_definition'):\n            lines.extend([\"## Definition\", \"\", schema['mathematical_definition'], \"\"])\n        \n        lines.append(\"## Examples\")\n        for example in schema['examples']:\n            lines.extend([\n                \"\",\n                f\"### {example['title']}\",\n                \"\",\n                example['explanation'],\n                \"\",\n                \"```python\",\n                example['code']['python'],\n                \"```\",\n            ])\n        \n        return '\\n'.join(lines)\n    \n    def validate_output(self, output: str) -> None:\n        # Basic markdown validation\n        if not output.startswith('# '):\n            raise ValueError('Markdown must start with H1 header')\n",
        "rust": "use anyhow::Result;\nuse kb_core::schema::Schema;\n\npub trait OutputGenerator {\n    fn name(&self) -> &str;\n    fn file_extension(&self) -> &str;\n    fn generate(&self, schema: &Schema) -> Result<String>;\n    fn validate_output(&self, output: &str) -> Result<()>;\n}\n\n/// Example: Markdown documentation generator\npub struct MarkdownGenerator {\n    template_dir: PathBuf,\n    tera: Tera,\n}\n\nimpl MarkdownGenerator {\n    pub fn new(template_dir: &str) -> Result<Self> {\n        let tera = Tera::new(&format!(\"{}/**/*.tera\", template_dir))?;\n        Ok(Self {\n            template_dir: PathBuf::from(template_dir),\n            tera,\n        })\n    }\n}\n\nimpl OutputGenerator for MarkdownGenerator {\n    fn name(&self) -> &str {\n        \"markdown\"\n    }\n    \n    fn file_extension(&self) -> &str {\n        \"md\"\n    }\n    \n    fn generate(&self, schema: &Schema) -> Result<String> {\n        let mut context = tera::Context::new();\n        context.insert(\"title\", &schema.title);\n        context.insert(\"description\", &schema.description);\n        context.insert(\"examples\", &schema.examples);\n        context.insert(\"math_def\", &schema.mathematical_definition);\n        \n        self.tera.render(\"markdown/doc.tera\", &context)\n            .map_err(|e| anyhow::anyhow!(\"Template error: {}\", e))\n    }\n    \n    fn validate_output(&self, output: &str) -> Result<()> {\n        if !output.starts_with(\"# \") {\n            anyhow::bail!(\"Markdown must start with H1 header\");\n        }\n        Ok(())\n    }\n}\n",
        "nodejs": "// TypeScript generator implementation\nimport { Schema, Example } from './types';\n\ninterface OutputGenerator {\n    readonly name: string;\n    readonly fileExtension: string;\n    generate(schema: Schema): Promise<string>;\n    validateOutput(output: string): Promise<void>;\n}\n\nclass MarkdownGenerator implements OutputGenerator {\n    readonly name = 'markdown';\n    readonly fileExtension = 'md';\n    \n    async generate(schema: Schema): Promise<string> {\n        const lines: string[] = [\n            `# ${schema.title}`,\n            '',\n            schema.description,\n            '',\n        ];\n        \n        if (schema.mathematical_definition) {\n            lines.push('## Definition', '', schema.mathematical_definition, '');\n        }\n        \n        lines.push('## Examples');\n        for (const example of schema.examples) {\n            lines.push(\n                '',\n                `### ${example.title}`,\n                '',\n                example.explanation,\n                '',\n                '```python',\n                example.code.python,\n                '```',\n            );\n        }\n        \n        return lines.join('\\n');\n    }\n    \n    async validateOutput(output: string): Promise<void> {\n        if (!output.startsWith('# ')) {\n            throw new Error('Markdown must start with H1 header');\n        }\n    }\n}\n"
      },
      "expected_output": "# Symbolic Differentiation\n\nComputes the derivative...\n\n## Definition\n\n$$\\frac{d}{dx} f(x) = ...$$\n\n## Examples\n\n### Power Rule\n..."
    },
    {
      "title": "Creating Tera Templates",
      "explanation": "Templates separate content from presentation. Create templates in `templates/{generator-name}/` directory.\n\n**Template features**:\n- Jinja2-like syntax\n- Filters for text transformation\n- Conditionals and loops\n- Template inheritance",
      "code": {
        "python": "# Python Jinja2 equivalent template\ntemplate_content = '''\n{# templates/markdown/doc.jinja2 #}\n# {{ title }}\n\n{{ description }}\n\n{% if mathematical_definition %}\n## Definition\n\n{{ mathematical_definition }}\n{% endif %}\n\n## Examples\n\n{% for example in examples %}\n### {{ example.title }}\n\n{{ example.explanation }}\n\n#### Python\n```python\n{{ example.code.python }}\n```\n\n#### Rust\n```rust\n{{ example.code.rust }}\n```\n\n#### JavaScript\n```javascript\n{{ example.code.nodejs }}\n```\n\n{% if example.expected_output %}\n**Output:**\n```\n{{ example.expected_output }}\n```\n{% endif %}\n\n{% endfor %}\n\n{% if use_cases %}\n## Use Cases\n\n{% for use_case in use_cases %}\n- {{ use_case }}\n{% endfor %}\n{% endif %}\n'''\n",
        "rust": "// templates/markdown/doc.tera\nlet template = r#\"\n{# Markdown documentation template #}\n# {{ title }}\n\n{{ description }}\n\n{% if math_def %}\n## Definition\n\n{{ math_def }}\n{% endif %}\n\n## Examples\n\n{% for example in examples %}\n### {{ example.title }}\n\n{{ example.explanation }}\n\n#### Python\n```python\n{{ example.code.python }}\n```\n\n#### Rust\n```rust\n{{ example.code.rust }}\n```\n\n#### JavaScript\n```javascript\n{{ example.code.nodejs }}\n```\n\n{% if example.expected_output %}\n**Output:**\n```\n{{ example.expected_output }}\n```\n{% endif %}\n\n{% endfor %}\n\n{% if use_cases %}\n## Use Cases\n\n{% for use_case in use_cases %}\n- {{ use_case }}\n{% endfor %}\n{% endif %}\n\"#;\n\n// Custom Tera filters\nfn register_custom_filters(tera: &mut Tera) {\n    tera.register_filter(\"escape_latex\", |value, _| {\n        let s = value.as_str().unwrap_or(\"\");\n        Ok(tera::Value::String(s.replace(\"\\\\\", \"\\\\\\\\\")))\n    });\n}\n",
        "nodejs": "// Nunjucks template (JavaScript equivalent)\nconst templateContent = `\n{# Markdown documentation template #}\n# {{ title }}\n\n{{ description }}\n\n{% if mathematical_definition %}\n## Definition\n\n{{ mathematical_definition }}\n{% endif %}\n\n## Examples\n\n{% for example in examples %}\n### {{ example.title }}\n\n{{ example.explanation }}\n\n#### Python\n\\`\\`\\`python\n{{ example.code.python }}\n\\`\\`\\`\n\n#### Rust\n\\`\\`\\`rust\n{{ example.code.rust }}\n\\`\\`\\`\n\n#### JavaScript\n\\`\\`\\`javascript\n{{ example.code.nodejs }}\n\\`\\`\\`\n\n{% if example.expected_output %}\n**Output:**\n\\`\\`\\`\n{{ example.expected_output }}\n\\`\\`\\`\n{% endif %}\n\n{% endfor %}\n`;\n"
      },
      "expected_output": "Template file: templates/markdown/doc.tera\nFeatures: conditionals, loops, filters\nOutput: Rendered markdown with all examples"
    },
    {
      "title": "Adding Integration Tests",
      "explanation": "Every generator MUST have integration tests that:\n1. Load an example schema\n2. Generate output\n3. Validate output structure\n4. Verify content correctness",
      "code": {
        "python": "import pytest\nimport json\nfrom pathlib import Path\nfrom generators import MarkdownGenerator\n\nclass TestMarkdownGenerator:\n    @pytest.fixture\n    def generator(self):\n        return MarkdownGenerator()\n    \n    @pytest.fixture\n    def sample_schema(self):\n        return {\n            'topic': 'test.example',\n            'title': 'Test Topic',\n            'description': 'A test description.',\n            'mathematical_definition': '$$x^2$$',\n            'examples': [{\n                'title': 'Basic Example',\n                'explanation': 'Shows basic usage.',\n                'code': {\n                    'python': 'x = 1',\n                    'rust': 'let x = 1;',\n                    'nodejs': 'const x = 1;',\n                },\n                'expected_output': '1',\n            }],\n        }\n    \n    def test_generate_creates_valid_markdown(self, generator, sample_schema):\n        output = generator.generate(sample_schema)\n        \n        # Structure checks\n        assert output.startswith('# Test Topic')\n        assert '## Definition' in output\n        assert '## Examples' in output\n        \n        # Content checks\n        assert 'A test description.' in output\n        assert '$$x^2$$' in output\n        assert 'x = 1' in output\n    \n    def test_validate_output_accepts_valid(self, generator, sample_schema):\n        output = generator.generate(sample_schema)\n        generator.validate_output(output)  # Should not raise\n    \n    def test_validate_output_rejects_invalid(self, generator):\n        with pytest.raises(ValueError):\n            generator.validate_output('No header here')\n",
        "rust": "#[cfg(test)]\nmod tests {\n    use super::*;\n    use kb_core::schema::Schema;\n    \n    fn sample_schema() -> Schema {\n        serde_yaml::from_str(r#\"\n            topic: \"test.example\"\n            title: \"Test Topic\"\n            description: \"A test description.\"\n            mathematical_definition: \"$$x^2$$\"\n            examples:\n              - title: \"Basic Example\"\n                explanation: \"Shows basic usage.\"\n                code:\n                  python: \"x = 1\"\n                  rust: \"let x = 1;\"\n                  nodejs: \"const x = 1;\"\n                expected_output: \"1\"\n        \"#).unwrap()\n    }\n    \n    #[test]\n    fn test_generate_creates_valid_markdown() {\n        let generator = MarkdownGenerator::new(\"templates/\").unwrap();\n        let schema = sample_schema();\n        \n        let output = generator.generate(&schema).unwrap();\n        \n        // Structure checks\n        assert!(output.starts_with(\"# Test Topic\"));\n        assert!(output.contains(\"## Definition\"));\n        assert!(output.contains(\"## Examples\"));\n        \n        // Content checks\n        assert!(output.contains(\"A test description.\"));\n        assert!(output.contains(\"$$x^2$$\"));\n        assert!(output.contains(\"x = 1\"));\n    }\n    \n    #[test]\n    fn test_validate_output_accepts_valid() {\n        let generator = MarkdownGenerator::new(\"templates/\").unwrap();\n        let schema = sample_schema();\n        let output = generator.generate(&schema).unwrap();\n        \n        assert!(generator.validate_output(&output).is_ok());\n    }\n    \n    #[test]\n    fn test_validate_output_rejects_invalid() {\n        let generator = MarkdownGenerator::new(\"templates/\").unwrap();\n        \n        assert!(generator.validate_output(\"No header here\").is_err());\n    }\n}\n",
        "nodejs": "// Jest integration tests\nimport { MarkdownGenerator } from './markdown-generator';\n\ndescribe('MarkdownGenerator', () => {\n    const generator = new MarkdownGenerator();\n    \n    const sampleSchema = {\n        topic: 'test.example',\n        title: 'Test Topic',\n        description: 'A test description.',\n        mathematical_definition: '$$x^2$$',\n        examples: [{\n            title: 'Basic Example',\n            explanation: 'Shows basic usage.',\n            code: {\n                python: 'x = 1',\n                rust: 'let x = 1;',\n                nodejs: 'const x = 1;',\n            },\n            expected_output: '1',\n        }],\n    };\n    \n    test('generates valid markdown', async () => {\n        const output = await generator.generate(sampleSchema);\n        \n        // Structure checks\n        expect(output).toMatch(/^# Test Topic/);\n        expect(output).toContain('## Definition');\n        expect(output).toContain('## Examples');\n        \n        // Content checks\n        expect(output).toContain('A test description.');\n        expect(output).toContain('$$x^2$$');\n        expect(output).toContain('x = 1');\n    });\n    \n    test('validates correct output', async () => {\n        const output = await generator.generate(sampleSchema);\n        await expect(generator.validateOutput(output)).resolves.not.toThrow();\n    });\n    \n    test('rejects invalid output', async () => {\n        await expect(generator.validateOutput('No header here'))\n            .rejects.toThrow();\n    });\n});\n"
      },
      "expected_output": "Tests passed: 3/3\n- generate_creates_valid_markdown\n- validate_output_accepts_valid\n- validate_output_rejects_invalid"
    }
  ],
  "article": {
    "introduction": {
      "hook": "This guide walks through creating new output generators for the MathHook Knowledge Base Engine. Generators transform YAML schemas into specific documentation formats - from Jupyter notebooks to LaTeX papers.\n\nBy following this guide, you'll learn to implement the `OutputGenerator` trait, create Tera templates, write integration tests, and register your generator with the CLI."
    },
    "sections": [
      {
        "title": "Generator Checklist",
        "content": "### Before You Start ###\n\n1. **Choose your format**: What documentation format are you targeting?\n2. **Study existing generators**: Look at `kb-jupyter` or `kb-mdbook` for patterns\n3. **Plan your templates**: What sections will your output include?\n\n### Implementation Steps ###\n\n1. **Create crate**: `cargo new --lib crates/kb-{format}`\n2. **Add dependencies**: `serde`, `tera`, `anyhow`, `kb-core`\n3. **Implement trait**: `OutputGenerator` with all 4 methods\n4. **Create templates**: In `templates/{format}/`\n5. **Write tests**: Unit + integration tests\n6. **Register generator**: Add to CLI command\n7. **Document**: Update README with new format"
      },
      {
        "title": "Template Best Practices",
        "content": "### Template Organization ###\n\n```\ntemplates/markdown/\n├── doc.tera           # Main document template\n├── example.tera       # Example section partial\n├── sidebar.tera       # Sidebar partial\n└── macros.tera        # Reusable macros\n```\n\n### Template Guidelines ###\n\n1. **Keep templates simple**: Logic in Rust, presentation in templates\n2. **Use partials**: Break complex templates into smaller pieces\n3. **Handle missing fields**: Use `{% if field %}` for optional content\n4. **Escape properly**: Use appropriate escaping for target format\n5. **Test with edge cases**: Empty arrays, missing fields, special characters"
      },
      {
        "title": "Validation Strategies",
        "content": "### Output Validation ###\n\nEach format requires specific validation:\n\n| Format | Validation Method |\n|--------|------------------|\n| `.ipynb` | Parse JSON, check nbformat schema |\n| `.md` | Check headers, validate code blocks |\n| `.tex` | Run `pdflatex --interaction=nonstopmode` |\n| `.vue` | Vue SFC parser (eslint-plugin-vue) |\n| `.json` | JSON.parse() + schema validation |\n\n### Common Validation Checks ###\n\n1. **Structure**: Required sections present\n2. **Syntax**: Valid for target format\n3. **Content**: Schema content appears in output\n4. **Encoding**: UTF-8, proper escaping\n5. **Idempotency**: Same input = same output"
      },
      {
        "title": "CLI Integration",
        "content": "### Registering Your Generator ###\n\nAdd your generator to the CLI registry in `kb-cli`:\n\n```rust\n// crates/kb-cli/src/main.rs\nuse kb_markdown::MarkdownGenerator;\n\nfn build_generators() -> Vec<Box<dyn OutputGenerator>> {\n    vec![\n        Box::new(JupyterGenerator::new(\"templates/jupyter\")),\n        Box::new(MdBookGenerator::new(\"templates/mdbook\")),\n        Box::new(MarkdownGenerator::new(\"templates/markdown\")),  // Add here\n        // ... other generators\n    ]\n}\n```\n\n### CLI Commands ###\n\n```bash\n# Generate all formats\nmathhook-kb build --schema schemas/derivative.yaml\n\n# Generate specific format\nmathhook-kb build --schema schemas/derivative.yaml --format markdown\n\n# Validate only (no generation)\nmathhook-kb validate --schema schemas/\n```"
      }
    ],
    "sidebars": [
      {
        "type": "note",
        "title": "Existing Generators",
        "content": "Study these for patterns:\n- `kb-jupyter`: JSON output, complex structure\n- `kb-mdbook`: Markdown with special syntax\n- `kb-vue`: JSON data for Vue consumption\n- `kb-latex`: Escaped special characters"
      },
      {
        "type": "warning",
        "title": "Critical Requirements",
        "content": "Your generator MUST:\n1. Validate output before writing\n2. Produce identical output on repeated runs\n3. Handle all schema fields (required + optional)\n4. Report errors with file/line context"
      }
    ]
  },
  "use_cases": [
    "Adding new documentation format support",
    "Understanding generator architecture",
    "Creating custom templates",
    "Writing generator tests"
  ],
  "related_topics": [
    "dev-claude-md",
    "dev-architecture",
    "dev-schema-reference"
  ]
}
