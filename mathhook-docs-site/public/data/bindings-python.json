{
  "topic": "bindings.python",
  "title": "Python API Guide",
  "description": "Complete guide to using MathHook from Python via PyO3 bindings.\nProvides comprehensive documentation for the Python API including installation,\nquick start, API reference, performance comparisons with SymPy, and integration patterns.\n",
  "code_refs": {
    "rust": "mathhook",
    "python": "mathhook",
    "nodejs": "mathhook-node"
  },
  "examples": [
    {
      "title": "Basic Symbol Creation and Expression Building",
      "explanation": "Create symbols and build expressions using operator overloading",
      "code": {
        "rust": "use mathhook::symbol;\nuse mathhook::expr;\n\nlet x = symbol!(x);\nlet y = symbol!(y);\n\n// Build expressions\nlet expr = expr!(x^2 + 2*x + 1);\nlet expr2 = expr!((x + 1) * (x - 1));\nlet expr3 = expr!(x / (x + 1));\nlet expr4 = expr!(-x);\n",
        "python": "from mathhook import Symbol\n\nx = Symbol('x')\ny = Symbol('y')\n\n# Arithmetic operators\nexpr = x**2 + 2*x + 1\nexpr2 = (x + 1) * (x - 1)\nexpr3 = x / (x + 1)\nexpr4 = -x\n",
        "nodejs": "const { Symbol, parse } = require('mathhook');\n\nconst x = new Symbol('x');\nconst y = new Symbol('y');\n\n// Parse expressions\nconst expr = parse('x^2 + 2*x + 1');\nconst expr2 = parse('(x + 1) * (x - 1)');\nconst expr3 = parse('x / (x + 1)');\nconst expr4 = parse('-x');\n"
      }
    },
    {
      "title": "Expression Simplification",
      "explanation": "Simplify algebraic expressions using MathHook",
      "code": {
        "rust": "use mathhook::{expr, symbol, simplify};\n\nlet x = symbol!(x);\nlet expr = expr!(x + x);\nlet result = simplify(expr);  // 2*x\n\nlet expr2 = expr!((x + 1) * (x - 1));\nlet result2 = simplify(expr2);  // x^2 - 1\n",
        "python": "from mathhook import parse, simplify\n\nexpr = parse(\"x + x\")\nresult = simplify(expr)  # 2*x\n\nexpr = parse(\"(x + 1) * (x - 1)\")\nresult = simplify(expr)  # x^2 - 1\n",
        "nodejs": "const { parse, simplify } = require('mathhook');\n\nconst expr = parse('x + x');\nconst result = simplify(expr);  // 2*x\n\nconst expr2 = parse('(x + 1) * (x - 1)');\nconst result2 = simplify(expr2);  // x^2 - 1\n"
      }
    },
    {
      "title": "Symbolic Differentiation",
      "explanation": "Compute derivatives symbolically",
      "code": {
        "rust": "use mathhook::{expr, symbol, derivative};\n\nlet x = symbol!(x);\nlet expr = expr!(x^3);\n\n// First derivative\nlet df = derivative(&expr, &x, 1);\n// Result: 3*x^2\n\n// Second derivative\nlet d2f = derivative(&expr, &x, 2);\n// Result: 6*x\n\n// Partial derivatives\nlet y = symbol!(y);\nlet expr2 = expr!(x^2 * y);\nlet df_dx = derivative(&expr2, &x, 1);  // 2*x*y\nlet df_dy = derivative(&expr2, &y, 1);  // x^2\n",
        "python": "from mathhook import Symbol, derivative\n\nx = Symbol('x')\nexpr = x**3\n\n# First derivative\ndf = derivative(expr, x)\nprint(df)  # 3*x^2\n\n# Second derivative\nd2f = derivative(expr, x, order=2)\nprint(d2f)  # 6*x\n\n# Partial derivatives\ny = Symbol('y')\nexpr = x**2 * y\ndf_dx = derivative(expr, x)  # 2*x*y\ndf_dy = derivative(expr, y)  # x^2\n",
        "nodejs": "const { Symbol, parse, derivative } = require('mathhook');\n\nconst x = new Symbol('x');\nconst expr = parse('x^3');\n\n// First derivative\nconst df = derivative(expr, x);\nconsole.log(df.toString());  // 3*x^2\n\n// Second derivative\nconst d2f = derivative(expr, x, { order: 2 });\nconsole.log(d2f.toString());  // 6*x\n"
      }
    },
    {
      "title": "Equation Solving",
      "explanation": "Solve algebraic equations symbolically",
      "code": {
        "rust": "use mathhook::{expr, symbol, solve};\n\nlet x = symbol!(x);\n\n// Linear equation: 2*x + 3 = 7\nlet solutions = solve(expr!(2*x + 3), expr!(7), &x);\n// Result: [x = 2]\n\n// Quadratic equation: x^2 - 5*x + 6 = 0\nlet solutions = solve(expr!(x^2 - 5*x + 6), expr!(0), &x);\n// Result: [x = 2, x = 3]\n",
        "python": "from mathhook import Symbol, solve\n\nx = Symbol('x')\n\n# Linear equation: 2*x + 3 = 7\nsolutions = solve(2*x + 3, 7, x)\nprint(solutions)  # [x = 2]\n\n# Quadratic equation: x^2 - 5*x + 6 = 0\nsolutions = solve(x**2 - 5*x + 6, 0, x)\nprint(solutions)  # [x = 2, x = 3]\n\n# Multiple variables\ny = Symbol('y')\nsolutions = solve([x + y - 5, x - y - 1], [x, y])\nprint(solutions)  # {x: 3, y: 2}\n",
        "nodejs": "const { Symbol, parse, solve } = require('mathhook');\n\nconst x = new Symbol('x');\n\n// Quadratic equation: x^2 - 5*x + 6 = 0\nconst expr = parse('x^2 - 5*x + 6');\nconst solutions = solve(expr, x);\n\nsolutions.forEach(sol => {\n    console.log(sol.toString());\n});\n// Output: x = 2, x = 3\n"
      }
    },
    {
      "title": "Integration with NumPy",
      "explanation": "Convert symbolic expressions to NumPy functions for numerical evaluation",
      "code": {
        "python": "import numpy as np\nfrom mathhook import Symbol, lambdify\n\nx = Symbol('x')\nexpr = x**2 + 2*x + 1\n\n# Convert to NumPy-compatible function\nf = lambdify(expr, [x], 'numpy')\n\n# Evaluate on NumPy array\nx_values = np.linspace(-5, 5, 100)\ny_values = f(x_values)\n\n# Use with NumPy operations\nmean = np.mean(y_values)\nstd = np.std(y_values)\n"
      }
    },
    {
      "title": "Evaluation with Context",
      "explanation": "Advanced evaluation with custom contexts and variable substitutions",
      "code": {
        "python": "from mathhook import PyExpression as Expression, EvalContext\n\nx = Expression.symbol(\"x\")\ny = Expression.symbol(\"y\")\n\n# Formula: x² + 2xy + y²\nexpr = x.pow(Expression.integer(2)).add(\n    Expression.integer(2).multiply(x).multiply(y)\n).add(y.pow(Expression.integer(2)))\n\n# Create numerical context with variable substitutions\nctx = EvalContext.numeric({\n    \"x\": Expression.integer(3),\n    \"y\": Expression.integer(4)\n})\n\n# Evaluate: (3)² + 2(3)(4) + (4)² = 9 + 24 + 16 = 49\nresult = expr.evaluate_with_context(ctx)\nprint(result)  # 49\n\n# Symbolic evaluation (no numerical conversion)\nctx_symbolic = EvalContext.symbolic()\nresult_symbolic = expr.evaluate_with_context(ctx_symbolic)\nprint(result_symbolic)  # x^2 + 2*x*y + y^2 (still symbolic)\n",
        "nodejs": "const { JsExpression, EvalContext, symbols } = require('mathhook');\n\nfunction symbol(name) {\n    const [sym] = symbols(name);\n    return sym;\n}\n\nconst x = symbol('x');\nconst y = symbol('y');\n\n// Formula: x² + 2xy + y²\nconst expr = x.pow(JsExpression.integer(2))\n    .add(JsExpression.integer(2).multiply(x).multiply(y))\n    .add(y.pow(JsExpression.integer(2)));\n\n// Create numerical context with variable substitutions\nconst ctx = EvalContext.numeric([\n    ['x', JsExpression.integer(3)],\n    ['y', JsExpression.integer(4)]\n]);\n\n// Evaluate: (3)² + 2(3)(4) + (4)² = 9 + 24 + 16 = 49\nconst result = expr.evaluateWithContext(ctx);\nconsole.log(result.toSimple());  // '49'\n"
      }
    }
  ],
  "article": {
    "content": "# Python API Guide\n\nComplete guide to using MathHook from Python via PyO3 bindings.\n\n## Installation\n\n```bash\npip install mathhook\n```\n\n**Requirements**:\n- Python 3.8 or higher\n- pip 20.0 or higher (for binary wheel support)\n\n**Platform Support**:\n- Linux (x86_64, aarch64)\n- macOS (Intel, Apple Silicon)\n- Windows (x86_64)\n\n## Quick Start\n\n```python\nfrom mathhook import Symbol, parse, simplify\n\n# Create symbols\nx = Symbol('x')\ny = Symbol('y')\n\n# Build expressions\nexpr = x**2 + 2*x + 1\n\n# Simplify\nsimplified = simplify(expr)\nprint(simplified)  # (x + 1)^2\n```\n\n## Why MathHook for Python?\n\n### Performance Comparison\n\n**100x Faster Than SymPy** for large expressions:\n\n```python\nimport time\nfrom mathhook import parse, simplify\n\n# Large polynomial expression\nexpr_str = \" + \".join([f\"{i}*x**{i}\" for i in range(100)])\n\n# MathHook\nstart = time.time()\nexpr = parse(expr_str)\nresult = simplify(expr)\nmathhook_time = time.time() - start\n\nprint(f\"MathHook: {mathhook_time:.4f}s\")\n# Typical: MathHook 0.001s vs SymPy 0.1s (100x faster)\n```\n\n### When to Use MathHook vs SymPy\n\n**Use MathHook when**:\n- Performance is critical (real-time applications, large expressions)\n- You need symbolic preprocessing for numerical simulations\n- Working with expressions with >50 terms\n- Building interactive applications (web, Jupyter with fast response)\n\n**Use SymPy when**:\n- Need advanced features: logic, sets, abstract algebra\n- Educational prototyping (rich ecosystem)\n- Assumption system is critical\n- Working with small expressions where speed doesn't matter\n\n**Use Both**:\n- Prototype with SymPy, optimize with MathHook for production\n- Use MathHook for hot loops, SymPy for one-time complex operations\n"
  },
  "related_topics": [
    "bindings.nodejs",
    "bindings.wasm",
    "getting-started.installation",
    "operations.simplification",
    "operations.differentiation",
    "operations.integration"
  ],
  "metadata": {
    "schema_version": "1.0"
  }
}