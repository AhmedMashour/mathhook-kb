{
  "topic": "introduction.architecture",
  "title": "MathHook Architecture",
  "description": "Deep dive into MathHook's internal architecture, design decisions, and implementation\ndetails. Understanding the architecture helps contributors and advanced users leverage\nMathHook's full capabilities.\n",
  "mathematical_definition": "The architecture follows functional programming principles with immutable data structures,\nensuring mathematical correctness through type safety and zero-cost abstractions.\n",
  "code_refs": {
    "rust": "mathhook_core",
    "python": "mathhook",
    "nodejs": "mathhook"
  },
  "quick_reference": {
    "core_types": [
      "Expression (32 bytes): Central enum representing all mathematical expressions",
      "Number (16 bytes): Tagged union for integers, rationals, floats",
      "Symbol: String-interned variables with assumptions",
      "Function: Universal function intelligence system"
    ],
    "architectural_constraints": [
      "32-byte Expression size (cache-line optimization)",
      "16-byte Number size (exact arithmetic)",
      "Zero-copy parsing where possible",
      "Thread-safe immutable expressions"
    ],
    "performance_techniques": [
      "SIMD vectorization for array operations",
      "Arena allocation for bulk expression creation",
      "String interning for fast symbol comparison",
      "Lazy evaluation with memoization"
    ]
  },
  "examples": [
    {
      "title": "Expression Type Internal Structure",
      "explanation": "The Expression enum is the heart of MathHook, representing all mathematical expressions\nin a 32-byte structure optimized for cache performance.\n",
      "code": {
        "rust": "use mathhook_core::core::expression::Expression;\nuse std::mem::size_of;\n\n// Verify size constraint\nassert_eq!(size_of::<Expression>(), 32);\n\n// Expression variants\nlet num = Expression::integer(42);              // Number variant\nlet sym = Expression::symbol(Symbol::new(\"x\")); // Symbol variant\nlet add = Expression::add(vec![num, sym]);      // Add variant\nlet mul = Expression::mul(vec![                 // Multiply variant\n    Expression::integer(2),\n    Expression::symbol(Symbol::new(\"x\"))\n]);\nlet pow = Expression::pow(sym, Expression::integer(2)); // Power variant\nlet func = Expression::function(\"sin\", vec![sym]);       // Function variant\n\n// Each fits in 32 bytes due to Box<T> for heap allocation of large data\nprintln!(\"Expression size: {} bytes\", size_of::<Expression>());\n",
        "python": "# Python API abstracts internal structure\nfrom mathhook import expr, symbol\nimport sys\n\nx = symbol('x')\n\n# These create different Expression variants internally\nnum = expr('42')              # Number\nsym = expr('x')               # Symbol\nadd = expr('x + 42')          # Add\nmul = expr('2*x')             # Multiply\npow = expr('x^2')             # Power\nfunc = expr('sin(x)')         # Function\n\n# Python objects wrap the Rust Expression type\nprint(f\"Python wrapper size: {sys.getsizeof(num)} bytes\")\nprint(f\"Rust core is 32 bytes\")\n",
        "nodejs": "const { expr, symbol } = require('mathhook');\n\nconst x = symbol('x');\n\n// These create different Expression variants internally\nconst num = expr('42');         // Number\nconst sym = expr('x');          // Symbol\nconst add = expr('x + 42');     // Add\nconst mul = expr('2*x');        // Multiply\nconst pow = expr('x^2');        // Power\nconst func = expr('sin(x)');    // Function\n\nconsole.log('JavaScript wrappers use Rust core (32 bytes)');\n"
      },
      "expected_output": "Expression size: 32 bytes\nEach variant optimized for cache performance\n"
    },
    {
      "title": "Number Type Exact Arithmetic",
      "explanation": "The Number type uses a 16-byte tagged union to represent integers, rationals,\nand floats while preserving mathematical exactness.\n",
      "code": {
        "rust": "use mathhook_core::core::number::Number;\n\n// Exact integer arithmetic\nlet a = Number::integer(123456789);\nlet b = Number::integer(987654321);\nlet sum = a + b;  // Exact: 1111111110\n\n// Exact rational arithmetic (NEVER use floats for symbolics)\nlet one_third = Number::rational(1, 3);\nlet two_fifths = Number::rational(2, 5);\nlet sum = one_third + two_fifths;  // Exact: 11/15, not 0.733...\n\n// Rationals are automatically reduced\nlet reduced = Number::rational(6, 9);  // Becomes 2/3\n\n// Float arithmetic (only for numerical approximation)\nlet pi_approx = Number::float(3.14159);\nlet e_approx = Number::float(2.71828);\nlet product = pi_approx * e_approx;  // Approximate: 8.5397...\n\nprintln!(\"1/3 + 2/5 = {}\", sum);  // 11/15 (exact)\n",
        "python": "from mathhook import Number\n\n# Exact integer\na = Number.integer(123456789)\nb = Number.integer(987654321)\nsum_val = a + b  # Exact\n\n# Exact rational (preferred for symbolic math)\none_third = Number.rational(1, 3)\ntwo_fifths = Number.rational(2, 5)\nsum_val = one_third + two_fifths  # 11/15 exact\n\n# Float (only when needed)\npi_approx = Number.float(3.14159)\n\nprint(f\"1/3 + 2/5 = {sum_val}\")  # 11/15\n",
        "nodejs": "const { Number } = require('mathhook');\n\n// Exact rational arithmetic\nconst oneThird = Number.rational(1, 3);\nconst twoFifths = Number.rational(2, 5);\nconst sum = oneThird.add(twoFifths);  // 11/15 exact\n\nconsole.log(`1/3 + 2/5 = ${sum.toString()}`);  // \"11/15\"\n"
      },
      "expected_output": "1/3 + 2/5 = 11/15 (exact rational, not 0.733...)\nPreserves mathematical exactness\n"
    },
    {
      "title": "Symbol System with Assumptions",
      "explanation": "Symbols use string interning for O(1) equality comparison and support\nmathematical assumptions for smarter simplification.\n",
      "code": {
        "rust": "use mathhook_core::core::symbol::Symbol;\n\n// Basic symbols\nlet x = Symbol::new(\"x\");\nlet y = Symbol::new(\"y\");\n\n// Symbols with assumptions\nlet positive_x = Symbol::new(\"x\").with_assumption(Assumption::Positive);\nlet integer_n = Symbol::new(\"n\").with_assumption(Assumption::Integer);\nlet real_a = Symbol::new(\"a\").with_assumption(Assumption::Real);\n\n// Assumptions affect simplification\nlet expr = Expression::pow(positive_x.into(), Expression::integer(2));\n// Simplifier knows x > 0, so x^2 > 0\n\n// Check assumptions\nif positive_x.is_positive() {\n    println!(\"x is positive, sqrt(x^2) = x (not |x|)\");\n}\n",
        "python": "from mathhook import symbol\n\n# Symbols with assumptions\nx = symbol('x', positive=True)\nn = symbol('n', integer=True)\na = symbol('a', real=True)\n\n# Assumptions guide simplification\nfrom mathhook import expr, simplify\n\n# sqrt(x^2) simplified differently based on assumptions\nexpr_default = expr('sqrt(x^2)')\n# Result: |x| (because x could be negative)\n\nexpr_positive = expr('sqrt(x^2)').with_assumption(x, positive=True)\n# Result: x (because x > 0)\n",
        "nodejs": "const { symbol } = require('mathhook');\n\n// Symbols with assumptions\nconst x = symbol('x', { positive: true });\nconst n = symbol('n', { integer: true });\nconst a = symbol('a', { real: true });\n\nconsole.log('Assumptions guide intelligent simplification');\n"
      },
      "expected_output": "Symbol interning: O(1) equality comparison\nAssumptions: sqrt(x\u00b2) = x (if x > 0), |x| (otherwise)\n"
    }
  ],
  "article": {
    "sections": [
      {
        "heading": "Core Type System",
        "content": "**Expression Enum (32 bytes)**:\n\nThe central type representing all mathematical expressions:\n\n```rust\npub enum Expression {\n    Number(Number),                          // 16 bytes + discriminant\n    Symbol(Symbol),                          // 8 bytes (Arc<String>) + discriminant\n    Add(Box<Vec<Expression>>),               // 8 bytes (pointer) + discriminant\n    Multiply(Box<Vec<Expression>>),          // 8 bytes (pointer) + discriminant\n    Power(Box<(Expression, Expression)>),    // 8 bytes (pointer) + discriminant\n    Function(Box<FunctionCall>),             // 8 bytes (pointer) + discriminant\n    Equality(Box<(Expression, Expression)>), // 8 bytes (pointer) + discriminant\n    // ... other variants\n}\n```\n\n**Design rationale**:\n- 32 bytes allows 2 expressions per 64-byte cache line (standard on modern CPUs)\n- Box<T> moves large data to heap, keeping enum size small\n- Cache-friendly layout improves performance by 20-40% in benchmarks\n\n**Number Type (16 bytes)**:\n\n```rust\npub enum Number {\n    Integer(i64),                      // 8 bytes + 8-byte discriminant\n    BigInteger(Box<BigInt>),           // 8 bytes pointer\n    Rational(Box<(BigInt, BigInt)>),   // 8 bytes pointer\n    Float(f64),                        // 8 bytes + padding\n}\n```\n\n**Symbol Type**:\n\n```rust\npub struct Symbol {\n    name: Arc<String>,           // String interning via Arc\n    assumptions: Assumptions,    // Bitflags for properties\n}\n```\n"
      },
      {
        "heading": "Memory Management",
        "content": "**Immutability**:\nAll expressions are immutable after creation. Operations produce new expressions\nrather than modifying existing ones.\n\nBenefits:\n- Thread safety without locks\n- Referential transparency (functional programming)\n- Safe sharing across threads via Arc\n- Easier to reason about correctness\n\n**Arena Allocation**:\nFor bulk expression creation, use arena allocation to reduce overhead:\n\n```rust\nuse mathhook_core::core::arena::Arena;\n\nlet arena = Arena::new();\n\n// Allocate many expressions efficiently\nfor i in 0..10000 {\n    let expr = arena.alloc(Expression::integer(i));\n    // All freed at once when arena drops\n}\n```\n\n**String Interning**:\nSymbols use string interning for fast equality comparison:\n\n```rust\nlet x1 = Symbol::new(\"x\");\nlet x2 = Symbol::new(\"x\");\nassert!(Arc::ptr_eq(&x1.name, &x2.name));  // Same pointer!\n```\n"
      },
      {
        "heading": "Parser Architecture (LALRPOP)",
        "content": "**Two-Stage Parsing**:\n\n1. **Lexer** (in `parser/lexer/`): Tokenization + implicit multiplication\n   - Converts `2x` \u2192 `2 * x`\n   - Handles `(a)(b)` \u2192 `a * b`\n   - Distinguishes function calls from multiplication: `sin(x)` \u2260 `sin * (x)`\n\n2. **Parser** (LALRPOP grammar): LR(1) parser with one-token lookahead\n   - Grammar file: `parser/grammar.lalrpop`\n   - Generated Rust code: `parser/grammar.rs` (don't edit manually)\n\n**Operator Precedence** (highest to lowest):\n1. Function application: `sin(x)`, `log(y)`\n2. Exponentiation: `^` (right-associative)\n3. Implicit/explicit multiplication: `*`, `/`\n4. Addition/subtraction: `+`, `-`\n\n**LaTeX Support**:\n- Parses LaTeX: `\\frac{dy}{dx}`, `\\int x^2 dx`, `\\sum_{i=1}^n i`\n- Standard notation: `x^2 + 3x + 1`\n- Wolfram-like syntax: `D[x^2, x]`\n"
      },
      {
        "heading": "Universal Function System",
        "content": "**Function Registry**:\n\nGlobal registry providing O(1) lookup for function intelligence:\n\n```rust\npub struct UniversalFunctionRegistry {\n    functions: HashMap<String, Box<dyn FunctionIntelligence>>,\n}\n\npub trait FunctionIntelligence {\n    fn evaluate(&self, args: &[Expression]) -> EvaluationResult;\n    fn properties(&self) -> &FunctionProperties;\n    fn simplify(&self, args: &[Expression]) -> Expression;\n    fn explain(&self) -> EducationalExplanation;\n}\n```\n\n**Function Families**:\n- **Elementary**: sin, cos, exp, log, sqrt\n- **Special**: gamma, bessel, legendre, hermite\n- **Number Theory**: factorial, gcd, lcm, prime\n- **Polynomials**: chebyshev, laguerre\n\n**Intelligence Per Function**:\n- Evaluation strategy (symbolic vs numerical)\n- Domain/range restrictions\n- Symmetries (even, odd, periodic)\n- Special values: sin(\u03c0) = 0, not 1.2246467991473532e-16\n- Derivatives and integrals\n"
      },
      {
        "heading": "SIMD Optimizations",
        "content": "**Vectorized Operations**:\n\nMathHook uses SIMD (Single Instruction, Multiple Data) for array arithmetic:\n\n```rust\nuse mathhook_core::core::performance::simd;\n\n// Evaluate polynomial at 1000 points simultaneously\nlet coeffs = vec![1.0, -2.0, 3.0];  // x^2 - 2x + 3\nlet x_vals: Vec<f64> = (0..1000).map(|i| i as f64 * 0.01).collect();\n\nlet results = simd::evaluate_polynomial_batch(&coeffs, &x_vals);\n// Uses AVX2 to process 4 floats per instruction\n```\n\n**Feature Flags**:\n- `avx2`: Advanced Vector Extensions 2 (256-bit)\n- `sse2`: Streaming SIMD Extensions 2 (128-bit, fallback)\n- Automatic runtime detection and dispatch\n\n**Performance Gains**:\n- 4-8x speedup for numerical evaluation on arrays\n- Batch differentiation and integration\n- Matrix operations\n"
      },
      {
        "heading": "Canonical Forms and Simplification",
        "content": "**Canonical Form Rules**:\n\nEvery expression is automatically converted to canonical form:\n\n1. **Commutative sorting**: `y + x` \u2192 `x + y`\n2. **Associativity flattening**: `(a + b) + c` \u2192 `Add(a, b, c)`\n3. **Identity elimination**: `x + 0` \u2192 `x`, `x * 1` \u2192 `x`\n4. **Rational reduction**: `6/4` \u2192 `3/2`\n\n**Simplification Pipeline**:\n\n```rust\npub fn simplify(expr: &Expression) -> Expression {\n    let expr = to_canonical(expr);         // Step 1: Canonical form\n    let expr = apply_identities(expr);     // Step 2: Algebraic identities\n    let expr = combine_like_terms(expr);   // Step 3: Combine terms\n    let expr = numerical_evaluate(expr);   // Step 4: Constant folding\n    expr\n}\n```\n\n**Zero Detection**:\n- Exact zero: `x - x` \u2192 `0`\n- Symbolic zero: requires advanced techniques (Gr\u00f6bner bases)\n- Numerical zero: epsilon comparison for floats\n"
      },
      {
        "heading": "Educational System",
        "content": "**Step-by-Step Explanations**:\n\nEvery operation can provide educational explanations:\n\n```rust\npub struct EducationalExplanation {\n    operation: String,\n    theory: String,\n    when_to_use: String,\n    common_mistakes: Vec<String>,\n    examples: Vec<Example>,\n}\n\npub struct EducationalRegistry {\n    explanations: HashMap<String, EducationalExplanation>,\n}\n```\n\n**Message Keys**:\n- `quadratic_formula`: When and how to apply\n- `integration_by_parts`: LIATE rule explanation\n- `chain_rule`: Composition of functions\n- `left_division_explanation`: Matrix equations\n"
      },
      {
        "heading": "Thread Safety and Concurrency",
        "content": "**Immutable Expressions**:\n- All `Expression` types are immutable\n- Safe to share across threads via `Arc<Expression>`\n- No locks needed for read-only operations\n\n**Thread-Safe Components**:\n- **Symbol interning**: Uses `DashMap` for concurrent access\n- **Function registry**: Immutable after initialization\n- **Number arithmetic**: No shared mutable state\n\n**Parallelization Opportunities**:\n- Simplification of independent subexpressions\n- Batch numerical evaluation\n- Parallel solving of system equations\n"
      }
    ]
  },
  "use_cases": [
    "Understanding MathHook internals for contributors",
    "Performance optimization by understanding architecture",
    "Building domain-specific extensions",
    "Advanced symbolic manipulation techniques"
  ],
  "related_topics": [
    "introduction.overview",
    "introduction.performance",
    "getting-started.quick-start"
  ],
  "references": [
    {
      "title": "MathHook CLAUDE.md",
      "url": "https://github.com/AhmedMashour/mathhook/blob/master/CLAUDE.md"
    },
    {
      "title": "Rust Performance Book",
      "url": "https://nnethercote.github.io/perf-book/"
    },
    {
      "title": "LALRPOP Documentation",
      "url": "http://lalrpop.github.io/lalrpop/"
    }
  ],
  "performance": {
    "complexity": "O(1) for most type operations, O(n) for traversal",
    "typical_time": "Expression creation: < 100ns, Symbol interning: < 50ns",
    "benchmarks": {
      "expression_size": "32 bytes",
      "number_size": "16 bytes",
      "symbol_creation": "< 50ns with interning",
      "cache_efficiency": "2 expressions per 64-byte cache line"
    }
  }
}