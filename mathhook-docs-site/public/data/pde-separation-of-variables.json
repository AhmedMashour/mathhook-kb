{
  "topic": "pde.separation-of-variables",
  "title": "Separation of Variables for PDEs",
  "description": "Separation of variables is the fundamental technique for solving linear partial differential\nequations (PDEs) with boundary conditions. This method transforms a PDE into a system of\nordinary differential equations (ODEs) that can be solved independently, then combines the\nsolutions into an infinite series.\n",
  "mathematical_definition": "For a PDE with two independent variables ($x$ and $t$), the **product ansatz** assumes:\n\n$$u(x,t) = X(x) \\cdot T(t)$$\n\nwhere $X(x)$ depends **only** on spatial variable $x$ and $T(t)$ depends **only** on\ntemporal variable $t$.\n",
  "code_refs": {
    "rust": "mathhook_core::pde::separation_of_variables",
    "python": "mathhook.pde.separation_of_variables",
    "nodejs": "mathhook.pde.separationOfVariables"
  },
  "examples": [
    {
      "title": "Heat Equation with Dirichlet BCs",
      "explanation": "Solve 1D heat equation with fixed boundary conditions",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet u = symbol!(u);\nlet x = symbol!(x);\nlet t = symbol!(t);\nlet alpha = symbol!(alpha);\n\nlet equation = expr!(u);\nlet pde = Pde::new(equation, u, vec![x.clone(), t.clone()]);\n\n// Boundary conditions: u(0,t) = 0, u(π,t) = 0\nlet bc_left = BoundaryCondition::dirichlet_at(x.clone(), expr!(0), expr!(0));\nlet bc_right = BoundaryCondition::dirichlet_at(x.clone(), expr!(pi), expr!(0));\nlet bcs = vec![bc_left, bc_right];\n\n// Initial condition: u(x,0) = sin(x)\nlet ic = InitialCondition::value(expr!(sin(x)));\nlet ics = vec![ic];\n\nlet solution = separate_variables(&pde, &bcs, &ics)?;\n// Result: eigenvalues [1, 4, 9, 16, ...], eigenfunctions [sin(x), sin(2x), ...]\n",
        "python": "from mathhook import symbol, expr\nfrom mathhook.pde import Pde, BoundaryCondition, InitialCondition, separate_variables\n\nu = symbol('u')\nx = symbol('x')\nt = symbol('t')\n\npde = Pde(u, u, [x, t])\n\n# Boundary conditions\nbc_left = BoundaryCondition.dirichlet_at(x, expr('0'), expr('0'))\nbc_right = BoundaryCondition.dirichlet_at(x, expr('pi'), expr('0'))\nbcs = [bc_left, bc_right]\n\n# Initial condition\nic = InitialCondition.value(expr('sin(x)'))\nics = [ic]\n\nsolution = separate_variables(pde, bcs, ics)\n# Result: eigenvalues [1, 4, 9, 16, ...], eigenfunctions [sin(x), sin(2x), ...]\n",
        "nodejs": "const { symbol, expr } = require('mathhook');\nconst { Pde, BoundaryCondition, InitialCondition, separateVariables } = require('mathhook/pde');\n\nconst u = symbol('u');\nconst x = symbol('x');\nconst t = symbol('t');\n\nconst pde = new Pde(u, u, [x, t]);\n\n// Boundary conditions\nconst bcLeft = BoundaryCondition.dirichletAt(x, expr('0'), expr('0'));\nconst bcRight = BoundaryCondition.dirichletAt(x, expr('pi'), expr('0'));\nconst bcs = [bcLeft, bcRight];\n\n// Initial condition\nconst ic = InitialCondition.value(expr('sin(x)'));\nconst ics = [ic];\n\nconst solution = separateVariables(pde, bcs, ics);\n// Result: eigenvalues [1, 4, 9, 16, ...], eigenfunctions [sin(x), sin(2x), ...]\n"
      }
    },
    {
      "title": "Wave Equation",
      "explanation": "Solve 1D wave equation with Dirichlet boundary conditions",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet u = symbol!(u);\nlet x = symbol!(x);\nlet t = symbol!(t);\nlet L = symbol!(L);\n\nlet pde = Pde::new(expr!(u), u, vec![x.clone(), t.clone()]);\n\nlet bc_left = BoundaryCondition::dirichlet_at(x.clone(), expr!(0), expr!(0));\nlet bc_right = BoundaryCondition::dirichlet_at(x.clone(), expr!(L), expr!(0));\nlet bcs = vec![bc_left, bc_right];\n\n// Initial displacement and velocity\nlet ic_displacement = InitialCondition::value(expr!(sin(pi * x / L)));\nlet ic_velocity = InitialCondition::derivative(expr!(0));\nlet ics = vec![ic_displacement, ic_velocity];\n\nlet solution = separate_variables(&pde, &bcs, &ics)?;\n",
        "python": "from mathhook import symbol, expr\nfrom mathhook.pde import Pde, BoundaryCondition, InitialCondition, separate_variables\n\nu = symbol('u')\nx = symbol('x')\nt = symbol('t')\nL = symbol('L')\n\npde = Pde(u, u, [x, t])\n\nbc_left = BoundaryCondition.dirichlet_at(x, expr('0'), expr('0'))\nbc_right = BoundaryCondition.dirichlet_at(x, L, expr('0'))\nbcs = [bc_left, bc_right]\n\nic_displacement = InitialCondition.value(expr('sin(pi*x/L)'))\nic_velocity = InitialCondition.derivative(expr('0'))\nics = [ic_displacement, ic_velocity]\n\nsolution = separate_variables(pde, bcs, ics)\n",
        "nodejs": "const { symbol, expr } = require('mathhook');\nconst { Pde, BoundaryCondition, InitialCondition, separateVariables } = require('mathhook/pde');\n\nconst u = symbol('u');\nconst x = symbol('x');\nconst t = symbol('t');\nconst L = symbol('L');\n\nconst pde = new Pde(u, u, [x, t]);\n\nconst bcLeft = BoundaryCondition.dirichletAt(x, expr('0'), expr('0'));\nconst bcRight = BoundaryCondition.dirichletAt(x, L, expr('0'));\nconst bcs = [bcLeft, bcRight];\n\nconst icDisplacement = InitialCondition.value(expr('sin(pi*x/L)'));\nconst icVelocity = InitialCondition.derivative(expr('0'));\nconst ics = [icDisplacement, icVelocity];\n\nconst solution = separateVariables(pde, bcs, ics);\n"
      }
    },
    {
      "title": "Laplace Equation on Rectangle",
      "explanation": "Solve Laplace's equation on rectangular domain",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet u = symbol!(u);\nlet x = symbol!(x);\nlet y = symbol!(y);\nlet a = symbol!(a);\n\nlet pde = Pde::new(expr!(u), u, vec![x.clone(), y.clone()]);\n\nlet bc_left = BoundaryCondition::dirichlet_at(x.clone(), expr!(0), expr!(0));\nlet bc_right = BoundaryCondition::dirichlet_at(x.clone(), expr!(a), expr!(0));\nlet bcs = vec![bc_left, bc_right];\n\nlet ics = vec![];  // Laplace is elliptic, not time-dependent\n\nlet solution = separate_variables(&pde, &bcs, &ics)?;\n",
        "python": "from mathhook import symbol, expr\nfrom mathhook.pde import Pde, BoundaryCondition, separate_variables\n\nu = symbol('u')\nx = symbol('x')\ny = symbol('y')\na = symbol('a')\n\npde = Pde(u, u, [x, y])\n\nbc_left = BoundaryCondition.dirichlet_at(x, expr('0'), expr('0'))\nbc_right = BoundaryCondition.dirichlet_at(x, a, expr('0'))\nbcs = [bc_left, bc_right]\n\nics = []  # Laplace is elliptic\n\nsolution = separate_variables(pde, bcs, ics)\n",
        "nodejs": "const { symbol, expr } = require('mathhook');\nconst { Pde, BoundaryCondition, separateVariables } = require('mathhook/pde');\n\nconst u = symbol('u');\nconst x = symbol('x');\nconst y = symbol('y');\nconst a = symbol('a');\n\nconst pde = new Pde(u, u, [x, y]);\n\nconst bcLeft = BoundaryCondition.dirichletAt(x, expr('0'), expr('0'));\nconst bcRight = BoundaryCondition.dirichletAt(x, a, expr('0'));\nconst bcs = [bcLeft, bcRight];\n\nconst ics = [];  // Laplace is elliptic\n\nconst solution = separateVariables(pde, bcs, ics);\n"
      }
    }
  ],
  "article": {
    "content": "# Separation of Variables for PDEs\n\n**Applies to:** Linear second-order PDEs with separable boundary conditions\n**Equation types:** Heat equation, wave equation, Laplace equation, and more\n**Key idea:** Assume solution is a product of single-variable functions\n**MathHook implementation:** Complete workflow from separation to series solution\n\n## Mathematical Background\n\n### What is Separation of Variables?\n\nFor a PDE with two independent variables ($x$ and $t$), the **product ansatz** assumes:\n\n$$u(x,t) = X(x) \\cdot T(t)$$\n\nwhere:\n- $X(x)$ depends **only** on spatial variable $x$\n- $T(t)$ depends **only** on temporal variable $t$\n\n**Key insight:** By substituting this product form into the PDE, we can separate the equation into two independent ODEs—one for $X(x)$ and one for $T(t)$.\n\n### When Does Separation Work?\n\n**Requirements:**\n\n1. **Linear PDE:** The PDE must be linear in $u$ and its derivatives\n2. **Separable boundary conditions:** Boundary conditions must only involve one variable\n3. **Product domain:** Domain must be a product of intervals (e.g., $[0, L] \\times [0, \\infty)$)\n\n**Common examples:**\n- Heat equation: $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$\n- Wave equation: $\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}$\n- Laplace equation: $\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0$\n\n### The Separation Process (Overview)\n\n1. **Substitute product ansatz** $u(x,t) = X(x)T(t)$ into PDE\n2. **Separate variables:** Divide to get $\\frac{f(x)}{g(t)} = \\text{constant}$\n3. **Introduce separation constant** $\\lambda$: Each side must equal $-\\lambda$\n4. **Solve spatial ODE** with boundary conditions → eigenvalues $\\lambda_n$ and eigenfunctions $X_n(x)$\n5. **Solve temporal ODE** for each $\\lambda_n$ → temporal solutions $T_n(t)$\n6. **Superposition:** General solution is $u(x,t) = \\sum_{n=1}^{\\infty} c_n X_n(x) T_n(t)$\n7. **Apply initial conditions** → determine coefficients $c_n$ (Fourier series)\n"
  },
  "use_cases": [
    "Heat diffusion in one-dimensional rods",
    "Vibrating string problems",
    "Electrostatic potential distribution",
    "Quantum mechanics (Schrödinger equation)",
    "Acoustic wave propagation"
  ],
  "related_topics": [
    "pde.heat-equation",
    "pde.wave-equation",
    "pde.laplace-equation",
    "pde.fourier-coefficients",
    "pde.eigenvalue-problems",
    "pde.boundary-conditions"
  ],
  "performance": {},
  "metadata": {
    "schema_version": "1.0",
    "last_updated": "2025-01-20"
  }
}