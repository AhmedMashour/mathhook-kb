{
  "topic": "internal.planning.matrix-solver-integration",
  "title": "Matrix Solver Integration Plan",
  "description": "Connect existing matrix decompositions (LU, QR, Cholesky) with solver infrastructure.\nEliminates code duplication where SystemSolver.solve_nxn_system() reimplements Gaussian\nelimination despite Matrix.lu_decomposition() already existing.\n",
  "article": {
    "content": "# Matrix Solver Integration Plan\n\n**Date**: 2025-12-06T1530\n**Status**: Ready for Execution\n**Estimated Effort**: 3.5 days\n\n---\n\n## Executive Summary\n\nConnect existing matrix decompositions (LU, QR, Cholesky) with solver infrastructure. Currently `SystemSolver.solve_nxn_system()` reimplements Gaussian elimination despite `Matrix.lu_decomposition()` already existing. This plan eliminates that duplication.\n\n---\n\n## Phase 0: Forward/Backward Substitution (Foundation)\n\n**Priority**: P0 - Required for all subsequent phases\n**File**: `crates/mathhook-core/src/matrices/unified/operations.rs`\n\n### Methods to Add\n\n```rust\nimpl Matrix {\n    /// Solve Lx = b for lower triangular L\n    pub fn forward_substitution(&self, b: &[Expression]) -> Result<Vec<Expression>, MathError>;\n\n    /// Solve Ux = b for upper triangular U\n    pub fn backward_substitution(&self, b: &[Expression]) -> Result<Vec<Expression>, MathError>;\n}\n```\n\n### Algorithms\n\n**Forward substitution** (Ly = b):\n```\nFor i = 0 to n-1:\n    sum = Σ(L[i][j] * x[j]) for j = 0 to i-1\n    x[i] = (b[i] - sum) / L[i][i]\n    if L[i][i] == 0: return Err(DivisionByZero)\n```\n\n**Backward substitution** (Ux = y):\n```\nFor i = n-1 down to 0:\n    sum = Σ(U[i][j] * x[j]) for j = i+1 to n-1\n    x[i] = (b[i] - sum) / U[i][i]\n    if U[i][i] == 0: return Err(DivisionByZero)\n```\n\n### Tests Required\n- Identity matrix (trivial)\n- 2x2, 3x3 triangular matrices\n- Zero diagonal element → DivisionByZero\n- Symbolic coefficients\n\n---\n\n## Phase 1: Matrix.solve(b) Using LU\n\n**Priority**: P0 - Core integration\n**File**: `crates/mathhook-core/src/matrices/unified/operations.rs`\n\n### Method to Add\n\n```rust\nimpl Matrix {\n    /// Solve Ax = b using LU decomposition\n    ///\n    /// Algorithm:\n    /// 1. Compute PA = LU\n    /// 2. Solve Ly = Pb (forward substitution)\n    /// 3. Solve Ux = y (backward substitution)\n    pub fn solve(&self, b: &[Expression]) -> Result<Vec<Expression>, MathError>;\n}\n```\n\n### Helper Needed\n\n```rust\nfn apply_permutation(p: &Option<Matrix>, b: &[Expression]) -> Vec<Expression>\n```\n\n### Error Cases\n- Non-square matrix → DomainError\n- Dimension mismatch → DomainError\n- Singular matrix → DivisionByZero\n\n### Tests Required\n- 2x2 integer solution\n- 3x3 rational solution\n- Identity matrix (trivial)\n- Singular matrix → error\n- Dimension mismatch → error\n\n---\n\n## Phase 2: Replace SystemSolver.solve_nxn_system()\n\n**Priority**: P0 - Eliminate duplication\n**File**: `crates/mathhook-core/src/algebra/solvers/systems.rs`\n\n### Current State (lines 407-518)\n- Manually extracts coefficients into augmented matrix\n- Reimplements Gaussian elimination with partial pivoting\n- Performs back substitution inline\n\n### Refactored Approach\n\n```rust\nfn solve_nxn_system(&self, equations: &[Expression], variables: &[Symbol]) -> SolverResult {\n    // 1. Build coefficient matrix A and RHS vector b\n    let (a_matrix, b_vec) = self.build_system_matrix(equations, variables);\n\n    // 2. Use Matrix.solve() which uses LU decomposition\n    match a_matrix.solve(&b_vec) {\n        Ok(solution) => SolverResult::Multiple(solution),\n        Err(MathError::DivisionByZero) => self.check_singularity_type(&a_matrix, &b_vec),\n        Err(_) => SolverResult::NoSolution,\n    }\n}\n```\n\n### Lines to Delete\n- Lines 426-479 (Gaussian elimination reimplementation)\n- Lines 480-518 (back substitution reimplementation)\n\n### Import to Add\n```rust\nuse crate::matrices::Matrix;\n```\n\n---\n\n## Phase 3: SPD Detection → Cholesky Routing\n\n**Priority**: P1 - Performance optimization\n**File**: `crates/mathhook-core/src/matrices/unified/operations.rs`\n\n### Enhanced solve() Method\n\n```rust\npub fn solve(&self, b: &[Expression]) -> Result<Vec<Expression>, MathError> {\n    // Try Cholesky first for SPD matrices (2x faster)\n    if self.is_symmetric() {\n        if let Some(chol) = self.cholesky_decomposition() {\n            let y = chol.l.forward_substitution(b)?;\n            let lt = chol.l.transpose();\n            return lt.backward_substitution(&y);\n        }\n    }\n\n    // Fall back to LU\n    self.solve_via_lu(b)\n}\n```\n\n### Expected Performance\n- 2x speedup for symmetric positive definite matrices\n\n---\n\n## Phase 4: QR-Based Least Squares\n\n**Priority**: P1 - Overdetermined systems\n**File**: `crates/mathhook-core/src/matrices/unified/operations.rs`\n\n### Method to Add\n\n```rust\nimpl Matrix {\n    /// Solve min ||Ax - b||_2 using QR decomposition\n    ///\n    /// For m×n matrix (m >= n):\n    /// 1. Compute A = QR\n    /// 2. Compute Q^T * b\n    /// 3. Solve Rx = (Q^T * b)[0:n]\n    pub fn solve_least_squares(&self, b: &[Expression]) -> Result<Vec<Expression>, MathError>;\n}\n```\n\n### Helper Needed\n\n```rust\nfn matrix_vector_multiply(m: &Matrix, v: &[Expression]) -> Vec<Expression>\n```\n\n---\n\n## Phase 5: Matrix Inversion Using LU\n\n**Priority**: P2 - Optimization\n**File**: `crates/mathhook-core/src/matrices/unified/operations.rs`\n\n### Enhanced inverse() Method\n\n```rust\nfn inverse(&self) -> Matrix {\n    match self {\n        Matrix::Identity(_) | Matrix::Scalar(_) | Matrix::Diagonal(_) => {\n            // Keep existing fast paths\n        }\n        _ => self.inverse_via_lu().unwrap_or_else(|| self.gauss_jordan_inverse()),\n    }\n}\n\nfn inverse_via_lu(&self) -> Option<Matrix> {\n    // Solve A * X = I column by column\n    for j in 0..n {\n        let e_j = unit_vector(j, n);\n        let col = self.solve(&e_j)?;\n        // Store in result matrix\n    }\n}\n```\n\n---\n\n## Dependency Order\n\n```\nPhase 0: Forward/Backward Substitution\n    ↓\nPhase 1: Matrix.solve(b)\n    ↓\nPhase 2: Replace solve_nxn_system ←── Phase 3: Cholesky Routing\n    ↓\nPhase 4: QR Least Squares\n    ↓\nPhase 5: LU-based Inverse\n```\n\n---\n\n## Verification Strategy\n\n### SymPy Validation\n```python\n# Create validation script at scripts/validate_matrix_solver.py\nfrom sympy import Matrix\n\nA = Matrix([[2, 1], [1, 3]])\nb = Matrix([5, 7])\nx = A.solve(b)  # Compare with Rust output\n```\n\n### Rust Tests\n```rust\n#[test]\nfn test_solve_via_lu_correctness() {\n    let a = Matrix::from_arrays([[2, 1], [1, 3]]);\n    let b = vec![expr!(5), expr!(7)];\n    let x = a.solve(&b).unwrap();\n\n    // Verify: A * x == b\n    let ax = matrix_vector_multiply(&a, &x);\n    assert_eq!(ax[0].simplify(), b[0].simplify());\n    assert_eq!(ax[1].simplify(), b[1].simplify());\n}\n```\n\n---\n\n## Risk Mitigation\n\n| Risk | Mitigation |\n|------|------------|\n| Singular matrix | Check LU diagonal before solving |\n| Numerical instability | Use `.simplify()` after each operation |\n| Performance regression | Benchmark before/after with `./scripts/bench.sh` |\n\n---\n\n## Files Summary\n\n| File | Changes |\n|------|---------|\n| `matrices/unified/operations.rs` | +180 lines (add solve methods) |\n| `algebra/solvers/systems.rs` | -170 lines (remove Gaussian), +50 lines (use Matrix.solve) |\n| `matrices/decomposition/lu.rs` | +20 lines (add is_singular helper) |\n| `matrices/decomposition/decomposition_tests.rs` | +100 lines (new tests) |\n\n**Net change**: ~+80 lines, elimination of code duplication\n"
  },
  "related_topics": [
    "internal.planning.fast-path-implementation",
    "internal.planning.fast-path-opportunities"
  ],
  "metadata": {
    "schema_version": "1.0"
  }
}