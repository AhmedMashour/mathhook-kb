{
  "topic": "api.solver.equations",
  "title": "Symbolic and Numerical Equation Solving",
  "description": "Find solutions to equations symbolically and numerically. Supports linear, quadratic,\npolynomial, and transcendental equations with automatic strategy selection. Includes\nsymbolic solving, numerical fallback, and parametric solutions.\n",
  "code_refs": {
    "rust": "mathhook_core::solvers::MathSolver",
    "python": "mathhook.solver.solve",
    "nodejs": "mathhook.solver.solve"
  },
  "examples": [
    {
      "title": "Linear Equations",
      "explanation": "Solve linear equations ax + b = 0",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Solve: 2x + 3 = 0\nlet eq1 = expr!(2 * x + 3);\nlet mut solver = MathSolver::new();\nlet sol1 = solver.solve(&eq1, &x);\n// Result: x = -3/2\n\n// Solve: 5x - 10 = 0\nlet eq2 = expr!(5 * x - 10);\nlet sol2 = solver.solve(&eq2, &x);\n// Result: x = 2\n",
        "python": "from mathhook import symbol, solve\n\nx = symbol('x')\n\n# Solve: 2x + 3 = 0\neq1 = 2*x + 3\nsol1 = solve(eq1, x)\n# Result: x = -3/2\n\n# Solve: 5x - 10 = 0\neq2 = 5*x - 10\nsol2 = solve(eq2, x)\n# Result: x = 2\n",
        "nodejs": "import { symbol, parse, solve } from 'mathhook';\n\nconst x = symbol('x');\n\n// Solve: 2x + 3 = 0\nconst eq1 = parse('2*x + 3');\nconst sol1 = solve(eq1, x);\n// Result: x = -3/2\n\n// Solve: 5x - 10 = 0\nconst eq2 = parse('5*x - 10');\nconst sol2 = solve(eq2, x);\n// Result: x = 2\n"
      }
    },
    {
      "title": "Quadratic Equations",
      "explanation": "Solve quadratic equations using quadratic formula",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Solve: x² - 5x + 6 = 0\nlet eq1 = expr!(x ^ 2 - 5 * x + 6);\nlet mut solver = MathSolver::new();\nlet solutions = solver.solve(&eq1, &x);\n// Result: [x = 2, x = 3]\n\n// Solve: x² - 4 = 0 (difference of squares)\nlet eq2 = expr!(x ^ 2 - 4);\nlet sol2 = solver.solve(&eq2, &x);\n// Result: [x = -2, x = 2]\n\n// Complex roots: x² + 1 = 0\nlet eq3 = expr!(x ^ 2 + 1);\nlet sol3 = solver.solve(&eq3, &x);\n// Result: [x = i, x = -i]\n",
        "python": "from mathhook import symbol, solve\n\nx = symbol('x')\n\n# Solve: x² - 5x + 6 = 0\neq1 = x**2 - 5*x + 6\nsolutions = solve(eq1, x)\n# Result: [x = 2, x = 3]\n\n# Solve: x² - 4 = 0\neq2 = x**2 - 4\nsol2 = solve(eq2, x)\n# Result: [x = -2, x = 2]\n\n# Complex roots\neq3 = x**2 + 1\nsol3 = solve(eq3, x)\n# Result: [x = i, x = -i]\n",
        "nodejs": "import { symbol, parse, solve } from 'mathhook';\n\nconst x = symbol('x');\n\n// Solve: x² - 5x + 6 = 0\nconst eq1 = parse('x^2 - 5*x + 6');\nconst solutions = solve(eq1, x);\n// Result: [x = 2, x = 3]\n\n// Solve: x² - 4 = 0\nconst eq2 = parse('x^2 - 4');\nconst sol2 = solve(eq2, x);\n// Result: [x = -2, x = 2]\n\n// Complex roots\nconst eq3 = parse('x^2 + 1');\nconst sol3 = solve(eq3, x);\n// Result: [x = i, x = -i]\n"
      }
    },
    {
      "title": "Polynomial Equations",
      "explanation": "Solve polynomial equations via factorization",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Solve: x³ - 6x² + 11x - 6 = 0\n// Factors: (x - 1)(x - 2)(x - 3)\nlet cubic = expr!(x ^ 3 - 6 * (x ^ 2) + 11 * x - 6);\nlet mut solver = MathSolver::new();\nlet solutions = solver.solve(&cubic, &x);\n// Result: [x = 1, x = 2, x = 3]\n\n// Solve: x⁴ - 1 = 0\nlet quartic = expr!(x ^ 4 - 1);\nlet sol2 = solver.solve(&quartic, &x);\n// Result: [x = 1, x = -1, x = i, x = -i]\n",
        "python": "from mathhook import symbol, solve\n\nx = symbol('x')\n\n# Solve: x³ - 6x² + 11x - 6 = 0\ncubic = x**3 - 6*x**2 + 11*x - 6\nsolutions = solve(cubic, x)\n# Result: [x = 1, x = 2, x = 3]\n\n# Solve: x⁴ - 1 = 0\nquartic = x**4 - 1\nsol2 = solve(quartic, x)\n# Result: [x = 1, x = -1, x = i, x = -i]\n",
        "nodejs": "import { symbol, parse, solve } from 'mathhook';\n\nconst x = symbol('x');\n\n// Solve: x³ - 6x² + 11x - 6 = 0\nconst cubic = parse('x^3 - 6*x^2 + 11*x - 6');\nconst solutions = solve(cubic, x);\n// Result: [x = 1, x = 2, x = 3]\n\n// Solve: x⁴ - 1 = 0\nconst quartic = parse('x^4 - 1');\nconst sol2 = solve(quartic, x);\n// Result: [x = 1, x = -1, x = i, x = -i]\n"
      }
    },
    {
      "title": "Transcendental Equations",
      "explanation": "Solve equations with trigonometric, exponential functions",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Solve: sin(x) = 0\nlet eq1 = expr!(sin(x));\nlet mut solver = MathSolver::new();\nlet solutions = solver.solve(&eq1, &x);\n// Result: [x = 0, x = π, x = 2π, ...] (periodic)\n\n// Solve: e^x = 5\nlet eq2 = expr!(exp(x) - 5);\nlet sol2 = solver.solve(&eq2, &x);\n// Result: x = ln(5)\n\n// Numerical fallback: x = cos(x)\nlet eq3 = expr!(x - cos(x));\nlet mut solver = MathSolver::new()\n    .with_numerical_fallback(true)\n    .with_tolerance(1e-10);\nlet sol3 = solver.solve(&eq3, &x);\n// Result: x ≈ 0.739085133...\n",
        "python": "from mathhook import symbol, solve, sin, exp, cos\n\nx = symbol('x')\n\n# Solve: sin(x) = 0\neq1 = sin(x)\nsolutions = solve(eq1, x)\n# Result: [x = 0, x = π, x = 2π, ...]\n\n# Solve: e^x = 5\neq2 = exp(x) - 5\nsol2 = solve(eq2, x)\n# Result: x = ln(5)\n\n# Numerical fallback\neq3 = x - cos(x)\nsol3 = solve(eq3, x, numerical=True)\n# Result: x ≈ 0.739085133...\n",
        "nodejs": "import { symbol, parse, solve } from 'mathhook';\n\nconst x = symbol('x');\n\n// Solve: sin(x) = 0\nconst eq1 = parse('sin(x)');\nconst solutions = solve(eq1, x);\n// Result: [x = 0, x = π, x = 2π, ...]\n\n// Solve: e^x = 5\nconst eq2 = parse('exp(x) - 5');\nconst sol2 = solve(eq2, x);\n// Result: x = ln(5)\n\n// Numerical fallback\nconst eq3 = parse('x - cos(x)');\nconst sol3 = solve(eq3, x, { numerical: true });\n// Result: x ≈ 0.739085133...\n"
      }
    },
    {
      "title": "Real-World Application: Projectile Motion",
      "explanation": "Physics application finding time to hit ground",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet t = symbol!(t);\nlet v0 = symbol!(v0);  // Initial velocity\nlet h = symbol!(h);    // Initial height\n\n// Position: y(t) = -16t² + v₀t + h\nlet position = expr!(-16 * (t ^ 2) + v0 * t + h);\n\n// Substitute values: v₀ = 64 ft/s, h = 80 ft\nlet position_vals = position.substitute(&v0, &expr!(64))\n                             .substitute(&h, &expr!(80));\n\n// Find time when projectile hits ground (y = 0)\nlet mut solver = MathSolver::new();\nlet times = solver.solve(&position_vals, &t);\n// Result: t ≈ 5 seconds (ignoring negative solution)\n",
        "python": "from mathhook import symbol, solve\n\nt = symbol('t')\n\n# Position: y(t) = -16t² + 64t + 80\nposition = -16*t**2 + 64*t + 80\n\n# Find time when y = 0\ntimes = solve(position, t)\n# Result: t ≈ 5 seconds (ignore negative)\n",
        "nodejs": "import { symbol, parse, solve } from 'mathhook';\n\nconst t = symbol('t');\n\n// Position: y(t) = -16t² + 64t + 80\nconst position = parse('-16*t^2 + 64*t + 80');\n\n// Find time when y = 0\nconst times = solve(position, t);\n// Result: t ≈ 5 seconds\n"
      }
    },
    {
      "title": "Parametric Solutions",
      "explanation": "Solve in terms of parameters",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet a = symbol!(a);\nlet b = symbol!(b);\n\n// Solve: ax + b = 0 (parametric in a, b)\nlet equation = expr!(a * x + b);\nlet mut solver = MathSolver::new();\nlet solution = solver.solve(&equation, &x);\n// Result: x = -b/a (symbolic solution)\n\n// Now substitute specific values\nlet specific = solution.substitute(&a, &expr!(2))\n                       .substitute(&b, &expr!(6));\n// Result: x = -3\n",
        "python": "from mathhook import symbol, solve\n\nx = symbol('x')\na = symbol('a')\nb = symbol('b')\n\n# Solve: ax + b = 0\nequation = a*x + b\nsolution = solve(equation, x)\n# Result: x = -b/a\n\n# Substitute specific values\nspecific = solution.subs([(a, 2), (b, 6)])\n# Result: x = -3\n",
        "nodejs": "import { symbol, parse, solve } from 'mathhook';\n\nconst x = symbol('x');\nconst a = symbol('a');\nconst b = symbol('b');\n\n// Solve: ax + b = 0\nconst equation = parse('a*x + b');\nconst solution = solve(equation, x);\n// Result: x = -b/a\n\n// Substitute specific values\nconst specific = solution.substitute(a, 2).substitute(b, 6);\n// Result: x = -3\n"
      }
    }
  ],
  "article": {
    "content": "# Equation Solving\n\n## Overview\n\nMathHook's solver finds solutions to equations using:\n- **Linear equations**: Direct algebraic solution $x = -b/a$\n- **Quadratic equations**: Quadratic formula with complex root support\n- **Polynomial equations**: Factorization and root finding\n- **Transcendental equations**: Symbolic when possible, numerical fallback\n- **Matrix equations**: Left and right division for noncommutative systems\n\n## Mathematical Foundations\n\n### Quadratic Formula\nFor $ax^2 + bx + c = 0$:\n$$x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$\n\n### Discriminant\n$$\\Delta = b^2 - 4ac$$\n- $\\Delta > 0$: Two distinct real roots\n- $\\Delta = 0$: One repeated real root\n- $\\Delta < 0$: Two complex conjugate roots\n\n## Solver Strategies\n\n### Automatic Strategy Selection\n1. Detect equation type (linear, quadratic, polynomial, transcendental)\n2. Apply appropriate technique:\n   - Linear: Algebraic isolation\n   - Quadratic: Quadratic formula\n   - Polynomial: Factorization then root finding\n   - Transcendental: Symbolic simplification or numerical methods\n3. Return all solutions (real and complex)\n\n### Numerical Fallback\nWhen no closed-form solution exists (e.g., $x = \\cos(x)$):\n- Newton's method: $x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$\n- Configurable tolerance and max iterations\n- Returns numerical approximation\n"
  },
  "use_cases": [
    "Finding zeros: Determine where functions equal zero",
    "Intersection points: Find where two functions are equal",
    "Parameter estimation: Determine unknown values from constraints",
    "Optimization: Critical points where derivative equals zero",
    "Physics problems: Solve for time, velocity, position"
  ],
  "related_topics": [
    "api.advanced.system_solving",
    "api.advanced.matrix_equations",
    "api.operations.substitution",
    "api.calculus.operations"
  ],
  "performance": {},
  "metadata": {
    "schema_version": "1.0"
  }
}