{
  "topic": "parser.custom",
  "title": "Custom Parsers and Extensions",
  "description": "Extend MathHook's parser for domain-specific mathematical notation.\nAdd custom functions, operators, preprocessors, and grammar modifications.\n",
  "code_refs": {
    "rust": "mathhook_core::parser::extensions",
    "python": "mathhook.parser.extensions",
    "nodejs": "mathhook.parser.extensions"
  },
  "examples": [
    {
      "title": "Adding Custom Functions",
      "explanation": "Register domain-specific functions",
      "code": {
        "rust": "use mathhook::parser::ParserBuilder;\n\nlet parser = ParserBuilder::new()\n    .add_function(\"erf\", \"error_function\")\n    .add_function(\"Si\", \"sine_integral\")\n    .add_function(\"Ci\", \"cosine_integral\")\n    .build();\n\nlet expr = parser.parse(\"erf(x) + Si(x)\")?;\n// Parsed as: error_function(x) + sine_integral(x)\n",
        "python": "from mathhook.parser import ParserBuilder\n\nparser = (ParserBuilder()\n    .add_function(\"erf\", \"error_function\")\n    .add_function(\"Si\", \"sine_integral\")\n    .add_function(\"Ci\", \"cosine_integral\")\n    .build())\n\nexpr = parser.parse(\"erf(x) + Si(x)\")\n# Parsed as: error_function(x) + sine_integral(x)\n",
        "nodejs": "const { ParserBuilder } = require('mathhook');\n\nconst parser = new ParserBuilder()\n    .addFunction(\"erf\", \"error_function\")\n    .addFunction(\"Si\", \"sine_integral\")\n    .addFunction(\"Ci\", \"cosine_integral\")\n    .build();\n\nconst expr = parser.parse(\"erf(x) + Si(x)\");\n// Parsed as: error_function(x) + sine_integral(x)\n"
      }
    },
    {
      "title": "Adding Custom Operators",
      "explanation": "Define new infix operators with precedence",
      "code": {
        "rust": "use mathhook::parser::ParserBuilder;\nuse mathhook::parser::Precedence;\n\nlet parser = ParserBuilder::new()\n    .add_operator(\"×\", \"*\")      // Cross product symbol\n    .add_operator(\"⊗\", \"tensor\") // Tensor product\n    .add_operator_with_precedence(\n        \"⊕\",\n        \"direct_sum\",\n        Precedence::Addition\n    )\n    .build();\n\nlet expr = parser.parse(\"A ⊗ B\")?;\n// Parsed as: tensor(A, B)\n",
        "python": "from mathhook.parser import ParserBuilder, Precedence\n\nparser = (ParserBuilder()\n    .add_operator(\"×\", \"*\")\n    .add_operator(\"⊗\", \"tensor\")\n    .add_operator_with_precedence(\n        \"⊕\",\n        \"direct_sum\",\n        Precedence.ADDITION\n    )\n    .build())\n\nexpr = parser.parse(\"A ⊗ B\")\n# Parsed as: tensor(A, B)\n",
        "nodejs": "const { ParserBuilder, Precedence } = require('mathhook');\n\nconst parser = new ParserBuilder()\n    .addOperator(\"×\", \"*\")\n    .addOperator(\"⊗\", \"tensor\")\n    .addOperatorWithPrecedence(\n        \"⊕\",\n        \"direct_sum\",\n        Precedence.ADDITION\n    )\n    .build();\n\nconst expr = parser.parse(\"A ⊗ B\");\n// Parsed as: tensor(A, B)\n"
      }
    },
    {
      "title": "Preprocessor Transformations",
      "explanation": "Transform input before parsing",
      "code": {
        "rust": "use mathhook::parser::ParserBuilder;\n\nlet parser = ParserBuilder::new()\n    .add_preprocessor(|input| {\n        input.replace(\"→\", \"->\")   // Arrow notation\n             .replace(\"×\", \"*\")     // Cross product\n             .replace(\"÷\", \"/\")     // Division symbol\n    })\n    .build();\n\nlet expr = parser.parse(\"x → ∞\")?;\n// Preprocessed to: x -> ∞\n// Then parsed normally\n",
        "python": "from mathhook.parser import ParserBuilder\n\ndef preprocess(input_str):\n    return (input_str\n        .replace(\"→\", \"->\")\n        .replace(\"×\", \"*\")\n        .replace(\"÷\", \"/\"))\n\nparser = (ParserBuilder()\n    .add_preprocessor(preprocess)\n    .build())\n\nexpr = parser.parse(\"x → ∞\")\n# Preprocessed to: x -> ∞\n# Then parsed normally\n",
        "nodejs": "const { ParserBuilder } = require('mathhook');\n\nconst parser = new ParserBuilder()\n    .addPreprocessor((input) => {\n        return input\n            .replace(/→/g, \"->\")\n            .replace(/×/g, \"*\")\n            .replace(/÷/g, \"/\");\n    })\n    .build();\n\nconst expr = parser.parse(\"x → ∞\");\n// Preprocessed to: x -> ∞\n// Then parsed normally\n"
      }
    },
    {
      "title": "Domain-Specific Parser (Chemistry)",
      "explanation": "Complete chemistry equation parser",
      "code": {
        "rust": "use mathhook::parser::ParserBuilder;\n\nfn create_chemistry_parser() -> Parser {\n    ParserBuilder::new()\n        .add_operator(\"→\", \"yields\")\n        .add_operator(\"⇌\", \"equilibrium\")\n        .add_operator(\"+\", \"plus\")\n        .add_preprocessor(|input| {\n            // H2O → H_2*O\n            expand_chemical_formulas(input)\n        })\n        .add_postprocessor(|expr| {\n            balance_equation(expr)\n        })\n        .build()\n}\n\nlet parser = create_chemistry_parser();\nlet reaction = parser.parse(\"H₂ + O₂ → H₂O\")?;\nlet balanced = reaction.balance();  // 2H₂ + O₂ → 2H₂O\n",
        "python": "from mathhook.parser import ParserBuilder\n\ndef create_chemistry_parser():\n    return (ParserBuilder()\n        .add_operator(\"→\", \"yields\")\n        .add_operator(\"⇌\", \"equilibrium\")\n        .add_operator(\"+\", \"plus\")\n        .add_preprocessor(expand_chemical_formulas)\n        .add_postprocessor(balance_equation)\n        .build())\n\nparser = create_chemistry_parser()\nreaction = parser.parse(\"H₂ + O₂ → H₂O\")\nbalanced = reaction.balance()  # 2H₂ + O₂ → 2H₂O\n",
        "nodejs": "const { ParserBuilder } = require('mathhook');\n\nfunction createChemistryParser() {\n    return new ParserBuilder()\n        .addOperator(\"→\", \"yields\")\n        .addOperator(\"⇌\", \"equilibrium\")\n        .addOperator(\"+\", \"plus\")\n        .addPreprocessor(expandChemicalFormulas)\n        .addPostprocessor(balanceEquation)\n        .build();\n}\n\nconst parser = createChemistryParser();\nconst reaction = parser.parse(\"H₂ + O₂ → H₂O\");\nconst balanced = reaction.balance();  // 2H₂ + O₂ → 2H₂O\n"
      }
    },
    {
      "title": "Custom LaTeX Macros",
      "explanation": "Expand LaTeX macros before parsing",
      "code": {
        "rust": "use mathhook::parser::LatexParserBuilder;\n\nlet parser = LatexParserBuilder::new()\n    .add_macro(r\"\\RR\", r\"\\mathbb{R}\")    // Real numbers\n    .add_macro(r\"\\CC\", r\"\\mathbb{C}\")    // Complex numbers\n    .add_macro(r\"\\NN\", r\"\\mathbb{N}\")    // Natural numbers\n    .add_macro(r\"\\dd\", r\"\\mathrm{d}\")    // Differential d\n    .build();\n\nlet expr = parser.parse(r\"f: \\RR \\to \\CC\")?;\n// Expands to: f: \\mathbb{R} \\to \\mathbb{C}\n",
        "python": "from mathhook.parser import LatexParserBuilder\n\nparser = (LatexParserBuilder()\n    .add_macro(r\"\\RR\", r\"\\mathbb{R}\")\n    .add_macro(r\"\\CC\", r\"\\mathbb{C}\")\n    .add_macro(r\"\\NN\", r\"\\mathbb{N}\")\n    .add_macro(r\"\\dd\", r\"\\mathrm{d}\")\n    .build())\n\nexpr = parser.parse(r\"f: \\RR \\to \\CC\")\n# Expands to: f: \\mathbb{R} \\to \\mathbb{C}\n",
        "nodejs": "const { LatexParserBuilder } = require('mathhook');\n\nconst parser = new LatexParserBuilder()\n    .addMacro(String.raw`\\RR`, String.raw`\\mathbb{R}`)\n    .addMacro(String.raw`\\CC`, String.raw`\\mathbb{C}`)\n    .addMacro(String.raw`\\NN`, String.raw`\\mathbb{N}`)\n    .addMacro(String.raw`\\dd`, String.raw`\\mathrm{d}`)\n    .build();\n\nconst expr = parser.parse(String.raw`f: \\RR \\to \\CC`);\n// Expands to: f: \\mathbb{R} \\to \\mathbb{C}\n"
      }
    }
  ],
  "article": {
    "content": "# Custom Parsers and Extensions\n\nExtend MathHook's parser for domain-specific mathematical notation.\n\n## Understanding Parser Extension\n\n### What Can You Extend?\n\nMathHook's parser is modular and extensible. You can add:\n\n- **Custom Functions**: Domain-specific functions (chemistry, physics, engineering)\n- **Custom Operators**: New infix/prefix/postfix operators\n- **Custom Notation**: LaTeX macros, specialized symbols\n- **Parser Preprocessors**: Transform input before parsing\n- **Lexer Tokens**: New token types for specialized syntax\n\n### When to Extend the Parser\n\n**Use Built-In Features When:**\n- Standard mathematical notation suffices\n- Functions can be named conventionally\n- LaTeX or Wolfram notation covers your needs\n\n**Extend the Parser When:**\n- Domain-specific notation is essential (chemistry: `→`, physics: `⊗`)\n- Custom operators with special precedence\n- Proprietary mathematical notation\n- Legacy system compatibility\n\n### Architecture Overview\n\n```\nInput String\n    ↓\nPreprocessor (optional) - Transform syntax before parsing\n    ↓\nLexer - Tokenize input (recognizes custom tokens)\n    ↓\nParser (LALRPOP) - Build expression tree\n    ↓\nPost-Processor (optional) - Transform parsed expression\n    ↓\nExpression\n```\n\n## Domain-Specific Examples\n\n### Chemistry Notation\n\nCustom parser for chemical equations:\n- `→` for yields\n- `⇌` for equilibrium\n- Subscripts for molecular formulas\n\n### Quantum Mechanics\n\nSpecialized notation:\n- `⊗` for tensor product\n- `⟨|⟩` for inner product\n- `[,]` for commutator\n- `{,}` for anticommutator\n\n### Financial Mathematics\n\nFinance-specific functions:\n- NPV (Net Present Value)\n- IRR (Internal Rate of Return)\n- FV/PV (Future/Present Value)\n- % operator for percentages\n\n### Control Theory\n\nSystem notation:\n- `*` as convolution\n- `ℒ` for Laplace transform\n- `//` for feedback connection\n"
  },
  "use_cases": [
    "Chemistry equation parsing and balancing",
    "Quantum mechanics notation (bra-ket, commutators)",
    "Financial mathematics formulas",
    "Control theory system notation",
    "Legacy system compatibility"
  ],
  "related_topics": [
    "parser.latex",
    "parser.wolfram",
    "parser.formatting",
    "operations.functions",
    "advanced.pattern_matching"
  ],
  "performance": {},
  "metadata": {
    "schema_version": "1.0"
  }
}