{
  "topic": "advanced.pde.registry",
  "title": "PDE Solver Registry System",
  "description": "MathHook uses a registry-based dispatch system for PDE solvers, eliminating hardcoded match\nstatements and enabling O(1) solver lookup. This architecture is inspired by the ODE module\nregistry and provides extensible, testable, and efficient solver selection.\n",
  "mathematical_definition": "Registry-based dispatch uses a HashMap for O(1) lookup by PDE type:\n\n$$\\text{Registry}: \\text{PdeType} \\rightarrow \\text{Vec}\\langle\\text{Arc}\\langle\\text{dyn PDESolver}\\rangle\\rangle$$\n\nPriority-based selection from multiple solvers per type ensures optimal solver choice.\n",
  "code_refs": {
    "rust": "mathhook_core::pde::registry",
    "python": "mathhook.pde.registry",
    "nodejs": "mathhook.pde.registry"
  },
  "examples": [
    {
      "title": "Default Registry Usage",
      "explanation": "Create and use default registry with standard solvers",
      "code": {
        "rust": "let registry = PDESolverRegistry::new();\n\n// Automatically classify and solve\nlet solution = registry.solve(&pde)?;\n",
        "python": "registry = PDESolverRegistry()\n\n# Automatically classify and solve\nsolution = registry.solve(pde)\n",
        "nodejs": "const registry = new PDESolverRegistry();\n\n// Automatically classify and solve\nconst solution = registry.solve(pde);\n"
      }
    },
    {
      "title": "Custom Poisson Solver",
      "explanation": "Register a custom solver for Poisson equation (non-homogeneous Laplace)",
      "code": {
        "rust": "struct PoissonEquationSolver {\n    max_terms: usize,\n}\n\nimpl PDESolver for PoissonEquationSolver {\n    fn solve(&self, pde: &Pde) -> PDEResult {\n        // Poisson solver logic here\n        Ok(PDESolution::laplace(solution, eigenvalues, coefficients))\n    }\n\n    fn can_solve(&self, pde_type: PdeType) -> bool {\n        matches!(pde_type, PdeType::Elliptic)\n    }\n\n    fn priority(&self) -> u8 {\n        90  // Lower than Laplace solver (100)\n    }\n\n    fn name(&self) -> &'static str {\n        \"Poisson Equation Solver\"\n    }\n\n    fn description(&self) -> &'static str {\n        \"Solves Poisson equation ∇²u = f with non-zero source term\"\n    }\n}\n\n// Register custom solver\nlet mut registry = PDESolverRegistry::new();\nregistry.register(\n    PdeType::Elliptic,\n    Arc::new(PoissonEquationSolver { max_terms: 10 }),\n);\n",
        "python": "class PoissonEquationSolver:\n    def __init__(self, max_terms=10):\n        self.max_terms = max_terms\n\n    def solve(self, pde):\n        # Poisson solver logic here\n        return PDESolution.laplace(solution, eigenvalues, coefficients)\n\n    def can_solve(self, pde_type):\n        return pde_type == PdeType.Elliptic\n\n    def priority(self):\n        return 90\n\n    def name(self):\n        return \"Poisson Equation Solver\"\n\n    def description(self):\n        return \"Solves Poisson equation ∇²u = f with non-zero source term\"\n\n# Register custom solver\nregistry = PDESolverRegistry()\nregistry.register(PdeType.Elliptic, PoissonEquationSolver(max_terms=10))\n",
        "nodejs": "class PoissonEquationSolver {\n    constructor(maxTerms = 10) {\n        this.maxTerms = maxTerms;\n    }\n\n    solve(pde) {\n        // Poisson solver logic here\n        return PDESolution.laplace(solution, eigenvalues, coefficients);\n    }\n\n    canSolve(pdeType) {\n        return pdeType === PdeType.Elliptic;\n    }\n\n    priority() {\n        return 90;\n    }\n\n    name() {\n        return \"Poisson Equation Solver\";\n    }\n\n    description() {\n        return \"Solves Poisson equation ∇²u = f with non-zero source term\";\n    }\n}\n\n// Register custom solver\nconst registry = new PDESolverRegistry();\nregistry.register(PdeType.Elliptic, new PoissonEquationSolver(10));\n"
      }
    },
    {
      "title": "Solver Discovery",
      "explanation": "List available solvers and inspect registry contents",
      "code": {
        "rust": "let registry = PDESolverRegistry::new();\n\nprintln!(\"Registered PDE types: {:?}\", registry.registered_types());\n// [Parabolic, Hyperbolic, Elliptic]\n\nprintln!(\"Total solvers: {}\", registry.solver_count());\n// 3\n\n// Get solver for specific type\nif let Some(solver) = registry.get_solver(&PdeType::Parabolic) {\n    println!(\"Heat solver: {}\", solver.name());\n    println!(\"Description: {}\", solver.description());\n}\n",
        "python": "registry = PDESolverRegistry()\n\nprint(f\"Registered PDE types: {registry.registered_types()}\")\n# [Parabolic, Hyperbolic, Elliptic]\n\nprint(f\"Total solvers: {registry.solver_count()}\")\n# 3\n\n# Get solver for specific type\nsolver = registry.get_solver(PdeType.Parabolic)\nif solver:\n    print(f\"Heat solver: {solver.name()}\")\n    print(f\"Description: {solver.description()}\")\n",
        "nodejs": "const registry = new PDESolverRegistry();\n\nconsole.log(`Registered PDE types: ${registry.registeredTypes()}`);\n// [Parabolic, Hyperbolic, Elliptic]\n\nconsole.log(`Total solvers: ${registry.solverCount()}`);\n// 3\n\n// Get solver for specific type\nconst solver = registry.getSolver(PdeType.Parabolic);\nif (solver) {\n    console.log(`Heat solver: ${solver.name()}`);\n    console.log(`Description: ${solver.description()}`);\n}\n"
      }
    }
  ],
  "article": {
    "content": "# PDE Solver Registry System\n\n## Architecture: Registry Pattern\n\nMathHook uses a **registry-based dispatch system** for PDE solvers, eliminating hardcoded `match` statements and enabling O(1) solver lookup.\n\n**Design inspired by**: ODE module registry (scored 9/10 for quality)\n\n## Registry Structure\n\n```rust\npub struct PDESolverRegistry {\n    /// Solvers organized by PDE type\n    solvers: HashMap<PdeType, Vec<Arc<dyn PDESolver>>>,\n    /// Priority order for trying solvers\n    priority_order: Vec<PdeType>,\n}\n```\n\n**Key features**:\n- **O(1) lookup** by PDE type (HashMap)\n- **Multiple solvers per type** (priority-sorted Vec)\n- **Thread-safe** (Arc for shared solver instances)\n- **Extensible** (register custom solvers)\n\n## PDESolver Trait\n\nAll solvers implement this trait:\n\n```rust\npub trait PDESolver: Send + Sync {\n    /// Attempts to solve the given PDE\n    fn solve(&self, pde: &Pde) -> PDEResult;\n\n    /// Returns true if this solver can handle the given PDE type\n    fn can_solve(&self, pde_type: PdeType) -> bool;\n\n    /// Priority for this solver (higher = try first)\n    fn priority(&self) -> u8;\n\n    /// Solver name for diagnostics\n    fn name(&self) -> &'static str;\n\n    /// Solver description\n    fn description(&self) -> &'static str;\n}\n```\n\n**Why Send + Sync?** Registry is shared across threads (web servers, parallel computation).\n\n## Default Solvers\n\nRegistry auto-registers standard solvers for three main PDE types:\n- Heat Equation Solver (Parabolic, priority 100)\n- Wave Equation Solver (Hyperbolic, priority 100)\n- Laplace Equation Solver (Elliptic, priority 100)\n\n## Solver Dispatch Workflow\n\n### Automatic Classification + Solving\n\n**Workflow**:\n1. **Classify**: Compute discriminant, determine PDE type\n2. **Lookup**: `HashMap::get(pde_type)` → O(1)\n3. **Select**: First solver in priority-sorted Vec\n4. **Solve**: Call `solver.solve(&pde)`\n5. **Return**: `PDESolution` with metadata\n\n### Try All Solvers (Fallback)\n\nIf classification uncertain, the registry can try all solvers in priority order until one succeeds.\n\n## Adding Custom Solvers\n\nCustom solvers can be registered with specified priority levels:\n- **Override**: Higher priority than standard solver\n- **Fallback**: Lower priority, try if standard fails\n- **Specialized**: Same priority, but more specific `can_solve()` logic\n\n## Error Handling\n\nThe registry provides comprehensive error types:\n- `NoSolverAvailable`: No solver registered for PDE type\n- `ClassificationFailed`: Cannot determine PDE type\n- `SolutionFailed`: Solver encountered an error\n- `InvalidBoundaryConditions`: Boundary conditions incompatible\n- `InvalidInitialConditions`: Initial conditions incompatible\n- `NotSeparable`: PDE not separable (for separation of variables)\n- `InvalidForm`: PDE structure not recognized\n\n## Performance Characteristics\n\n### Lookup Complexity\n\n- **Classification**: O(1) - pattern matching\n- **Registry lookup**: O(1) - HashMap\n- **Solver selection**: O(1) - first element in sorted Vec\n- **Overall**: O(1) for standard PDEs\n\n### Memory Overhead\n\n- **Arc<dyn PDESolver>**: 16 bytes per solver (fat pointer)\n- **HashMap**: ~24 bytes + entries\n- **Total**: ~100 bytes for default registry (3 solvers)\n\n**Negligible** compared to solution computation.\n\n## Comparison: Registry vs Hardcoded Match\n\nRegistry approach provides:\n- ✅ Extensible (register custom solvers)\n- ✅ Priority-based selection\n- ✅ Testable (inject mock solvers)\n- ✅ Solver reuse (Arc-wrapped, cached)\n\nHardcoded approach problems:\n- ❌ Cannot add solvers without modifying source\n- ❌ No priority system\n- ❌ Hard to test (tightly coupled)\n- ❌ Creates new solver instance every time (no caching)\n"
  },
  "use_cases": [
    "Automatic PDE type classification and solver selection",
    "Extensible solver framework for custom PDE types",
    "Thread-safe parallel PDE solving in web servers",
    "Testing with mock solver injection",
    "Priority-based solver fallback strategies"
  ],
  "related_topics": [
    "advanced.pde.sympy_validation",
    "advanced.pde.performance",
    "advanced.pde.technical_guide"
  ],
  "performance": {
    "complexity": "O(1)",
    "typical_time": "< 1 μs for solver lookup"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}