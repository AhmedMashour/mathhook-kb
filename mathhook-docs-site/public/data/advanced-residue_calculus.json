{
  "topic": "advanced.residue_calculus",
  "title": "Residue Calculus and Pole Finding",
  "description": "Find poles of rational and transcendental functions for applications in\ncontrol theory, signal processing, and complex analysis. SymPy-validated\npole locations for trigonometric functions.\n",
  "mathematical_definition": "Pole of order $n$ at $z = z_0$:\n$$\\lim_{z \\to z_0} (z - z_0)^n f(z) = c \\neq 0$$\n\nResidue theorem:\n$$\\oint_C f(z) \\, dz = 2\\pi i \\sum_k \\text{Res}(f, z_k)$$\n",
  "code_refs": {
    "rust": "mathhook_core::residues",
    "python": "mathhook.residues",
    "nodejs": "mathhook.residues"
  },
  "examples": [
    {
      "title": "Rational Function Poles",
      "explanation": "Find poles where denominator equals zero",
      "code": {
        "rust": "let z = symbol!(z);\n\n// Simple pole at z = 0\nlet f1 = expr!(1 / z);\nlet poles1 = f1.find_poles(&z);\n// Returns: [expr!(0)]\n\n// Pole of order 2 at z = 3\nlet f2 = expr!(1 / ((z - 3) ^ 2));\nlet poles2 = f2.find_poles(&z);\n// Returns: [expr!(3)]\n\n// Multiple simple poles\nlet f3 = expr!(1 / ((z - 1) * (z + 2)));\nlet poles3 = f3.find_poles(&z);\n// Returns: [expr!(1), expr!(-2)]\n",
        "python": "from sympy import symbols, singularities\n\nz = symbols('z')\n\n# Simple pole\nf1 = 1/z\npoles1 = singularities(f1, z)\n# Returns: {0}\n\n# Multiple poles\nf3 = 1/((z-1)*(z+2))\npoles3 = singularities(f3, z)\n# Returns: {1, -2}\n",
        "nodejs": "const z = symbol('z');\n\n// Simple pole\nconst f1 = div(1, z);\nconst poles1 = f1.findPoles(z);\n// Returns: [0]\n\n// Multiple poles\nconst f3 = div(1, mul(sub(z, 1), add(z, 2)));\nconst poles3 = f3.findPoles(z);\n// Returns: [1, -2]\n"
      }
    },
    {
      "title": "Trigonometric Function Poles (SymPy Validated)",
      "explanation": "Poles of tan, cot, sec, csc functions",
      "code": {
        "rust": "let x = symbol!(x);\n\n// tan(x) has poles at x = π/2 + nπ\nlet f = expr!(tan(x));\nlet poles = f.find_poles(&x);\n// Returns principal pole: [expr!(pi / 2)]\n\n// cot(x) has poles at x = nπ\nlet f = expr!(cot(x));\nlet poles = f.find_poles(&x);\n// Returns principal pole: [expr!(0)]\n\n// sec(x) has poles at x = π/2 + nπ\nlet f = expr!(sec(x));\nlet poles = f.find_poles(&x);\n// Returns principal pole: [expr!(pi / 2)]\n\n// csc(x) has poles at x = nπ\nlet f = expr!(csc(x));\nlet poles = f.find_poles(&x);\n// Returns principal pole: [expr!(0)]\n",
        "python": "from sympy import symbols, tan, cot, sec, csc, singularities, pi\n\nx = symbols('x', real=True)\n\n# tan(x) poles\npoles_tan = singularities(tan(x), x)\n# Principal: pi/2\n\n# cot(x) poles\npoles_cot = singularities(cot(x), x)\n# Principal: 0\n\n# sec(x) poles\npoles_sec = singularities(sec(x), x)\n# Principal: pi/2\n\n# csc(x) poles\npoles_csc = singularities(csc(x), x)\n# Principal: 0\n",
        "nodejs": "const x = symbol('x');\n\n// tan(x) poles\nconst poles_tan = tan(x).findPoles(x);\n// Returns: [pi/2]\n\n// cot(x) poles\nconst poles_cot = cot(x).findPoles(x);\n// Returns: [0]\n"
      }
    },
    {
      "title": "Control System Stability",
      "explanation": "Transfer function pole analysis for stability",
      "code": {
        "rust": "let s = symbol!(s);\nlet zeta = expr!(0.7);      // Damping ratio\nlet omega_n = expr!(10);    // Natural frequency\nlet K = expr!(100);\n\nlet denominator = expr!(s^2 + 2*zeta*omega_n*s + omega_n^2);\nlet H = expr!(K / denominator);\n\nlet poles = H.find_poles(&s);\n\n// For ζ = 0.7, ωₙ = 10:\n// Poles ≈ -7 ± 7.14i\n// - Stable (negative real part)\n// - Damped oscillation at ~7.14 rad/s\n",
        "python": "from sympy import symbols, sqrt\n\ns = symbols('s')\nzeta = 0.7\nomega_n = 10\nK = 100\n\nH = K / (s**2 + 2*zeta*omega_n*s + omega_n**2)\npoles = solve(denom(H), s)\n\n# Stability: all poles have Re(pole) < 0\n",
        "nodejs": "const s = symbol('s');\nconst zeta = 0.7;\nconst omega_n = 10;\nconst K = 100;\n\nconst denom = add(pow(s, 2), mul(2, zeta, omega_n, s), pow(omega_n, 2));\nconst H = div(K, denom);\n\nconst poles = H.findPoles(s);\n"
      }
    }
  ],
  "use_cases": [
    "Control theory: System stability analysis",
    "Signal processing: Filter design, frequency response",
    "Electrical engineering: RLC circuits, impedance",
    "Complex analysis: Contour integration, residue theorem"
  ],
  "related_topics": [
    "advanced.complex_numbers",
    "advanced.special_functions",
    "operations.solving",
    "applications.control_theory"
  ],
  "metadata": {
    "schema_version": "1.0"
  }
}