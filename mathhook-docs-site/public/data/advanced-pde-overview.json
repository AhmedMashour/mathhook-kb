{
  "topic": "advanced.pde.overview",
  "title": "Partial Differential Equations (PDEs)",
  "description": "Comprehensive overview of partial differential equations in MathHook CAS.\nCovers mathematical foundations, classification, solution methods, and current capabilities.\n",
  "mathematical_definition": "A second-order linear PDE in two independent variables has the general form:\n\n$$A \\frac{\\partial^2 u}{\\partial x^2} + B \\frac{\\partial^2 u}{\\partial x \\partial y} + C \\frac{\\partial^2 u}{\\partial y^2} + D \\frac{\\partial u}{\\partial x} + E \\frac{\\partial u}{\\partial y} + Fu = G$$\n\nwhere:\n- $u(x,y)$ is the unknown function\n- $A, B, C, D, E, F, G$ are coefficients (may depend on $x$, $y$, or $u$)\n- $x, y$ are independent variables (typically spatial coordinates or time)\n",
  "code_refs": {
    "rust": "mathhook_core::pde",
    "python": "mathhook.pde",
    "nodejs": "mathhook.pde"
  },
  "examples": [
    {
      "title": "Registry-Based Solver Dispatch",
      "explanation": "Automatic PDE classification and solver selection using O(1) registry lookup",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Create registry (auto-registers all solvers)\nlet registry = PDESolverRegistry::new();\n\n// Define PDE\nlet u = symbol!(u);\nlet x = symbol!(x);\nlet t = symbol!(t);\nlet equation = expr!(add: x, t);  // Heat equation pattern\nlet pde = Pde::new(equation, u, vec![x, t]);\n\n// Automatic classification and solving\nlet solution = registry.solve(&pde)?;\n\nprintln!(\"Solution: {}\", solution.solution);\nprintln!(\"Eigenvalues: {:?}\", solution.get_eigenvalues());\n",
        "python": "from mathhook import symbol, expr, Pde, PDESolverRegistry\n\n# Create registry\nregistry = PDESolverRegistry()\n\n# Define PDE\nu = symbol('u')\nx = symbol('x')\nt = symbol('t')\nequation = expr(x + t)  # Heat equation pattern\npde = Pde(equation, u, [x, t])\n\n# Automatic solving\nsolution = registry.solve(pde)\n\nprint(f\"Solution: {solution.solution}\")\nprint(f\"Eigenvalues: {solution.get_eigenvalues()}\")\n",
        "nodejs": "const { symbol, expr, Pde, PDESolverRegistry } = require('mathhook');\n\n// Create registry\nconst registry = new PDESolverRegistry();\n\n// Define PDE\nconst u = symbol('u');\nconst x = symbol('x');\nconst t = symbol('t');\nconst equation = expr(x + t);  // Heat equation pattern\nconst pde = new Pde(equation, u, [x, t]);\n\n// Automatic solving\nconst solution = registry.solve(pde);\n\nconsole.log(`Solution: ${solution.solution}`);\nconsole.log(`Eigenvalues: ${solution.getEigenvalues()}`);\n"
      }
    }
  ],
  "article": {
    "content": "# Partial Differential Equations (PDEs)\n\n## What Are PDEs?\n\nPartial Differential Equations (PDEs) describe relationships involving functions of multiple variables and their partial derivatives. Unlike Ordinary Differential Equations (ODEs) which involve functions of a single variable, PDEs govern phenomena that vary in space **and** time.\n\n### Why PDEs Matter\n\nPDEs are the mathematical language of:\n1. **Physics**: Heat conduction, wave propagation, electromagnetic fields, quantum mechanics\n2. **Engineering**: Structural analysis, fluid dynamics, signal processing, control systems\n3. **Finance**: Option pricing (Black-Scholes), risk modeling\n4. **Biology**: Population dynamics, pattern formation, reaction-diffusion systems\n5. **Computer Graphics**: Image processing, surface modeling, fluid simulation\n\n## MathHook PDE Module Capabilities\n\n### What MathHook Provides (Version 7.5/10)\n\n✅ **Core Functionality**:\n- PDE classification via discriminant ($B^2 - 4AC$)\n- Heat equation solver (1D, Dirichlet boundary conditions)\n- Wave equation solver (1D, Dirichlet boundary conditions)\n- Laplace equation solver (2D rectangular domains, Dirichlet boundary conditions)\n- Eigenvalue computation for standard boundary conditions\n- Registry-based solver dispatch (O(1) lookup)\n- Symbolic solution representation\n\n✅ **Mathematical Correctness**:\n- Verified against SymPy reference implementation\n- Correct eigenvalue formulas\n- Proper separation of variables structure\n- Accurate boundary condition handling\n\n### Current Limitations (Honestly Documented)\n\n⚠️ **Symbolic Fourier Coefficients**:\n- Solutions contain symbolic coefficients ($A_1, A_2, A_3, \\ldots$)\n- Numerical evaluation requires symbolic integration (Phase 2)\n- Example: Heat equation returns $u(x,t) = \\sum A_n \\sin(\\lambda_n x) e^{-\\lambda_n \\alpha t}$ with $A_n$ symbolic\n\n⚠️ **Limited Boundary Conditions**:\n- Only Dirichlet (fixed value) boundary conditions fully supported\n- Neumann (derivative) and Robin (mixed) BCs planned for Phase 2\n\n⚠️ **Standard Equations Only**:\n- Supports heat, wave, and Laplace equations\n- General nonlinear PDEs not yet supported\n\n## Solution Methodology: Separation of Variables\n\nAll MathHook PDE solvers use the **separation of variables** technique.\n"
  },
  "use_cases": [
    "Heat diffusion in materials",
    "Wave propagation modeling",
    "Electrostatic potential distribution",
    "Educational demonstrations of PDE theory",
    "Prototyping analytical solutions"
  ],
  "related_topics": [
    "advanced.pde.classification",
    "advanced.pde.heat_equation",
    "advanced.pde.wave_equation",
    "advanced.pde.laplace_equation",
    "advanced.pde.fourier_coefficients",
    "advanced.pde.boundary_conditions"
  ],
  "performance": {
    "complexity": "O(1) solver lookup, O(n) eigenvalue computation",
    "typical_time": "< 100μs for classification and eigenvalue generation"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}