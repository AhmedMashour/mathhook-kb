{
  "topic": "api.calculus.operations",
  "title": "Symbolic Calculus: Differentiation and Integration",
  "description": "Symbolic differentiation and integration using automatic differentiation rules,\nintegration strategies, and the Risch algorithm. Supports chain rule, product rule,\nquotient rule, and comprehensive integration techniques from table lookup to complete\nRisch algorithm for elementary functions.\n",
  "code_refs": {
    "rust": "mathhook_core::calculus::{derivative, integrate}",
    "python": "mathhook.calculus.{derivative, integrate}",
    "nodejs": "mathhook.calculus.{derivative, integrate}"
  },
  "examples": [
    {
      "title": "Basic Differentiation",
      "explanation": "Compute derivatives using power rule and chain rule",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet expr = expr!(x ^ 3);\n\n// First derivative: 3x^2\nlet derivative = expr.derivative(&x, 1);\n\n// Second derivative: 6x\nlet second_derivative = expr.derivative(&x, 2);\n\n// Complex function with chain rule\nlet expr = expr!(sin(x ^ 2));\nlet deriv = expr.derivative(&x, 1);\n// Result: cos(x^2) * 2x\n",
        "python": "from mathhook import symbol, derivative\n\nx = symbol('x')\nexpr = x**3\n\n# First derivative: 3x^2\ndf = derivative(expr, x)\n\n# Second derivative: 6x\nd2f = derivative(expr, x, order=2)\n\n# Complex function with chain rule\nfrom mathhook import sin\nexpr = sin(x**2)\nderiv = derivative(expr, x)\n# Result: cos(x^2) * 2x\n",
        "nodejs": "import { symbol, parse, derivative } from 'mathhook';\n\nconst x = symbol('x');\nconst expr = parse('x^3');\n\n// First derivative: 3x^2\nconst df = derivative(expr, x);\n\n// Second derivative: 6x\nconst d2f = derivative(expr, x, { order: 2 });\n\n// Complex function with chain rule\nconst expr2 = parse('sin(x^2)');\nconst deriv = derivative(expr2, x);\n// Result: cos(x^2) * 2x\n"
      }
    },
    {
      "title": "Product and Quotient Rules",
      "explanation": "Differentiate products and quotients",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Product rule: d/dx(x^2 * x^3) = 2x * x^3 + x^2 * 3x^2 = 5x^4\nlet f = expr!(x ^ 2);\nlet g = expr!(x ^ 3);\nlet product = expr!(mul: f, g);\nlet deriv = product.derivative(&x, 1);\n// Result: 5*x^4\n\n// Quotient rule: d/dx(x^2 / (x+1))\nlet numerator = expr!(x ^ 2);\nlet denominator = expr!(x + 1);\nlet quotient = expr!(div: numerator, denominator);\nlet deriv = quotient.derivative(&x, 1);\n// Result: (2*x*(x+1) - x^2*1) / (x+1)^2\n",
        "python": "from mathhook import symbol, derivative\n\nx = symbol('x')\n\n# Product rule\nf = x**2\ng = x**3\nproduct = f * g\nderiv = derivative(product, x)\n# Result: 5*x^4\n\n# Quotient rule\nnumerator = x**2\ndenominator = x + 1\nquotient = numerator / denominator\nderiv = derivative(quotient, x)\n# Result: (2*x*(x+1) - x^2) / (x+1)^2\n",
        "nodejs": "import { symbol, parse, derivative } from 'mathhook';\n\nconst x = symbol('x');\n\n// Product rule\nconst product = parse('x^2 * x^3');\nconst deriv1 = derivative(product, x);\n// Result: 5*x^4\n\n// Quotient rule\nconst quotient = parse('x^2 / (x + 1)');\nconst deriv2 = derivative(quotient, x);\n// Result: (2*x*(x+1) - x^2) / (x+1)^2\n"
      }
    },
    {
      "title": "Partial Derivatives (Multivariable)",
      "explanation": "Compute partial derivatives with respect to each variable",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet y = symbol!(y);\nlet expr = expr!((x ^ 2) * y);\n\n// Partial derivative with respect to x\nlet df_dx = expr.derivative(&x, 1);\n// Result: 2*x*y\n\n// Partial derivative with respect to y\nlet df_dy = expr.derivative(&y, 1);\n// Result: x^2\n",
        "python": "from mathhook import symbol, derivative\n\nx = symbol('x')\ny = symbol('y')\nexpr = x**2 * y\n\n# Partial derivative with respect to x\ndf_dx = derivative(expr, x)\n# Result: 2*x*y\n\n# Partial derivative with respect to y\ndf_dy = derivative(expr, y)\n# Result: x^2\n",
        "nodejs": "import { symbol, parse, derivative } from 'mathhook';\n\nconst x = symbol('x');\nconst y = symbol('y');\nconst expr = parse('x^2 * y');\n\n// Partial derivative with respect to x\nconst df_dx = derivative(expr, x);\n// Result: 2*x*y\n\n// Partial derivative with respect to y\nconst df_dy = derivative(expr, y);\n// Result: x^2\n"
      }
    },
    {
      "title": "Basic Integration",
      "explanation": "Symbolic integration using layered strategy",
      "code": {
        "rust": "use mathhook::prelude::*;\nuse mathhook::calculus::integrals::Integration;\n\nlet x = symbol!(x);\n\n// Simple polynomial (Layer 1: Table Lookup)\nlet expr = expr!(x ^ 2);\nlet result = expr.integrate(x.clone());\n// Result: x^3/3 + C\n\n// Rational function (Layer 2: Partial fractions)\nlet expr = expr!(1 / (x + 1));\nlet result = expr.integrate(x.clone());\n// Result: ln|x+1| + C\n\n// Trigonometric (Layer 3: Function registry)\nlet expr = expr!(sin(x));\nlet result = expr.integrate(x.clone());\n// Result: -cos(x) + C\n",
        "python": "from mathhook import symbol, integrate\n\nx = symbol('x')\n\n# Simple polynomial\nexpr = x**2\nresult = integrate(expr, x)\n# Result: x^3/3 + C\n\n# Rational function\nexpr = 1 / (x + 1)\nresult = integrate(expr, x)\n# Result: ln|x+1| + C\n\n# Trigonometric\nfrom mathhook import sin\nexpr = sin(x)\nresult = integrate(expr, x)\n# Result: -cos(x) + C\n",
        "nodejs": "import { symbol, parse, integrate } from 'mathhook';\n\nconst x = symbol('x');\n\n// Simple polynomial\nconst expr = parse('x^2');\nconst result = integrate(expr, x);\n// Result: x^3/3 + C\n\n// Rational function\nconst expr2 = parse('1 / (x + 1)');\nconst result2 = integrate(expr2, x);\n// Result: ln|x+1| + C\n\n// Trigonometric\nconst expr3 = parse('sin(x)');\nconst result3 = integrate(expr3, x);\n// Result: -cos(x) + C\n"
      }
    },
    {
      "title": "Integration by Parts and Substitution",
      "explanation": "Advanced integration techniques",
      "code": {
        "rust": "use mathhook::prelude::*;\nuse mathhook::calculus::integrals::Integration;\n\nlet x = symbol!(x);\n\n// Integration by parts: ∫x*e^x dx\nlet expr = expr!(x * exp(x));\nlet result = expr.integrate(x.clone());\n// Result: e^x(x-1) + C\n\n// U-substitution: ∫2x*sin(x^2) dx\nlet expr = expr!(2 * x * sin(x ^ 2));\nlet result = expr.integrate(x.clone());\n// Result: -cos(x^2) + C\n",
        "python": "from mathhook import symbol, integrate, exp, sin\n\nx = symbol('x')\n\n# Integration by parts\nexpr = x * exp(x)\nresult = integrate(expr, x)\n# Result: e^x(x-1) + C\n\n# U-substitution\nexpr = 2 * x * sin(x**2)\nresult = integrate(expr, x)\n# Result: -cos(x^2) + C\n",
        "nodejs": "import { symbol, parse, integrate } from 'mathhook';\n\nconst x = symbol('x');\n\n// Integration by parts\nconst expr = parse('x * exp(x)');\nconst result = integrate(expr, x);\n// Result: e^x(x-1) + C\n\n// U-substitution\nconst expr2 = parse('2 * x * sin(x^2)');\nconst result2 = integrate(expr2, x);\n// Result: -cos(x^2) + C\n"
      }
    },
    {
      "title": "Real-World Application: Velocity and Acceleration",
      "explanation": "Physics application of derivatives",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet t = symbol!(t);\nlet position = expr!((t ^ 3) - (6 * (t ^ 2)) + (9 * t));\n\nlet velocity = position.derivative(&t, 1);\n// v(t) = 3t^2 - 12t + 9\n\nlet acceleration = position.derivative(&t, 2);\n// a(t) = 6t - 12\n\n// Find when velocity is zero (critical points)\n// Solve: 3t^2 - 12t + 9 = 0\n",
        "python": "from mathhook import symbol, derivative\n\nt = symbol('t')\nposition = t**3 - 6*t**2 + 9*t\n\nvelocity = derivative(position, t)\n# v(t) = 3t^2 - 12t + 9\n\nacceleration = derivative(position, t, order=2)\n# a(t) = 6t - 12\n",
        "nodejs": "import { symbol, parse, derivative } from 'mathhook';\n\nconst t = symbol('t');\nconst position = parse('t^3 - 6*t^2 + 9*t');\n\nconst velocity = derivative(position, t);\n// v(t) = 3t^2 - 12t + 9\n\nconst acceleration = derivative(position, t, { order: 2 });\n// a(t) = 6t - 12\n"
      }
    }
  ],
  "article": {
    "content": "# Symbolic Calculus Operations\n\n## Differentiation\n\n### Overview\nSymbolic differentiation using automatic differentiation with:\n- **Power Rule**: $\\frac{d}{dx} x^n = nx^{n-1}$\n- **Product Rule**: $\\frac{d}{dx}(fg) = f'g + fg'$\n- **Quotient Rule**: $\\frac{d}{dx}\\frac{f}{g} = \\frac{f'g - fg'}{g^2}$\n- **Chain Rule**: $\\frac{d}{dx}f(g(x)) = f'(g(x)) \\cdot g'(x)$\n\n### Supported Functions\n- Trigonometric: sin, cos, tan, cot, sec, csc\n- Inverse trig: arcsin, arctan, arccos\n- Exponential/Logarithmic: exp, log, ln\n- Hyperbolic: sinh, cosh, tanh\n\n## Integration\n\n### 8-Layer Strategy Architecture\n1. **Table Lookup**: O(1) hash lookup for 500+ common patterns\n2. **Rational Functions**: Partial fraction decomposition\n3. **Function Registry**: Built-in antiderivatives\n4. **Integration by Parts**: LIATE heuristic\n5. **U-Substitution**: Chain rule patterns\n6. **Trigonometric**: Trig identities and reduction\n7. **Risch Algorithm**: Complete algorithm for elementary functions\n8. **Symbolic Fallback**: Return unevaluated integral\n\n### Coverage and Performance\n- **Coverage**: 93-95% of elementary integrals\n- **Fast Path**: Layers 1-4 (90% of integrals, <1ms)\n- **Medium Path**: Layers 5-6 (5-8%, 1-10ms)\n- **Slow Path**: Layer 7 (2-5%, 10-2000ms)\n"
  },
  "use_cases": [
    "Physics: Computing velocity, acceleration, jerk from position functions",
    "Machine Learning: Backpropagation gradients for optimization",
    "Optimization: Finding critical points via derivative = 0",
    "Area/Volume: Integration for definite areas under curves",
    "Differential Equations: Symbolic solutions and transformations"
  ],
  "related_topics": [
    "api.operations.limits",
    "api.operations.series",
    "api.operations.solving",
    "api.advanced.differential_equations",
    "api.educational.step_by_step"
  ],
  "performance": {},
  "metadata": {
    "schema_version": "1.0"
  }
}