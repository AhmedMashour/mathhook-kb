{
  "topic": "operations.solving",
  "title": "Solving Equations",
  "description": "Find solutions to equations symbolically and numerically.\n",
  "mathematical_definition": "**Linear Equation:**\n$$ax + b = 0 \\implies x = -\\frac{b}{a}$$\n\n**Quadratic Formula:**\n$$ax^2 + bx + c = 0 \\implies x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$\n\n**Discriminant ($\\Delta$):**\n$$\\Delta = b^2 - 4ac$$\n- $\\Delta > 0$: Two distinct real roots\n- $\\Delta = 0$: One repeated real root\n- $\\Delta < 0$: Two complex conjugate roots\n\n**Matrix Equations (Noncommutative):**\n- Left division: $AX = B \\implies X = A^{-1}B$\n- Right division: $XA = B \\implies X = BA^{-1}$\n- Note: $A^{-1}B \\neq BA^{-1}$ for matrices!\n",
  "code_refs": {
    "rust": "mathhook_core::solvers::MathSolver",
    "python": "mathhook.solve",
    "nodejs": "mathhook.solve"
  },
  "examples": [
    {
      "title": "Linear Equations",
      "explanation": "Solve ax + b = 0",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Solve: 2x + 3 = 0\nlet eq1 = expr!(2 * x + 3);\nlet mut solver = MathSolver::new();\nlet sol1 = solver.solve(&eq1, &x);\n// Result: x = -3/2\n\n// Solve: 5x - 10 = 0\nlet eq2 = expr!(5 * x - 10);\nlet sol2 = solver.solve(&eq2, &x);\n// Result: x = 2\n",
        "python": "from mathhook import symbol, solve\n\nx = symbol('x')\n\n# Solve: 2x + 3 = 0\neq1 = 2*x + 3\nsol1 = solve(eq1, x)\n# Result: x = -3/2\n\n# Solve: 5x - 10 = 0\neq2 = 5*x - 10\nsol2 = solve(eq2, x)\n# Result: x = 2\n",
        "nodejs": "const { symbol, solve } = require('mathhook');\n\nconst x = symbol('x');\n\n// Solve: 2x + 3 = 0\nconst eq1 = x.mul(2).add(3);\nconst sol1 = solve(eq1, x);\n// Result: x = -3/2\n"
      }
    },
    {
      "title": "Quadratic Equations",
      "explanation": "Solve ax² + bx + c = 0",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Solve: x² - 5x + 6 = 0\nlet eq1 = expr!(x ^ 2 - 5 * x + 6);\nlet mut solver = MathSolver::new();\nlet solutions = solver.solve(&eq1, &x);\n// Result: [x = 2, x = 3]\n\n// Solve: x² - 4 = 0 (difference of squares)\nlet eq2 = expr!(x ^ 2 - 4);\nlet sol2 = solver.solve(&eq2, &x);\n// Result: [x = -2, x = 2]\n",
        "python": "from mathhook import symbol, solve\n\nx = symbol('x')\n\n# Solve: x² - 5x + 6 = 0\neq1 = x**2 - 5*x + 6\nsolutions = solve(eq1, x)\n# Result: [2, 3]\n\n# Solve: x² - 4 = 0\neq2 = x**2 - 4\nsol2 = solve(eq2, x)\n# Result: [-2, 2]\n",
        "nodejs": "const { symbol, solve } = require('mathhook');\n\nconst x = symbol('x');\n\n// Solve: x² - 5x + 6 = 0\nconst eq1 = x.pow(2).sub(x.mul(5)).add(6);\nconst solutions = solve(eq1, x);\n// Result: [2, 3]\n"
      }
    },
    {
      "title": "Complex Roots",
      "explanation": "When discriminant is negative",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Solve: x² + 1 = 0 (complex roots)\nlet equation = expr!(x ^ 2 + 1);\nlet mut solver = MathSolver::new();\nlet solutions = solver.solve(&equation, &x);\n// Result: [x = i, x = -i]\n\n// Solve: x² - 2x + 5 = 0\n// Discriminant: 4 - 20 = -16 < 0 (complex roots)\nlet eq2 = expr!(x ^ 2 - 2 * x + 5);\nlet sol2 = solver.solve(&eq2, &x);\n// Result: [x = 1 + 2i, x = 1 - 2i]\n",
        "python": "from mathhook import symbol, solve, I\n\nx = symbol('x')\n\n# Solve: x² + 1 = 0\nequation = x**2 + 1\nsolutions = solve(equation, x)\n# Result: [I, -I]\n\n# Solve: x² - 2x + 5 = 0\neq2 = x**2 - 2*x + 5\nsol2 = solve(eq2, x)\n# Result: [1 + 2*I, 1 - 2*I]\n",
        "nodejs": "const { symbol, solve } = require('mathhook');\n\nconst x = symbol('x');\n\n// Solve: x² + 1 = 0\nconst equation = x.pow(2).add(1);\nconst solutions = solve(equation, x);\n// Result: [i, -i]\n"
      }
    },
    {
      "title": "Transcendental Equations",
      "explanation": "Trigonometric, exponential, logarithmic",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Solve: sin(x) = 0\nlet eq1 = expr!(sin(x));\nlet mut solver = MathSolver::new();\nlet solutions = solver.solve(&eq1, &x);\n// Result: [x = 0, x = π, x = 2π, ...] (infinitely many)\n\n// Solve: e^x = 5\nlet eq2 = expr!(exp(x) - 5);\nlet sol2 = solver.solve(&eq2, &x);\n// Result: x = ln(5)\n\n// Solve: log(x) = 2\nlet eq3 = expr!(log(x) - 2);\nlet sol3 = solver.solve(&eq3, &x);\n// Result: x = e² (if natural log)\n",
        "python": "from mathhook import symbol, solve, sin, exp, log\n\nx = symbol('x')\n\n# Solve: sin(x) = 0\neq1 = sin(x)\nsolutions = solve(eq1, x)\n# Result: [0, π, 2π, ...]\n\n# Solve: e^x = 5\neq2 = exp(x) - 5\nsol2 = solve(eq2, x)\n# Result: log(5)\n",
        "nodejs": "const { symbol, solve, parse } = require('mathhook');\n\nconst x = symbol('x');\n\n// Solve: sin(x) = 0\nconst eq1 = parse('sin(x)');\nconst solutions = solve(eq1, x);\n// Result: [0, π, 2π, ...]\n"
      }
    },
    {
      "title": "Matrix Equations (Noncommutative)",
      "explanation": "Left and right division for matrices",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Matrix symbols\nlet A = symbol!(A; matrix);\nlet X = symbol!(X; matrix);\nlet B = symbol!(B; matrix);\n\n// Left division: A*X = B → X = A⁻¹*B\nlet left_eq = expr!(A * X - B);\nlet mut solver = MathSolver::new();\nlet solution_left = solver.solve(&left_eq, &X);\n// Result: X = A⁻¹*B\n\n// Right division: X*A = B → X = B*A⁻¹\nlet right_eq = expr!(X * A - B);\nlet solution_right = solver.solve(&right_eq, &X);\n// Result: X = B*A⁻¹\n\n// Note: A⁻¹*B ≠ B*A⁻¹ for matrices!\n",
        "python": "from mathhook import symbol, solve\n\n# Matrix symbols\nA = symbol('A', matrix=True)\nX = symbol('X', matrix=True)\nB = symbol('B', matrix=True)\n\n# Left division: A*X = B → X = A⁻¹*B\nleft_eq = A*X - B\nsolution_left = solve(left_eq, X)\n# Result: X = A^(-1)*B\n",
        "nodejs": "const { symbol, solve } = require('mathhook');\n\n// Matrix symbols\nconst A = symbol('A', { type: 'matrix' });\nconst X = symbol('X', { type: 'matrix' });\nconst B = symbol('B', { type: 'matrix' });\n\n// Left division: A*X = B → X = A⁻¹*B\nconst leftEq = A.mul(X).sub(B);\nconst solutionLeft = solve(leftEq, X);\n// Result: X = A^(-1)*B\n"
      }
    }
  ],
  "use_cases": [
    "Finding zeros: Determine where functions equal zero",
    "Intersection points: Find where two functions are equal",
    "Physics problems: Solve for time, velocity, position",
    "Optimization: Critical points where derivative equals zero"
  ],
  "related_topics": [
    "operations.substitution",
    "operations.differentiation",
    "features.noncommutative"
  ],
  "performance": {
    "complexity": "Varies: O(1) for linear, O(n^3) for polynomial factoring"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}