{
  "topic": "advanced.pde.user_guide",
  "title": "PDE User Guide - MathHook CAS",
  "description": "Comprehensive user guide for solving partial differential equations with MathHook. Covers\nfundamental PDE concepts, classification systems, the method of characteristics for first-order\nPDEs, and practical examples including transport equations, Burgers' equation, and heat equations.\nIncludes educational features, troubleshooting, and performance considerations.\n",
  "mathematical_definition": "A **partial differential equation (PDE)** is a functional equation involving partial derivatives:\n\n$$F\\left(x, y, u, \\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial y}, \\frac{\\partial^2 u}{\\partial x^2}, \\ldots\\right) = 0$$\n\n**First-order quasi-linear PDE**:\n\n$$a(x,y,u) \\frac{\\partial u}{\\partial x} + b(x,y,u) \\frac{\\partial u}{\\partial y} = c(x,y,u)$$\n\n**Characteristic equations** (method of characteristics):\n\n$$\\frac{dx}{ds} = a(x,y,u), \\quad \\frac{dy}{ds} = b(x,y,u), \\quad \\frac{du}{ds} = c(x,y,u)$$\n",
  "code_refs": {
    "rust": "mathhook_core::pde",
    "python": "mathhook.pde",
    "nodejs": "mathhook.pde"
  },
  "examples": [
    {
      "title": "Transport Equation (Step-by-Step)",
      "explanation": "Solve transport equation ∂u/∂t + 2·∂u/∂x = 0 with initial condition u(x,0) = sin(x)",
      "code": {
        "rust": "let u = symbol!(u);\nlet t = symbol!(t);\nlet x = symbol!(x);\n\n// Build the PDE\nlet equation = expr!(u);\nlet pde = Pde::new(equation, u.clone(), vec![t.clone(), x.clone()]);\n\n// Solve using method of characteristics\nlet result = method_of_characteristics(&pde)?;\n\nprintln!(\"Characteristic equations:\");\nfor (i, char_eq) in result.characteristic_equations.iter().enumerate() {\n    println!(\"  Equation {}: {}\", i + 1, char_eq);\n}\n\nprintln!(\"\\nGeneral solution: {}\", result.solution);\n\n// Apply initial condition: u(x,0) = sin(x)\n// Solution: u(x,t) = sin(x - 2t)\nlet solution_with_ic = expr!(sin(x + (-2) * t));\nprintln!(\"\\nSpecific solution: u(x,t) = {}\", solution_with_ic);\n",
        "python": "u = symbol('u')\nt = symbol('t')\nx = symbol('x')\n\n# Build the PDE\nequation = expr(u)\npde = Pde(equation, u, [t, x])\n\n# Solve using method of characteristics\nresult = method_of_characteristics(pde)\n\nprint(\"Characteristic equations:\")\nfor i, char_eq in enumerate(result.characteristic_equations):\n    print(f\"  Equation {i + 1}: {char_eq}\")\n\nprint(f\"\\nGeneral solution: {result.solution}\")\n\n# Apply initial condition: u(x,0) = sin(x)\n# Solution: u(x,t) = sin(x - 2t)\nsolution_with_ic = expr('sin(x + (-2) * t)')\nprint(f\"\\nSpecific solution: u(x,t) = {solution_with_ic}\")\n",
        "nodejs": "const u = symbol('u');\nconst t = symbol('t');\nconst x = symbol('x');\n\n// Build the PDE\nconst equation = expr(u);\nconst pde = new Pde(equation, u, [t, x]);\n\n// Solve using method of characteristics\nconst result = methodOfCharacteristics(pde);\n\nconsole.log(\"Characteristic equations:\");\nresult.characteristicEquations.forEach((charEq, i) => {\n    console.log(`  Equation ${i + 1}: ${charEq}`);\n});\n\nconsole.log(`\\nGeneral solution: ${result.solution}`);\n\n// Apply initial condition: u(x,0) = sin(x)\n// Solution: u(x,t) = sin(x - 2t)\nconst solutionWithIc = expr('sin(x + (-2) * t)');\nconsole.log(`\\nSpecific solution: u(x,t) = ${solutionWithIc}`);\n"
      }
    },
    {
      "title": "Verifying PDE Solution",
      "explanation": "Check that solution satisfies the PDE and initial condition",
      "code": {
        "rust": "use derivatives::Derivative;\nuse mathhook::simplify::Simplify;\n\n// Solution: u(x,t) = sin(x - 2*t)\nlet solution = expr!(sin(x + (-2) * t));\n\n// Verify PDE: ∂u/∂t + 2·∂u/∂x = 0\nlet du_dt = solution.derivative(t.clone());\nlet du_dx = solution.derivative(x.clone());\n\nprintln!(\"∂u/∂t = {}\", du_dt);\n// Output: -2*cos(x - 2*t)\n\nprintln!(\"∂u/∂x = {}\", du_dx);\n// Output: cos(x - 2*t)\n\n// Check PDE\nlet lhs = expr!(du_dt + 2 * du_dx);\nprintln!(\"PDE LHS = {}\", lhs.simplify());\n// Output: 0 ✓\n",
        "python": "from mathhook.derivatives import derivative\nfrom mathhook.simplify import simplify\n\n# Solution: u(x,t) = sin(x - 2*t)\nsolution = expr('sin(x + (-2) * t)')\n\n# Verify PDE: ∂u/∂t + 2·∂u/∂x = 0\ndu_dt = derivative(solution, t)\ndu_dx = derivative(solution, x)\n\nprint(f\"∂u/∂t = {du_dt}\")\n# Output: -2*cos(x - 2*t)\n\nprint(f\"∂u/∂x = {du_dx}\")\n# Output: cos(x - 2*t)\n\n# Check PDE\nlhs = expr(f\"{du_dt} + 2 * {du_dx}\")\nprint(f\"PDE LHS = {simplify(lhs)}\")\n# Output: 0 ✓\n",
        "nodejs": "const { derivative } = require('mathhook/derivatives');\nconst { simplify } = require('mathhook/simplify');\n\n// Solution: u(x,t) = sin(x - 2*t)\nconst solution = expr('sin(x + (-2) * t)');\n\n// Verify PDE: ∂u/∂t + 2·∂u/∂x = 0\nconst duDt = derivative(solution, t);\nconst duDx = derivative(solution, x);\n\nconsole.log(`∂u/∂t = ${duDt}`);\n// Output: -2*cos(x - 2*t)\n\nconsole.log(`∂u/∂x = ${duDx}`);\n// Output: cos(x - 2*t)\n\n// Check PDE\nconst lhs = expr(`${duDt} + 2 * ${duDx}`);\nconsole.log(`PDE LHS = ${simplify(lhs)}`);\n// Output: 0 ✓\n"
      }
    },
    {
      "title": "Burgers' Equation (Nonlinear)",
      "explanation": "Analyze Burgers' equation ∂u/∂t + u·∂u/∂x = 0 showing nonlinear characteristics",
      "code": {
        "rust": "// Burgers' equation coefficients\nlet u_sym = symbol!(u);\nlet coefficients = PdeCoefficients {\n    a: expr!(1),                         // Coefficient of ∂u/∂t\n    b: expr!(u_sym),                     // Coefficient of ∂u/∂x (nonlinear!)\n    c: expr!(0),                         // RHS\n};\n\nprintln!(\"Burgers' equation characteristic system:\");\nprintln!(\"dt/ds = {}\", coefficients.a);\nprintln!(\"dx/ds = {}\", coefficients.b);  // Note: depends on u!\nprintln!(\"du/ds = {}\", coefficients.c);\n\n// The solution u = F(x - u*t) is implicit (requires solving for u)\n// Warning: Can develop shocks where characteristics intersect\n",
        "python": "# Burgers' equation coefficients\nu_sym = symbol('u')\ncoefficients = PdeCoefficients(\n    a=expr(1),           # Coefficient of ∂u/∂t\n    b=expr(u_sym),       # Coefficient of ∂u/∂x (nonlinear!)\n    c=expr(0)            # RHS\n)\n\nprint(\"Burgers' equation characteristic system:\")\nprint(f\"dt/ds = {coefficients.a}\")\nprint(f\"dx/ds = {coefficients.b}\")  # Note: depends on u!\nprint(f\"du/ds = {coefficients.c}\")\n\n# The solution u = F(x - u*t) is implicit (requires solving for u)\n# Warning: Can develop shocks where characteristics intersect\n",
        "nodejs": "// Burgers' equation coefficients\nconst uSym = symbol('u');\nconst coefficients = {\n    a: expr(1),           // Coefficient of ∂u/∂t\n    b: expr(uSym),        // Coefficient of ∂u/∂x (nonlinear!)\n    c: expr(0)            // RHS\n};\n\nconsole.log(\"Burgers' equation characteristic system:\");\nconsole.log(`dt/ds = ${coefficients.a}`);\nconsole.log(`dx/ds = ${coefficients.b}`);  // Note: depends on u!\nconsole.log(`du/ds = ${coefficients.c}`);\n\n// The solution u = F(x - u*t) is implicit (requires solving for u)\n// Warning: Can develop shocks where characteristics intersect\n"
      }
    },
    {
      "title": "Educational Step-by-Step Solver",
      "explanation": "Get detailed explanations of solution process",
      "code": {
        "rust": "let solver = EducationalPDESolver::new();\n\nlet u = symbol!(u);\nlet x = symbol!(x);\nlet t = symbol!(t);\n\nlet equation = expr!(u + x);\n\n// Solve with explanations\nlet (result, explanation) = solver.solve_pde(&equation, &u, &[x, t]);\n\n// Display step-by-step explanation\nprintln!(\"Educational Explanation:\");\nfor (i, step) in explanation.steps.iter().enumerate() {\n    println!(\"Step {}: {}\", i + 1, step.title);\n    println!(\"  {}\", step.description);\n    println!();\n}\n",
        "python": "solver = EducationalPDESolver()\n\nu = symbol('u')\nx = symbol('x')\nt = symbol('t')\n\nequation = expr('u + x')\n\n# Solve with explanations\nresult, explanation = solver.solve_pde(equation, u, [x, t])\n\n# Display step-by-step explanation\nprint(\"Educational Explanation:\")\nfor i, step in enumerate(explanation.steps):\n    print(f\"Step {i + 1}: {step.title}\")\n    print(f\"  {step.description}\")\n    print()\n",
        "nodejs": "const solver = new EducationalPDESolver();\n\nconst u = symbol('u');\nconst x = symbol('x');\nconst t = symbol('t');\n\nconst equation = expr('u + x');\n\n// Solve with explanations\nconst [result, explanation] = solver.solvePde(equation, u, [x, t]);\n\n// Display step-by-step explanation\nconsole.log(\"Educational Explanation:\");\nexplanation.steps.forEach((step, i) => {\n    console.log(`Step ${i + 1}: ${step.title}`);\n    console.log(`  ${step.description}`);\n    console.log();\n});\n"
      }
    }
  ],
  "article": {
    "content": "# PDE User Guide - MathHook CAS\n\nComplete user guide content from the original markdown file, covering:\n- Introduction to PDEs and their real-world applications\n- PDE classification (by order, type, linearity)\n- Getting started with MathHook\n- Basic PDE solving examples\n- Method of characteristics\n- Educational features\n- Common patterns and troubleshooting\n- Advanced topics and API reference\n"
  },
  "use_cases": [
    "Heat diffusion modeling in materials science",
    "Wave propagation analysis in acoustics and electromagnetics",
    "Fluid dynamics and Navier-Stokes simulations",
    "Quantum mechanics - Schrödinger equation",
    "Electrostatics - Laplace and Poisson equations",
    "Traffic flow modeling",
    "Education and learning PDE concepts"
  ],
  "related_topics": [
    "advanced.pde.technical_guide",
    "advanced.pde.registry",
    "advanced.pde.sympy_validation",
    "advanced.pde.performance"
  ],
  "performance": {
    "complexity": "O(N·M) for N time steps and M spatial grid points",
    "typical_time": "~100 μs for full method of characteristics"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}