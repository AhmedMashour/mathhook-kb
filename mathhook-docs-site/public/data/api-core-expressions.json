{
  "topic": "api.core.expressions",
  "title": "Core Expression System",
  "description": "The Expression type is the foundation of MathHook. Expressions are immutable,\n32-byte cache-optimized structures representing mathematical constructs from\nnumbers to complex symbolic operations.\n",
  "code_refs": {
    "rust": "mathhook_core::expression::Expression",
    "python": "mathhook.Expression",
    "nodejs": "mathhook.Expression"
  },
  "examples": [
    {
      "title": "Creating Expressions with Macros",
      "explanation": "Use expr!() and symbol!() macros for ergonomic expression creation",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet y = symbol!(y);\n\n// Basic arithmetic\nlet sum = expr!(x + y);\nlet product = expr!(x * y);\nlet power = expr!(x ^ 2);\n\n// Complex nested expressions\nlet complex = expr!(sin(x ^ 2) + cos(y ^ 2));\n",
        "python": "from mathhook import symbol, expr\n\nx = symbol('x')\ny = symbol('y')\n\n# Basic arithmetic\nsum_expr = x + y\nproduct = x * y\npower = x**2\n\n# Complex nested expressions\nfrom mathhook import sin, cos\ncomplex_expr = sin(x**2) + cos(y**2)\n",
        "nodejs": "import { symbol, parse } from 'mathhook';\n\nconst x = symbol('x');\nconst y = symbol('y');\n\n// Parse expressions\nconst sum = parse('x + y');\nconst product = parse('x * y');\nconst power = parse('x^2');\n\n// Complex nested expressions\nconst complex = parse('sin(x^2) + cos(y^2)');\n"
      }
    },
    {
      "title": "Immutability and Operations",
      "explanation": "All operations return new expressions, original unchanged",
      "code": {
        "rust": "let expr = expr!(x + 1);\nlet doubled = expr.mul(&expr!(2));  // Returns new expression\n// `expr` is unchanged - still x + 1\n\n// Safe to use in multiple threads\nuse std::sync::Arc;\nlet expr_arc = Arc::new(expr!(x ^ 2));\nlet clone = Arc::clone(&expr_arc);\n",
        "python": "expr = x + 1\ndoubled = expr * 2  # Returns new expression\n# expr is unchanged - still x + 1\n\n# Safe for concurrent use\nimport threading\nshared_expr = x**2\n",
        "nodejs": "const expr = parse('x + 1');\nconst doubled = expr.mul(2);  // Returns new expression\n// expr is unchanged - still x + 1\n\n// Immutable - safe for concurrent access\n"
      }
    },
    {
      "title": "Canonical Forms and Equality",
      "explanation": "Automatic normalization ensures equivalent expressions are equal",
      "code": {
        "rust": "let expr1 = expr!(x + y);\nlet expr2 = expr!(y + x);\nassert_eq!(expr1, expr2);  // True - both normalized to x + y\n\n// Flattening\nlet nested = expr!((x + y) + z);\n// Automatically flattened to Add(x, y, z)\n\n// Identity removal\nlet identity = expr!(x + 0);\nassert_eq!(identity.simplify(), expr!(x));\n",
        "python": "expr1 = x + y\nexpr2 = y + x\nassert expr1 == expr2  # True - both normalized to x + y\n\n# Flattening and identity removal\nnested = (x + y) + z\nidentity = x + 0\nassert identity.simplify() == x\n",
        "nodejs": "const expr1 = parse('x + y');\nconst expr2 = parse('y + x');\n// Both normalized to x + y\n\n// Identity removal\nconst identity = parse('x + 0');\nconst simplified = identity.simplify();\n// Result: x\n"
      }
    },
    {
      "title": "Pattern Matching and Structure",
      "explanation": "Work with expression structure using pattern matching",
      "code": {
        "rust": "use mathhook::Expression;\n\nmatch expr {\n    Expression::Add(terms) => {\n        println!(\"Sum with {} terms\", terms.len());\n    }\n    Expression::Mul(factors) => {\n        println!(\"Product with {} factors\", factors.len());\n    }\n    Expression::Pow(base, exp) => {\n        println!(\"Power: {} ^ {}\", base, exp);\n    }\n    Expression::Function(name, args) => {\n        println!(\"Function {} with {} args\", name, args.len());\n    }\n    _ => {}\n}\n",
        "python": "from mathhook import Expression\n\n# Python uses method introspection\nif expr.is_add():\n    terms = expr.get_terms()\n    print(f\"Sum with {len(terms)} terms\")\nelif expr.is_mul():\n    factors = expr.get_factors()\n    print(f\"Product with {len(factors)} factors\")\nelif expr.is_pow():\n    base, exp = expr.get_base_exp()\n    print(f\"Power: {base} ^ {exp}\")\n",
        "nodejs": "import { Expression } from 'mathhook';\n\n// Node.js uses type checking methods\nif (expr.isAdd()) {\n    const terms = expr.getTerms();\n    console.log(`Sum with ${terms.length} terms`);\n} else if (expr.isMul()) {\n    const factors = expr.getFactors();\n    console.log(`Product with ${factors.length} factors`);\n} else if (expr.isPow()) {\n    const [base, exp] = expr.getBaseExp();\n    console.log(`Power: ${base} ^ ${exp}`);\n}\n"
      }
    }
  ],
  "article": {
    "content": "# Core Expression System\n\n## Overview\n\nThe `Expression` type is MathHook's core data structure, designed for:\n- **Immutability**: Thread-safe, predictable behavior\n- **Performance**: 32-byte size for cache optimization (2 per cache line)\n- **Canonical Forms**: Automatic normalization for equality checking\n\n## Expression Structure\n\nExpressions use Rust enums for type-safe mathematical constructs:\n- **Numbers**: Integer, Rational, Float, Complex\n- **Variables**: Symbol\n- **Operations**: Add, Mul, Pow\n- **Functions**: Function calls (sin, cos, log, etc.)\n- **Constants**: π, e, i, φ, γ\n- **Matrices**: Matrix (noncommutative)\n- **Relations**: Equation, Inequality\n\n## Design Decisions\n\n### Why 32 Bytes?\n- Modern CPUs have 64-byte cache lines\n- Two expressions fit perfectly in one cache line\n- 3-5x faster operations in hot loops\n- Critical for CAS workloads with millions of expression traversals\n\n### Why Immutable?\n- Thread safety without locks\n- No hidden mutation surprises\n- Compiler optimizations\n- Traceable expression history\n\n### Why Canonical Forms?\n- Structural equality: y + x → x + y\n- Flattening: (a + b) + c → Add(a, b, c)\n- Identity removal: x + 0 → x\n- Rational reduction: 6/4 → 3/2\n"
  },
  "use_cases": [
    "Symbolic mathematics: algebra, calculus, equation solving",
    "Educational tools: step-by-step explanations with expression trees",
    "Computer algebra systems: pattern matching and rewriting",
    "Mathematical modeling: symbolic problem representation",
    "Code generation: transform symbolic expressions to executable code"
  ],
  "related_topics": [
    "api.core.symbols_numbers",
    "api.core.functions",
    "api.operations.simplification",
    "api.operations.substitution"
  ],
  "performance": {
    "complexity": "O(1) construction, O(n) operations for n-node trees",
    "typical_time": "50ns construction, 10-100μs simplification"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}