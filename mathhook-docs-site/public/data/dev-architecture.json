{
  "topic": "dev.architecture",
  "title": "System Architecture",
  "description": "Deep dive into the MathHook Knowledge Base Engine architecture - a multi-format documentation generation system that transforms single schema definitions into 12+ output formats.",
  "mathematical_definition": "\\text{Schema}_{YAML} \\xrightarrow{\\text{Generators}} \\{\\text{Jupyter}, \\text{mdBook}, \\text{Vue}, \\text{LaTeX}, ...\\}",
  "examples": [
    {
      "title": "Repository Structure",
      "explanation": "The Knowledge Base Engine is organized into Rust crates, templates, and schemas. Each generator is a separate crate implementing the `OutputGenerator` trait.",
      "code": {
        "python": "# Repository structure overview\nmathhook_kb_structure = {\n    'crates/': {\n        'kb-core/':     'Core schema parsing & validation (Rust)',\n        'kb-cli/':      'CLI tool (mathhook-kb command)',\n        'kb-jupyter/':  'Jupyter notebook generator',\n        'kb-mdbook/':   'mdBook generator',\n        'kb-vue/':      'Vue SSR data generator',\n        'kb-api-docs/': 'API docs generator',\n        'kb-llm-rag/':  'LLM-optimized markdown',\n        'kb-latex/':    'LaTeX generator',\n    },\n    'templates/':  'Tera templates for all outputs',\n    'schemas/':    'Schema definitions (YAML)',\n    'generators/': {\n        'vue-site/': 'Node.js/Nuxt SSR builder',\n    },\n    'scripts/':    'Build and validation scripts',\n}\n\n# Each crate follows this pattern:\n# kb-{format}/ contains the generator for that format\n",
        "rust": "// Core crate structure\n// crates/kb-core/src/lib.rs\n\npub mod schema;      // Schema types and parsing\npub mod validation;  // Schema validation\npub mod generator;   // OutputGenerator trait\n\n// crates/kb-jupyter/src/lib.rs\nuse kb_core::generator::OutputGenerator;\nuse kb_core::schema::Schema;\n\npub struct JupyterGenerator {\n    template_dir: PathBuf,\n    tera: Tera,\n}\n\nimpl OutputGenerator for JupyterGenerator {\n    fn name(&self) -> &str { \"jupyter\" }\n    fn file_extension(&self) -> &str { \"ipynb\" }\n    \n    fn generate(&self, schema: &Schema) -> Result<String> {\n        // Generate .ipynb JSON\n    }\n    \n    fn validate_output(&self, output: &str) -> Result<()> {\n        // Validate notebook structure\n    }\n}\n",
        "nodejs": "// Vue SSR generator structure\n// generators/vue-site/\n\nconst structure = {\n    'nuxt.config.ts':    'Nuxt 3 configuration',\n    'pages/': {\n        'index.vue':     'Homepage',\n        'docs/': {\n            'index.vue':   'Docs listing',\n            '[topic].vue': 'Dynamic topic pages',\n        },\n    },\n    'public/data/':      'JSON data from Rust generator',\n    'components/':       'Reusable Vue components',\n};\n\n// Rust kb-vue generates JSON data\n// Nuxt consumes JSON and renders Vue components\n"
      },
      "expected_output": "mathhook-kb/\n├── crates/          # Rust generators\n├── templates/       # Tera templates\n├── schemas/         # YAML definitions\n└── generators/      # Node.js builders"
    },
    {
      "title": "Generator Trait Pattern",
      "explanation": "All generators implement the `OutputGenerator` trait, ensuring consistent interfaces and extensibility. New formats can be added without modifying core code.",
      "code": {
        "python": "# Python equivalent of the generator pattern\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any\n\nclass OutputGenerator(ABC):\n    \"\"\"Base class for all documentation generators\"\"\"\n    \n    @property\n    @abstractmethod\n    def name(self) -> str:\n        \"\"\"Generator name (e.g., 'jupyter')\"\"\"\n        pass\n    \n    @property\n    @abstractmethod\n    def file_extension(self) -> str:\n        \"\"\"Output file extension (e.g., 'ipynb')\"\"\"\n        pass\n    \n    @abstractmethod\n    def generate(self, schema: Dict[str, Any]) -> str:\n        \"\"\"Generate output from schema\"\"\"\n        pass\n    \n    @abstractmethod\n    def validate_output(self, output: str) -> None:\n        \"\"\"Validate generated output\"\"\"\n        pass\n\nclass JupyterGenerator(OutputGenerator):\n    @property\n    def name(self) -> str:\n        return 'jupyter'\n    \n    @property\n    def file_extension(self) -> str:\n        return 'ipynb'\n    \n    def generate(self, schema):\n        # Build notebook structure\n        pass\n    \n    def validate_output(self, output):\n        # Validate JSON structure\n        pass\n",
        "rust": "// Define the generator trait\npub trait OutputGenerator {\n    /// Generator name (e.g., \"jupyter\")\n    fn name(&self) -> &str;\n    \n    /// Output file extension (e.g., \"ipynb\")\n    fn file_extension(&self) -> &str;\n    \n    /// Generate output from validated schema\n    fn generate(&self, schema: &Schema) -> Result<String>;\n    \n    /// Validate the generated output\n    fn validate_output(&self, output: &str) -> Result<()>;\n}\n\n// Register all generators\nfn build_generator_registry() -> Vec<Box<dyn OutputGenerator>> {\n    vec![\n        Box::new(JupyterGenerator::new(\"templates/jupyter\")),\n        Box::new(MdBookGenerator::new(\"templates/mdbook\")),\n        Box::new(VueGenerator::new(\"templates/vue\")),\n        Box::new(LatexGenerator::new(\"templates/latex\")),\n        Box::new(LlmRagGenerator::new(\"templates/llm-rag\")),\n    ]\n}\n\n// Generate all formats from one schema\nfn generate_all(schema: &Schema, generators: &[Box<dyn OutputGenerator>]) {\n    for gen in generators {\n        let output = gen.generate(schema)?;\n        gen.validate_output(&output)?;\n        write_file(&format!(\"{}.{}\", schema.topic, gen.file_extension()), &output)?;\n    }\n}\n",
        "nodejs": "// TypeScript generator interface\ninterface OutputGenerator {\n    readonly name: string;\n    readonly fileExtension: string;\n    \n    generate(schema: Schema): Promise<string>;\n    validateOutput(output: string): Promise<void>;\n}\n\nclass JupyterGenerator implements OutputGenerator {\n    readonly name = 'jupyter';\n    readonly fileExtension = 'ipynb';\n    \n    async generate(schema: Schema): Promise<string> {\n        const notebook = {\n            nbformat: 4,\n            nbformat_minor: 5,\n            metadata: { kernelspec: { name: 'python3' } },\n            cells: this.buildCells(schema),\n        };\n        return JSON.stringify(notebook, null, 2);\n    }\n    \n    async validateOutput(output: string): Promise<void> {\n        const nb = JSON.parse(output);\n        if (nb.nbformat !== 4) {\n            throw new Error('Invalid nbformat version');\n        }\n    }\n}\n"
      },
      "expected_output": "Generator registry:\n- jupyter  (.ipynb)\n- mdbook   (.md)\n- vue      (.json)\n- latex    (.tex)\n- llm-rag  (.md)"
    },
    {
      "title": "Template Engine (Tera)",
      "explanation": "Templates separate content (schemas) from presentation. Tera provides Jinja2-like syntax for generating any text format.",
      "code": {
        "python": "# Python equivalent using Jinja2\nfrom jinja2 import Environment, FileSystemLoader\n\nenv = Environment(loader=FileSystemLoader('templates/'))\n\n# Load template\ntemplate = env.get_template('jupyter/notebook.jinja2')\n\n# Render with schema data\noutput = template.render(\n    title=schema['title'],\n    description=schema['description'],\n    examples=schema['examples'],\n    mathematical_definition=schema['mathematical_definition'],\n)\n\n# Template file (jupyter/notebook.jinja2):\n'''\n{\n  \"nbformat\": 4,\n  \"cells\": [\n    {\n      \"cell_type\": \"markdown\",\n      \"source\": [\"# {{ title }}\\n\", \"{{ description }}\"]\n    },\n    {% for example in examples %}\n    {\n      \"cell_type\": \"code\",\n      \"source\": {{ example.code.python | tojson }}\n    },\n    {% endfor %}\n  ]\n}\n'''\n",
        "rust": "use tera::{Tera, Context};\n\n// Initialize template engine\nlet tera = Tera::new(\"templates/**/*.tera\")?;\n\n// Build template context from schema\nlet mut context = Context::new();\ncontext.insert(\"title\", &schema.title);\ncontext.insert(\"description\", &schema.description);\ncontext.insert(\"examples\", &schema.examples);\ncontext.insert(\"math_def\", &schema.mathematical_definition);\n\n// Render template\nlet output = tera.render(\"jupyter/notebook.tera\", &context)?;\n\n// Template file (templates/jupyter/notebook.tera):\n// {\n//   \"nbformat\": 4,\n//   \"cells\": [\n//     {\n//       \"cell_type\": \"markdown\",\n//       \"source\": [\"# {{ title }}\\n\", \"{{ description }}\"]\n//     },\n//     {% for example in examples %}\n//     {\n//       \"cell_type\": \"code\",\n//       \"source\": {{ example.code.python | json_encode() }}\n//     },\n//     {% endfor %}\n//   ]\n// }\n",
        "nodejs": "// Tera-like template with Nunjucks\nconst nunjucks = require('nunjucks');\n\nconst env = nunjucks.configure('templates/', {\n    autoescape: true,\n    noCache: process.env.NODE_ENV !== 'production',\n});\n\n// Render template\nconst output = env.render('jupyter/notebook.njk', {\n    title: schema.title,\n    description: schema.description,\n    examples: schema.examples,\n    mathematical_definition: schema.mathematical_definition,\n});\n\nconsole.log('Template rendered successfully');\n"
      },
      "expected_output": "Template separation:\nschemas/derivative.yaml  -> Content (what)\ntemplates/jupyter/*.tera -> Presentation (how)"
    }
  ],
  "article": {
    "introduction": {
      "hook": "The **MathHook Knowledge Base Engine** is a multi-format documentation generation system built in Rust. Its core principle is **Single Source of Truth** - one YAML schema file generates 12+ output formats including Jupyter notebooks, mdBook pages, Vue components, LaTeX papers, and LLM-optimized markdown.\n\nThis architecture ensures consistency across all documentation while allowing format-specific customization through output hints and templates."
    },
    "sections": [
      {
        "title": "Output Formats",
        "content": "The Knowledge Base Engine generates 12+ documentation formats from a single schema:\n\n### Interactive Formats ###\n1. **Jupyter Notebooks** (`.ipynb`) - Interactive Python tutorials\n2. **Google Colab Notebooks** - Zero-install onboarding with Colab metadata\n3. **Observable Notebooks** (`.js`) - Interactive visualizations\n\n### Documentation Formats ###\n4. **mdBook** (`.md`) - Rust-style documentation\n5. **Vue SSR Static Site** - Marketing/learning hub with Vue components\n6. **Interactive API Docs** - VitePress-compatible with live playground\n\n### Academic Formats ###\n7. **LaTeX/PDF** - Academic paper templates\n8. **LLM-Optimized RAG Markdown** - Chunked for AI agent retrieval\n\n### Integration Formats ###\n9. **Benchmark Dashboard** (JSON) - Performance comparisons\n10. **LangChain Integration Guides** - Agent framework docs\n11. **MCP Server** - AI code navigation\n12. **Video Tutorial Companions** - Transcripts + notebooks"
      },
      {
        "title": "Technology Stack",
        "content": "### Core Engine (Rust) ###\n\n**Schema & Serialization**:\n- `serde` + `serde_yaml` + `serde_json` - Type-safe parsing\n\n**Templating**:\n- `tera` - Jinja2-like templates, Rust-native\n\n**CLI**:\n- `clap` - Derive-based argument parsing\n- `colored` - Terminal colors for errors\n\n**Code Analysis**:\n- `syn` - Rust AST parsing for validation\n- `tree-sitter` - Multi-language parsing (future)\n\n**Error Handling**:\n- `anyhow` - Flexible error types\n- `thiserror` - Derive Error implementations\n\n### Vue SSR Builder ###\n\n- **Nuxt 3** - Vue SSR framework\n- **Tailwind CSS** - Utility-first styling\n- **KaTeX** - Math rendering\n- **Prism.js** - Syntax highlighting"
      },
      {
        "title": "Data Flow",
        "content": "### Schema to Output Pipeline ###\n\n```\n1. Parse YAML Schema\n   ├── serde_yaml::from_str()\n   └── Deserialize into Schema struct\n\n2. Validate Schema\n   ├── Check required fields\n   ├── Validate code references\n   └── Check example syntax\n\n3. For Each Generator\n   ├── Load Tera templates\n   ├── Build Context from Schema\n   ├── Render template\n   └── Validate output\n\n4. Write Output Files\n   ├── derivative.ipynb\n   ├── derivative.md\n   ├── derivative.json (for Vue)\n   └── derivative.tex\n```\n\n### Template Context ###\n\nTemplates receive a context with all schema fields plus computed values:\n- `title`, `description`, `topic`\n- `mathematical_definition`\n- `examples[]` with multi-language code\n- `article.sections[]` for long-form content\n- `use_cases[]`, `related_topics[]`\n- Format-specific `outputs.*` hints"
      },
      {
        "title": "Extension Points",
        "content": "### Adding a New Generator ###\n\n1. Create new crate: `crates/kb-{format}/`\n2. Implement `OutputGenerator` trait\n3. Create templates: `templates/{format}/`\n4. Add to generator registry\n5. Update CLI\n\n### Adding Schema Fields ###\n\n1. Update `Schema` struct in `kb-core`\n2. Add validation rules\n3. Update all generators to use new field\n4. Update templates\n5. Document in schema reference\n\n### Custom Output Hints ###\n\nSchemas can include format-specific hints:\n\n```yaml\noutputs:\n  jupyter:\n    include_interactive_plots: true\n  mdbook:\n    include_mathematical_proof: true\n  vue_site:\n    seo_keywords: [\"calculus\", \"derivative\"]\n```"
      }
    ],
    "sidebars": [
      {
        "type": "performance",
        "title": "Performance Target",
        "content": "Schema parsing and generation should complete in **<1 second** for typical schemas.\n\n**Optimization strategies**:\n- Parse schemas in parallel (rayon)\n- Cache template compilation\n- Lazy evaluation where possible"
      },
      {
        "type": "info",
        "title": "Design Philosophy",
        "content": "**Hybrid Schema (Option C)**:\n\n- **Core content** (required): topic, title, description, examples\n- **Output hints** (optional): format-specific customization\n- **Engine fills gaps**: sensible defaults when hints missing"
      }
    ]
  },
  "use_cases": [
    "Understanding the multi-format generation architecture",
    "Adding new output format generators",
    "Customizing template presentation",
    "Extending schema fields"
  ],
  "related_topics": [
    "dev-claude-md",
    "dev-schema-reference",
    "dev-generator-guide"
  ]
}
