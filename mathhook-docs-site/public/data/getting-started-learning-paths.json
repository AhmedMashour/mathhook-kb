{
  "topic": "getting-started.learning-paths",
  "title": "Learning Paths",
  "description": "Choose your journey based on background and goals. Structured learning paths for\nPython data scientists, Node.js developers, Rust programmers, mathematics educators,\nand computational scientists with time estimates and outcomes.\n",
  "code_refs": {
    "rust": "mathhook::prelude",
    "python": "mathhook",
    "nodejs": "mathhook-node"
  },
  "examples": [
    {
      "title": "Python Data Scientist - SymPy Migration",
      "explanation": "Quick comparison of SymPy vs MathHook syntax",
      "code": {
        "rust": "// Not applicable for Python path\n",
        "python": "# SymPy syntax (familiar to data scientists)\n# from sympy import symbols, simplify\n# x, y = symbols('x y')\n# expr = (x + y)**2\n\n# MathHook syntax (similar but faster)\nfrom mathhook import Expression\n\nx = Expression.symbol('x')\ny = Expression.symbol('y')\nexpr = (x.add(y)).pow(2)\nsimplified = expr.simplify()\n",
        "nodejs": "// Not applicable for Python path\n"
      }
    },
    {
      "title": "Node.js Developer - Web Form Parsing",
      "explanation": "Parse user input LaTeX from web forms",
      "code": {
        "rust": "// Not applicable for Node.js path\n",
        "python": "# Not applicable for Node.js path\n",
        "nodejs": "import { Parser, ParserConfig } from 'mathhook-node';\n\n// Parse LaTeX from web form input\nconst userInput = req.body.equation; // e.g., \"x^2 + 2x + 1\"\nconst parser = new Parser(ParserConfig.default());\nconst expr = parser.parse(userInput);\n\n// Render LaTeX output for display\nconst latex = expr.toLatex();\nres.json({ latex });\n"
      }
    },
    {
      "title": "Rust Programmer - Custom Extension",
      "explanation": "Extend Universal Function Registry with custom function",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Implement custom simplification rule\nfn custom_simplify(expr: &Expression) -> Expression {\n    // Custom logic here\n    expr.clone()\n}\n\n// Register custom function\n// (Actual API may vary - check documentation)\nlet x = symbol!(x);\nlet expr = expr!(x ^ 2);\n",
        "python": "# Not applicable for Rust path\n",
        "nodejs": "// Not applicable for Rust path\n"
      }
    },
    {
      "title": "Mathematics Educator - Step-by-Step",
      "explanation": "Generate educational explanations for students",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet expr = expr!((x + 1) * (x - 1));\n\nlet explanation = expr.explain_simplification();\nfor step in &explanation.steps {\n    println!(\"{}: {}\", step.title, step.description);\n}\n",
        "python": "from mathhook import Expression\n\nx = Expression.symbol('x')\nexpr = (x.add(1)).mul(x.sub(1))\n\nexplanation = expr.explain_simplification()\nfor step in explanation.steps:\n    print(f\"{step.title}: {step.description}\")\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\nconst expr = x.add(1).mul(x.sub(1));\n\nconst explanation = expr.explainSimplification();\nfor (const step of explanation.steps) {\n    console.log(`${step.title}: ${step.description}`);\n}\n"
      }
    },
    {
      "title": "Computational Scientist - Symbolic Jacobian",
      "explanation": "Generate Jacobian matrix for nonlinear system",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet y = symbol!(y);\n\n// System of equations\nlet f1 = expr!(add: (x ^ 2), y);\nlet f2 = expr!(x * y);\n\n// Compute Jacobian symbolically\nlet df1_dx = f1.derivative(x.clone());\nlet df1_dy = f1.derivative(y.clone());\nlet df2_dx = f2.derivative(x.clone());\nlet df2_dy = f2.derivative(y.clone());\n\nlet jacobian = Expression::matrix(vec![\n    vec![df1_dx, df1_dy],\n    vec![df2_dx, df2_dy],\n]);\n",
        "python": "from mathhook import Expression\n\nx = Expression.symbol('x')\ny = Expression.symbol('y')\n\n# System of equations\nf1 = x.pow(2).add(y)\nf2 = x.mul(y)\n\n# Compute Jacobian symbolically\ndf1_dx = f1.derivative(x)\ndf1_dy = f1.derivative(y)\ndf2_dx = f2.derivative(x)\ndf2_dy = f2.derivative(y)\n\njacobian = Expression.matrix([\n    [df1_dx, df1_dy],\n    [df2_dx, df2_dy]\n])\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\nconst y = Expression.symbol('y');\n\n// System of equations\nconst f1 = x.pow(2).add(y);\nconst f2 = x.mul(y);\n\n// Compute Jacobian symbolically\nconst df1_dx = f1.derivative(x);\nconst df1_dy = f1.derivative(y);\nconst df2_dx = f2.derivative(x);\nconst df2_dy = f2.derivative(y);\n\nconst jacobian = Expression.matrix([\n    [df1_dx, df1_dy],\n    [df2_dx, df2_dy]\n]);\n"
      }
    }
  ],
  "article": {
    "content": "# Learning Paths\n\nChoose your journey based on your background and goals. Each path is designed to\nget you productive with MathHook as quickly as possible.\n\n## Path 1: Python Data Scientist\n\n**Background**: Familiar with NumPy, SymPy, pandas\n**Goal**: Use MathHook for faster symbolic computation in Python\n**Time to Productivity**: 1-2 hours\n\nLearn Python API, performance comparison with SymPy, integration with data science\nstack, and when to use MathHook vs SymPy.\n\n## Path 2: Node.js/TypeScript Developer\n\n**Background**: JavaScript/TypeScript web development\n**Goal**: Add symbolic math to web applications\n**Time to Productivity**: 2-3 hours\n\nLearn Node.js bindings, LaTeX parsing for web forms, web framework integration,\nand V8 optimization.\n\n## Path 3: Rust Systems Programmer\n\n**Background**: Rust experience, need high-performance CAS\n**Goal**: Embed MathHook in Rust application or contribute to core\n**Time to Productivity**: 4-6 hours to mastery\n\nLearn architecture, memory layout, SIMD optimization, and custom extensions.\n\n## Path 4: Mathematics Student/Educator\n\n**Background**: Calculus, linear algebra, abstract algebra knowledge\n**Goal**: Understand CAS internals, use for teaching, contribute\n**Time to Productivity**: 8-12 hours to contribution-ready\n\nLearn symbolic computation theory, algorithm implementation, and educational features.\n\n## Path 5: Computational Scientist\n\n**Background**: MATLAB, Julia, scientific computing\n**Goal**: Fast symbolic preprocessing for numerical simulations\n**Time to Productivity**: 3-4 hours\n\nLearn symbolic matrix algebra, system solving, hybrid symbolic-numerical workflows,\nand code generation.\n\n## Common Themes\n\nEssential concepts for all users:\n- Expressions are immutable (safe for concurrent use)\n- Canonical forms (x + y equals y + x)\n- Exact vs approximate arithmetic (rationals vs floats)\n- Error handling (domain errors, undefined operations)\n"
  },
  "use_cases": [
    "Onboarding new users with tailored learning paths",
    "Estimating time investment for MathHook mastery",
    "Choosing appropriate resources based on background",
    "Planning educational curriculum with MathHook"
  ],
  "related_topics": [
    "getting-started.installation",
    "getting-started.quick-start",
    "bindings.python",
    "bindings.nodejs",
    "architecture.principles",
    "educational.step-by-step"
  ],
  "metadata": {
    "schema_version": "1.0"
  }
}