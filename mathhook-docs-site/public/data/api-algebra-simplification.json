{
  "topic": "api.algebra.simplification",
  "title": "Symbolic Simplification",
  "description": "Comprehensive symbolic simplification for mathematical expressions, with full\nsupport for noncommutative algebra (matrices, operators, quaternions). Implements\ncanonical forms and mathematical identities to reduce expressions to simplest form.\n",
  "code_refs": {
    "rust": "mathhook_core::simplify::Simplify",
    "python": "mathhook.simplify",
    "nodejs": "mathhook.simplify"
  },
  "examples": [
    {
      "title": "Basic Simplification",
      "explanation": "Identity elements and constant folding",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Identity elements\nlet expr = expr!((x + 0) * 1);\nlet simplified = expr.simplify();\n// Result: x\n\n// Constant folding\nlet expr = expr!(2 + 3);\nlet simplified = expr.simplify();\n// Result: 5\n",
        "python": "from mathhook import symbol\n\nx = symbol('x')\n\n# Identity elements\nexpr = (x + 0) * 1\nsimplified = expr.simplify()\n# Result: x\n\n# Constant folding\nexpr = 2 + 3\nsimplified = expr.simplify()\n# Result: 5\n",
        "nodejs": "import { symbol, parse } from 'mathhook';\n\nconst x = symbol('x');\n\n// Identity elements\nconst expr = parse('(x + 0) * 1');\nconst simplified = expr.simplify();\n// Result: x\n\n// Constant folding\nconst expr2 = parse('2 + 3');\nconst simplified2 = expr2.simplify();\n// Result: 5\n"
      }
    },
    {
      "title": "Power Rule Simplification",
      "explanation": "Combine like powers with same base",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Combine like powers\nlet expr = expr!((x^2) * (x^3));\nlet simplified = expr.simplify();\n// Result: x^5\n\n// Multiple powers\nlet expr = expr!((x^2) * (x^3) * (x^4));\nlet simplified = expr.simplify();\n// Result: x^9\n",
        "python": "from mathhook import symbol\n\nx = symbol('x')\n\n# Combine like powers\nexpr = x**2 * x**3\nsimplified = expr.simplify()\n# Result: x^5\n\n# Multiple powers\nexpr = x**2 * x**3 * x**4\nsimplified = expr.simplify()\n# Result: x^9\n",
        "nodejs": "import { symbol, parse } from 'mathhook';\n\nconst x = symbol('x');\n\n// Combine like powers\nconst expr = parse('x^2 * x^3');\nconst simplified = expr.simplify();\n// Result: x^5\n\n// Multiple powers\nconst expr2 = parse('x^2 * x^3 * x^4');\nconst simplified2 = expr2.simplify();\n// Result: x^9\n"
      }
    },
    {
      "title": "Noncommutative Algebra",
      "explanation": "Preserve order for noncommutative symbols",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Scalar symbols (commutative) - factors can be sorted\nlet x = symbol!(x);\nlet y = symbol!(y);\nlet expr = expr!(y * x);\nlet simplified = expr.simplify();\n// Result: x * y (sorted alphabetically)\n\n// Matrix symbols (noncommutative) - order preserved\nlet A = symbol!(A; matrix);\nlet B = symbol!(B; matrix);\nlet expr = expr!(B * A);\nlet simplified = expr.simplify();\n// Result: B * A (original order preserved)\n",
        "python": "from mathhook import symbol\n\n# Scalar symbols (commutative)\nx = symbol('x')\ny = symbol('y')\nexpr = y * x\nsimplified = expr.simplify()\n# Result: x * y (sorted)\n\n# Matrix symbols (noncommutative)\nA = symbol('A', matrix=True)\nB = symbol('B', matrix=True)\nexpr = B * A\nsimplified = expr.simplify()\n# Result: B * A (order preserved)\n",
        "nodejs": "import { symbol, parse } from 'mathhook';\n\n// Scalar symbols (commutative)\nconst x = symbol('x');\nconst y = symbol('y');\nconst expr = parse('y * x');\nconst simplified = expr.simplify();\n// Result: x * y (sorted)\n\n// Matrix symbols (noncommutative)\nconst A = symbol('A', { type: 'matrix' });\nconst B = symbol('B', { type: 'matrix' });\nconst expr2 = parse('B * A');\nconst simplified2 = expr2.simplify();\n// Result: B * A (order preserved)\n"
      }
    },
    {
      "title": "Power Distribution (Commutative Only)",
      "explanation": "Distribute powers for scalars, not for matrices",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Scalars (commutative): distributes power\nlet x = symbol!(x);\nlet y = symbol!(y);\nlet expr = expr!((x * y) ^ 2);\nlet simplified = expr.simplify();\n// Result: x^2 * y^2 (distributed)\n\n// Matrices (noncommutative): does NOT distribute\nlet A = symbol!(A; matrix);\nlet B = symbol!(B; matrix);\nlet expr = expr!((A * B) ^ 2);\nlet simplified = expr.simplify();\n// Result: (A*B)^2 (NOT distributed to A^2 * B^2)\n",
        "python": "from mathhook import symbol\n\n# Scalars (commutative)\nx = symbol('x')\ny = symbol('y')\nexpr = (x * y)**2\nsimplified = expr.simplify()\n# Result: x^2 * y^2\n\n# Matrices (noncommutative)\nA = symbol('A', matrix=True)\nB = symbol('B', matrix=True)\nexpr = (A * B)**2\nsimplified = expr.simplify()\n# Result: (A*B)^2\n",
        "nodejs": "import { symbol, parse } from 'mathhook';\n\n// Scalars (commutative)\nconst expr = parse('(x * y)^2');\nconst simplified = expr.simplify();\n// Result: x^2 * y^2\n\n// Matrices (noncommutative)\nconst A = symbol('A', { type: 'matrix' });\nconst B = symbol('B', { type: 'matrix' });\nconst expr2 = parse('(A * B)^2');\nconst simplified2 = expr2.simplify();\n// Result: (A*B)^2\n"
      }
    },
    {
      "title": "Rational Arithmetic",
      "explanation": "Exact rational computation with arbitrary precision",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet expr = expr!(1/3 + 1/6);  // Rational arithmetic\nlet simplified = expr.simplify();\n// Result: 1/2 (exact rational, not 0.5)\n\n// Arbitrary precision\nlet expr = expr!(1/999999999 + 1/999999999);\nlet simplified = expr.simplify();\n// Result: 2/999999999 (exact, no overflow)\n",
        "python": "from mathhook import expr as parse_expr\n\nexpr = parse_expr('1/3 + 1/6')\nsimplified = expr.simplify()\n# Result: 1/2 (exact rational)\n\n# Arbitrary precision\nexpr = parse_expr('1/999999999 + 1/999999999')\nsimplified = expr.simplify()\n# Result: 2/999999999 (exact)\n",
        "nodejs": "import { parse } from 'mathhook';\n\nconst expr = parse('1/3 + 1/6');\nconst simplified = expr.simplify();\n// Result: 1/2 (exact rational)\n\n// Arbitrary precision\nconst expr2 = parse('1/999999999 + 1/999999999');\nconst simplified2 = expr2.simplify();\n// Result: 2/999999999 (exact)\n"
      }
    }
  ],
  "article": {
    "content": "# Symbolic Simplification\n\n## Overview\n\nMathHook's simplification system transforms expressions to canonical form through:\n- **Arithmetic Simplification**: Collect like terms, flatten operations, remove identities\n- **Power Rule**: Combine like powers ($x^a \\cdot x^b \\rightarrow x^{a+b}$)\n- **Noncommutative Algebra**: Preserve order for matrices, operators, quaternions\n- **Rational Arithmetic**: Exact computation with arbitrary precision\n\n## Capabilities\n\n### Arithmetic Operations\n- **Addition**: Collects like terms, flattens nested sums, removes 0\n- **Multiplication**: Combines factors, flattens products, removes 1, applies power rule\n- **Power**: Simplifies exponents, distributes when safe (commutative only)\n\n### Noncommutative Algebra\n- **Matrices**: Preserves order ($AB \\neq BA$)\n- **Operators**: Quantum mechanics commutators $[x,p] = xp - px$\n- **Quaternions**: $ij = k$ but $ji = -k$\n\n### Numerical Stability\n- **Checked arithmetic**: Integer operations use checked_mul, checked_add\n- **BigInt promotion**: Automatic on overflow\n- **Iterative flattening**: Avoids stack overflow for deeply nested expressions\n\n## Performance\n\n### Targets\n- **Simplification time**: <1ms for expressions with <100 nodes\n- **Memory**: Minimal allocations through iterative flattening\n- **Cache efficiency**: 32-byte expression size (2 per cache line)\n\n### Optimization Strategies\n- **Iterative flattening**: Avoids recursion stack overflow\n- **Early exit**: Returns immediately for identity elements\n- **Power combining**: O(n) grouping of like powers\n"
  },
  "use_cases": [
    "Simplifying intermediate results in symbolic computation",
    "Cleaning up expressions before presentation or LaTeX output",
    "Detecting equivalent expressions through canonical forms",
    "Educational tools: show step-by-step simplification",
    "Pattern matching: simplified forms enable better recognition"
  ],
  "related_topics": [
    "api.core.expressions",
    "api.operations.expansion_factoring",
    "api.operations.substitution",
    "api.advanced.noncommutative_algebra"
  ],
  "performance": {
    "complexity": "O(n) for n-node expression tree",
    "typical_time": "10-100Î¼s for <10 nodes, <1ms for <100 nodes"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}