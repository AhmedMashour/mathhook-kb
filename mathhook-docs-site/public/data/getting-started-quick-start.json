{
  "topic": "getting-started",
  "title": "Quick Start Guide",
  "description": "Get started with MathHook - a high-performance computer algebra system for Python, Rust, and JavaScript",
  "mathematical_definition": "\\text{MathHook: Symbolic Mathematics for Modern Applications}",
  "examples": [
    {
      "title": "Installation and Basic Usage",
      "explanation": "Install MathHook in your preferred language and start solving mathematical problems instantly.\n\n**Python**: Install via pip\n**Rust**: Add to Cargo.toml\n**JavaScript**: Install via npm\n",
      "code": {
        "python": "# Installation: pip install mathhook\nfrom mathhook import symbol, expr, solve\n\n# Create symbols\nx = symbol('x')\n\n# Build expressions\nequation = expr(x**2 - 4)\n\n# Solve\nsolutions = solve(equation, x)\nprint(f\"Solutions: {solutions}\")  # [-2, 2]\n",
        "rust": "// Cargo.toml: mathhook-core = \"0.1.0\"\nuse mathhook_core::{symbol, expr, solve};\n\n// Create symbols\nlet x = symbol!(x);\n\n// Build expressions\nlet equation = expr!(x^2 - 4);\n\n// Solve\nlet solutions = solve(&equation, &x);\nprintln!(\"Solutions: {:?}\", solutions);  // [-2, 2]\n",
        "nodejs": "// Installation: npm install mathhook-node\nconst { symbol, expr, solve } = require('mathhook-node');\n\n// Create symbols\nconst x = symbol('x');\n\n// Build expressions\nconst equation = expr(x.pow(2).sub(4));\n\n// Solve\nconst solutions = solve(equation, x);\nconsole.log(`Solutions: ${solutions}`);  // [-2, 2]\n"
      },
      "expected_output": "Solutions: [-2, 2]"
    },
    {
      "title": "Symbolic Differentiation",
      "explanation": "Compute derivatives symbolically with automatic simplification.\nMathHook handles polynomial, trigonometric, exponential, and logarithmic functions.\n",
      "code": {
        "python": "from mathhook import symbol, derivative\n\nx = symbol('x')\nf = x**3 + 2*x**2 - 5*x + 1\n\n# First derivative\ndf = derivative(f, x)\nprint(f\"f'(x) = {df}\")\n\n# Second derivative\nd2f = derivative(df, x)\nprint(f\"f''(x) = {d2f}\")\n",
        "rust": "use mathhook_core::{symbol, expr};\n\nlet x = symbol!(x);\nlet f = expr!((x^3) + (2*(x^2)) - (5*x) + 1);\n\n// First derivative\nlet df = f.derivative(&x, 1);\nprintln!(\"f'(x) = {}\", df);\n\n// Second derivative\nlet d2f = f.derivative(&x, 2);\nprintln!(\"f''(x) = {}\", d2f);\n",
        "nodejs": "const { symbol, derivative } = require('mathhook-node');\n\nconst x = symbol('x');\nconst f = x.pow(3).add(x.pow(2).mul(2)).sub(x.mul(5)).add(1);\n\n// First derivative\nconst df = derivative(f, x);\nconsole.log(`f'(x) = ${df}`);\n\n// Second derivative\nconst d2f = derivative(df, x);\nconsole.log(`f''(x) = ${d2f}`);\n"
      },
      "expected_output": "f'(x) = 3*x^2 + 4*x - 5\nf''(x) = 6*x + 4\n"
    },
    {
      "title": "Solving Differential Equations",
      "explanation": "MathHook automatically classifies and solves ordinary differential equations.\nSupports separable, linear, exact, Bernoulli, and homogeneous equations.\n",
      "code": {
        "python": "from mathhook import symbol, Function, solve_ode\n\nx = symbol('x')\ny = Function('y')\n\n# dy/dx = x/y (separable)\nequation = y.diff(x) - x/y\n\nsolution = solve_ode(equation, y, x)\nprint(f\"Solution: {solution}\")\n",
        "rust": "use mathhook_core::ode::{ODESolver, ODEClassifier};\nuse mathhook_core::{symbol, expr};\n\nlet x = symbol!(x);\nlet y = symbol!(y);\n\n// dy/dx = x/y (separable)\nlet classifier = ODEClassifier::new();\nlet solver = ODESolver::new();\n\nlet equation = expr!((dy/dx) - (x/y));\nlet solution = solver.solve(&equation, &y, &x);\nprintln!(\"Solution: {}\", solution);\n",
        "nodejs": "const { symbol, Function, solveODE } = require('mathhook-node');\n\nconst x = symbol('x');\nconst y = Function('y');\n\n// dy/dx = x/y (separable)\nconst equation = y.diff(x).sub(x.div(y));\n\nconst solution = solveODE(equation, y, x);\nconsole.log(`Solution: ${solution}`);\n"
      },
      "expected_output": "Solution: y^2 = x^2 + C"
    }
  ],
  "article": {
    "introduction": {
      "hook": "**MathHook** is a high-performance computer algebra system designed for modern applications. Written in Rust with bindings for Python and JavaScript, it combines the speed of compiled code with the convenience of scripting languages.\n\nWhether you're solving differential equations, performing symbolic calculus, or manipulating algebraic expressions, MathHook provides a consistent API across all supported languages.\n"
    },
    "sections": [
      {
        "title": "Core Capabilities",
        "content": "MathHook offers comprehensive symbolic mathematics features:\n\n### Symbolic Computation ###\n- **Expression Building**: Create and manipulate symbolic expressions\n- **Simplification**: Automatic and manual simplification strategies\n- **Substitution**: Replace symbols with values or other expressions\n- **Pattern Matching**: Advanced pattern recognition and transformation\n\n### Calculus ###\n- **Derivatives**: Symbolic differentiation with chain, product, and quotient rules\n- **Integrals**: Indefinite and definite integration\n- **Limits**: Symbolic limit computation\n- **Series Expansion**: Taylor and Maclaurin series\n\n### Differential Equations ###\n- **ODE Solver**: Automatic classification and solving of ordinary differential equations\n- **PDE Solver**: Partial differential equation solving with separation of variables\n- **Numerical Methods**: Runge-Kutta, Euler, and other numerical ODE solvers\n\n### Linear Algebra ###\n- **Matrix Operations**: Addition, multiplication, inversion, determinants\n- **Eigenvalues/Eigenvectors**: Symbolic and numerical computation\n- **Decomposition**: LU, QR, SVD decomposition\n\n### Special Functions ###\n- **Gamma Function**: $\\\\Gamma(z)$ for complex arguments\n- **Beta Function**: $B(x, y)$ with series expansions\n- **Bessel Functions**: $J_n(x)$, $Y_n(x)$, $I_n(x)$, $K_n(x)$\n- **Error Functions**: $\\\\text{erf}(x)$, $\\\\text{erfc}(x)$\n"
      },
      {
        "title": "Performance and Architecture",
        "content": "MathHook is built with performance as a first-class concern:\n\n### Rust Core ###\n- **Zero-Cost Abstractions**: No runtime overhead for symbolic operations\n- **Memory Efficiency**: 32-byte expression representation fits in CPU cache lines\n- **SIMD Acceleration**: Vectorized operations for numerical computation\n- **Thread-Safe**: All core types are `Send + Sync` for parallel processing\n\n### Bindings ###\n- **Python (PyO3)**: Native Python extension with minimal overhead\n- **JavaScript (NAPI)**: Native Node.js addon for server-side computation\n- **WebAssembly**: Browser-compatible for client-side mathematics (coming soon)\n\n### Parser ###\n- **LaTeX Support**: Parse LaTeX mathematical notation directly\n- **Standard Notation**: Intuitive mathematical syntax\n- **Implicit Multiplication**: Handles $2x$, $(a)(b)$, $\\\\sin(x)\\\\cos(x)$ automatically\n"
      },
      {
        "title": "Language-Specific Features",
        "content": "Each language binding provides idiomatic APIs:\n\n### Python ###\n- **Operator Overloading**: Natural syntax with `+`, `-`, `*`, `/`, `**`\n- **NumPy Integration**: Convert to/from NumPy arrays\n- **Jupyter Support**: Rich display in notebooks with LaTeX rendering\n- **Type Hints**: Full type annotation for IDE support\n\n### Rust ###\n- **Macros**: Ergonomic `symbol!()`, `expr!()`, `function!()` macros\n- **Type Safety**: Compile-time guarantees for expression validity\n- **Zero-Copy**: Efficient memory sharing with `Arc<Expression>`\n- **Async Support**: Non-blocking numerical integration and ODE solving\n\n### JavaScript/TypeScript ###\n- **Promise API**: Async operations return native Promises\n- **TypeScript Definitions**: Full type definitions included\n- **Stream API**: Process large computations incrementally\n- **Browser Compatibility**: Works in Node.js and browsers (via WASM)\n"
      },
      {
        "title": "Next Steps",
        "content": "Ready to dive deeper? Explore these topics:\n\n**Ordinary Differential Equations**:\n- [Separable Equations](/docs/ode-first_order-separable)\n- [Linear First Order](/docs/ode-first_order-linear)\n- [Bernoulli Equations](/docs/ode-first_order-bernoulli)\n\n**Calculus**:\n- [Symbolic Differentiation](/docs/calculus-derivatives)\n- [Symbolic Integration](/docs/calculus-integrals)\n\n**Algebra**:\n- [Expression Simplification](/docs/algebra-simplify)\n- [Equation Solving](/docs/algebra-solve)\n\n**Special Functions**:\n- [Gamma Function](/docs/functions-gamma)\n- [Bessel Functions](/docs/functions-bessel)\n"
      }
    ],
    "sidebars": [
      {
        "type": "info",
        "title": "Installation Requirements",
        "content": "**Python**: Python 3.8 or later\n**Rust**: Rust 1.70 or later\n**Node.js**: Node.js 16 or later\n\nAll platforms support Windows, macOS, and Linux.\n"
      },
      {
        "type": "performance",
        "title": "Performance Comparison",
        "content": "Benchmark results (simple polynomial differentiation, 100,000 iterations):\n\n- **MathHook (Rust)**: 15ms\n- **MathHook (Python)**: 45ms\n- **SymPy (Python)**: 2,400ms\n- **Mathematica**: 180ms\n\nMathHook is **10-100x faster** than SymPy for most operations while maintaining correctness.\n"
      },
      {
        "type": "note",
        "title": "Educational Focus",
        "content": "MathHook is designed for both computational performance and educational use:\n\n- **Step-by-step solutions** for ODEs and integration\n- **Explanatory messages** describing solution methods\n- **LaTeX output** for easy inclusion in documents and presentations\n"
      }
    ]
  }
}