{
  "topic": "api.matrix.operations",
  "title": "Matrix Operations and Noncommutative Algebra",
  "description": "Symbolic and numeric matrix operations with full support for noncommutative algebra.\nMatrix symbols preserve multiplication order (AB ≠ BA), enabling correct handling of\nlinear algebra, quantum mechanics operators, and transformation matrices.\n",
  "code_refs": {
    "rust": "mathhook_core::expression::Expression::matrix",
    "python": "mathhook.Matrix",
    "nodejs": "mathhook.Matrix"
  },
  "examples": [
    {
      "title": "Creating Matrix Symbols",
      "explanation": "Matrix symbols are noncommutative - order matters",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Matrix symbols (noncommutative)\nlet A = symbol!(A; matrix);\nlet B = symbol!(B; matrix);\nlet X = symbol!(X; matrix);\n\n// Matrix multiplication - ORDER MATTERS!\nlet product_ab = expr!(A * B);  // A*B\nlet product_ba = expr!(B * A);  // B*A ≠ A*B in general!\n\n// Matrix equation: A*X = B\nlet equation = expr!(A * X);\n",
        "python": "from mathhook import symbol\n\n# Matrix symbols (noncommutative)\nA = symbol('A', matrix=True)\nB = symbol('B', matrix=True)\nX = symbol('X', matrix=True)\n\n# Matrix multiplication - ORDER MATTERS!\nproduct_ab = A * B  # A*B\nproduct_ba = B * A  # B*A ≠ A*B\n\n# Matrix equation\nequation = A * X\n",
        "nodejs": "import { symbol, parse } from 'mathhook';\n\n// Matrix symbols (noncommutative)\nconst A = symbol('A', { type: 'matrix' });\nconst B = symbol('B', { type: 'matrix' });\nconst X = symbol('X', { type: 'matrix' });\n\n// Matrix multiplication - ORDER MATTERS!\nconst product_ab = parse('A * B');  // A*B\nconst product_ba = parse('B * A');  // B*A ≠ A*B\n"
      }
    },
    {
      "title": "Creating Numeric Matrices",
      "explanation": "Build matrices from expression arrays",
      "code": {
        "rust": "use mathhook::prelude::*;\nuse mathhook::Expression;\n\nlet x = symbol!(x);\n\n// 2×2 matrix with symbolic entries\nlet matrix = Expression::matrix(vec![\n    vec![expr!(x), expr!(1)],\n    vec![expr!(0), expr!(x)],\n]);\n\n// 3×3 identity matrix\nlet identity = Expression::identity_matrix(3);\n\n// Zero matrix (2 rows, 3 columns)\nlet zero = Expression::zero_matrix(2, 3);\n",
        "python": "from mathhook import Matrix, symbol\n\nx = symbol('x')\n\n# 2×2 matrix with symbolic entries\nmatrix = Matrix([\n    [x, 1],\n    [0, x]\n])\n\n# 3×3 identity matrix\nidentity = Matrix.identity(3)\n\n# Zero matrix\nzero = Matrix.zero(2, 3)\n",
        "nodejs": "import { Matrix, symbol } from 'mathhook';\n\nconst x = symbol('x');\n\n// 2×2 matrix with symbolic entries\nconst matrix = new Matrix([\n    [x, 1],\n    [0, x]\n]);\n\n// 3×3 identity matrix\nconst identity = Matrix.identity(3);\n\n// Zero matrix\nconst zero = Matrix.zero(2, 3);\n"
      }
    },
    {
      "title": "Matrix Multiplication (Critical!)",
      "explanation": "Order matters - demonstrate noncommutativity",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet A = symbol!(A; matrix);\nlet B = symbol!(B; matrix);\nlet C = symbol!(C; matrix);\n\n// Order matters!\nlet ab = expr!(A * B);  // AB\nlet ba = expr!(B * A);  // BA ≠ AB in general\n\n// Associative (but not commutative)\nlet abc_left = expr!((A * B) * C);   // (AB)C\nlet abc_right = expr!(A * (B * C));  // A(BC)\n// (AB)C = A(BC) always\n\n// Mixed scalar-matrix\nlet x = symbol!(x);\nlet xAB = expr!(x * A * B);  // x(AB) = (xA)B = A(xB)\n",
        "python": "from mathhook import symbol\n\nA = symbol('A', matrix=True)\nB = symbol('B', matrix=True)\nC = symbol('C', matrix=True)\n\n# Order matters!\nab = A * B  # AB\nba = B * A  # BA ≠ AB\n\n# Associative\nabc_left = (A * B) * C   # (AB)C\nabc_right = A * (B * C)  # A(BC)\n# These are equal\n\n# Mixed scalar-matrix\nx = symbol('x')\nxAB = x * A * B  # Scalars commute with matrices\n",
        "nodejs": "import { symbol, parse } from 'mathhook';\n\nconst A = symbol('A', { type: 'matrix' });\nconst B = symbol('B', { type: 'matrix' });\nconst C = symbol('C', { type: 'matrix' });\n\n// Order matters!\nconst ab = parse('A * B');  // AB\nconst ba = parse('B * A');  // BA ≠ AB\n\n// Associative\nconst abc_left = parse('(A * B) * C');\nconst abc_right = parse('A * (B * C)');\n// Equal\n"
      }
    },
    {
      "title": "Left Division vs Right Division",
      "explanation": "Solving matrix equations correctly",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet A = symbol!(A; matrix);\nlet X = symbol!(X; matrix);\nlet B = symbol!(B; matrix);\n\n// Left division: A*X = B → X = A⁻¹*B\nlet left_eq = expr!(A * X - B);\nlet mut solver = MatrixEquationSolver::new();\nlet solution_left = solver.solve(&left_eq, &X);\n// Result: X = A⁻¹*B\n\n// Right division: X*A = B → X = B*A⁻¹\nlet right_eq = expr!(X * A - B);\nlet solution_right = solver.solve(&right_eq, &X);\n// Result: X = B*A⁻¹\n\n// Note: A⁻¹*B ≠ B*A⁻¹ for matrices!\n",
        "python": "from mathhook import symbol, solve\n\nA = symbol('A', matrix=True)\nX = symbol('X', matrix=True)\nB = symbol('B', matrix=True)\n\n# Left division: A*X = B\nleft_eq = A*X - B\nsolution_left = solve(left_eq, X)\n# Result: X = A⁻¹*B\n\n# Right division: X*A = B\nright_eq = X*A - B\nsolution_right = solve(right_eq, X)\n# Result: X = B*A⁻¹\n",
        "nodejs": "import { symbol, parse, solve } from 'mathhook';\n\nconst A = symbol('A', { type: 'matrix' });\nconst X = symbol('X', { type: 'matrix' });\nconst B = symbol('B', { type: 'matrix' });\n\n// Left division: A*X = B\nconst left_eq = parse('A*X - B');\nconst solution_left = solve(left_eq, X);\n// Result: X = A⁻¹*B\n\n// Right division: X*A = B\nconst right_eq = parse('X*A - B');\nconst solution_right = solve(right_eq, X);\n// Result: X = B*A⁻¹\n"
      }
    },
    {
      "title": "Matrix Operations: Inverse and Determinant",
      "explanation": "Compute matrix properties",
      "code": {
        "rust": "use mathhook::prelude::*;\nuse mathhook::Expression;\n\nlet A = symbol!(A; matrix);\n\n// Symbolic inverse\nlet A_inv = expr!(A ^ (-1));  // A^(-1)\n\n// Symbolic determinant\nlet det_A = expr!(det(A));\n\n// Numeric determinant\nlet matrix = Expression::matrix(vec![\n    vec![expr!(1), expr!(2)],\n    vec![expr!(3), expr!(4)],\n]);\nlet det = expr!(det(matrix));\n// Evaluates to: 1*4 - 2*3 = -2\n",
        "python": "from mathhook import symbol, Matrix, det\n\nA = symbol('A', matrix=True)\n\n# Symbolic inverse\nA_inv = A**(-1)\n\n# Symbolic determinant\ndet_A = det(A)\n\n# Numeric determinant\nmatrix = Matrix([\n    [1, 2],\n    [3, 4]\n])\ndet_val = det(matrix)\n# Result: -2\n",
        "nodejs": "import { symbol, Matrix, parse } from 'mathhook';\n\nconst A = symbol('A', { type: 'matrix' });\n\n// Symbolic inverse\nconst A_inv = parse('A^(-1)');\n\n// Symbolic determinant\nconst det_A = parse('det(A)');\n\n// Numeric determinant\nconst matrix = new Matrix([\n    [1, 2],\n    [3, 4]\n]);\nconst det_val = matrix.det();\n// Result: -2\n"
      }
    },
    {
      "title": "Real-World Application: Quantum Mechanics",
      "explanation": "Pauli matrices and commutation relations",
      "code": {
        "rust": "use mathhook::prelude::*;\nuse mathhook::Expression;\n\n// Pauli matrices\nlet sigma_x = Expression::matrix(vec![\n    vec![expr!(0), expr!(1)],\n    vec![expr!(1), expr!(0)],\n]);\n\nlet i = Expression::i();  // Imaginary unit\n\nlet sigma_y = Expression::matrix(vec![\n    vec![expr!(0), expr!(-i)],\n    vec![i, expr!(0)],\n]);\n\nlet sigma_z = Expression::matrix(vec![\n    vec![expr!(1), expr!(0)],\n    vec![expr!(0), expr!(-1)],\n]);\n\n// Commutation relations: [σ_x, σ_y] = 2iσ_z\nlet comm_xy = expr!((sigma_x * sigma_y) - (sigma_y * sigma_x));\nlet expected = expr!(2 * i * sigma_z);\n\n// Verify\nlet difference = expr!(comm_xy - expected);\nlet simplified = difference.simplify();\n// Should equal zero matrix\n",
        "python": "from mathhook import Matrix, I\n\n# Pauli matrices\nsigma_x = Matrix([[0, 1], [1, 0]])\nsigma_y = Matrix([[0, -I], [I, 0]])\nsigma_z = Matrix([[1, 0], [0, -1]])\n\n# Commutation: [σ_x, σ_y] = 2iσ_z\ncomm_xy = sigma_x*sigma_y - sigma_y*sigma_x\nexpected = 2*I*sigma_z\n\n# Verify\nassert (comm_xy - expected).simplify() == Matrix.zero(2, 2)\n",
        "nodejs": "import { Matrix, I } from 'mathhook';\n\n// Pauli matrices\nconst sigma_x = new Matrix([[0, 1], [1, 0]]);\nconst sigma_y = new Matrix([[0, -I], [I, 0]]);\nconst sigma_z = new Matrix([[1, 0], [0, -1]]);\n\n// Commutation: [σ_x, σ_y] = 2iσ_z\nconst comm_xy = sigma_x.mul(sigma_y).sub(sigma_y.mul(sigma_x));\nconst expected = sigma_z.mul(2*I);\n"
      }
    }
  ],
  "article": {
    "content": "# Matrix Operations\n\n## Overview\n\nMathHook provides comprehensive matrix support with:\n- **Noncommutative multiplication**: Order preserved ($AB \\neq BA$)\n- **Matrix symbols**: Distinguished from scalar symbols\n- **Left/Right division**: Correct handling for matrix equations\n- **Special matrices**: Identity, zero, diagonal\n- **LaTeX rendering**: Bold notation for matrices ($\\mathbf{A}$)\n\n## Matrix Symbol Types\n\n### Creating Matrix Symbols\nUse `symbol!(name; matrix)` to create noncommutative matrix symbols:\n```rust\nlet A = symbol!(A; matrix);\nlet B = symbol!(B; matrix);\n```\n\n### Why Type Matters\n- **Noncommutative multiplication**: $AB \\neq BA$\n- **LaTeX formatting**: Rendered as $\\mathbf{A}$ (bold)\n- **Equation solving**: Left vs right division distinguished\n- **Educational messages**: Order-aware explanations\n\n## Matrix Operations\n\n### Multiplication (NONCOMMUTATIVE!)\nOrder matters for matrix multiplication:\n- $A \\times B \\neq B \\times A$ (general)\n- $(AB)C = A(BC)$ (associative)\n- Dimension compatibility: $A_{m \\times n} \\cdot B_{n \\times p} = C_{m \\times p}$\n\n### Addition/Subtraction (Commutative)\nElement-wise operations:\n- $A + B = B + A$ (commutative)\n- Must have same dimensions\n\n### Matrix Equations\n**Left Division**: $AX = B \\Rightarrow X = A^{-1}B$\n**Right Division**: $XA = B \\Rightarrow X = BA^{-1}$\n\n**Important**: $A^{-1}B \\neq BA^{-1}$ in general!\n\n## Mathematical Background\n\n### Matrix Multiplication\nFor $A_{m \\times n}$ and $B_{n \\times p}$:\n$$C_{ij} = \\sum_{k=1}^{n} A_{ik} B_{kj}$$\n\n### Matrix Inverse\nFor square matrix $A$, if $A^{-1}$ exists:\n$$A \\times A^{-1} = A^{-1} \\times A = I$$\n\n### Determinant (2×2)\n$$\\det\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix} = ad - bc$$\n"
  },
  "use_cases": [
    "Linear systems: Solve Ax = b for vector x",
    "Transformations: Rotations, scaling, projections in graphics",
    "Quantum mechanics: Operators represented as matrices",
    "Network analysis: Adjacency matrices for graphs",
    "Economics: Input-output models",
    "Statistics: Covariance matrices, regression"
  ],
  "related_topics": [
    "api.advanced.noncommutative_algebra",
    "api.advanced.system_solving",
    "api.solver.equations",
    "api.parser.latex"
  ],
  "performance": {},
  "metadata": {
    "schema_version": "1.0"
  }
}