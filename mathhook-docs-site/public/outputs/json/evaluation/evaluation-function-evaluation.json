{
  "topic": "evaluation.function-evaluation",
  "title": "Function Evaluation",
  "description": "MathHook provides a unified, intelligent function evaluation system that handles both symbolic\nand numerical computation. The system uses the Universal Function Registry architecture to\ndispatch function calls to specialized implementations while maintaining mathematical correctness.\n",
  "code_refs": {
    "rust": "mathhook_core::functions::evaluation",
    "python": "mathhook.functions.evaluation",
    "nodejs": "mathhook.functions.evaluation"
  },
  "examples": [
    {
      "title": "Elementary Functions",
      "explanation": "Evaluating basic trigonometric and exponential functions",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\nlet sin_x = expr!(sin(x));\nlet cos_x = expr!(cos(x));\nlet exp_x = expr!(exp(x));\nlet log_x = expr!(log(x));\n",
        "python": "from mathhook import symbol, expr\n\nx = symbol('x')\n\nsin_x = expr('sin(x)')\ncos_x = expr('cos(x)')\nexp_x = expr('exp(x)')\nlog_x = expr('log(x)')\n",
        "nodejs": "const { symbol, expr } = require('mathhook');\n\nconst x = symbol('x');\n\nconst sinX = expr('sin(x)');\nconst cosX = expr('cos(x)');\nconst expX = expr('exp(x)');\nconst logX = expr('log(x)');\n"
      }
    },
    {
      "title": "Special Value Evaluation",
      "explanation": "Automatic simplification of known exact values",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Trigonometric special values\nlet sin_0 = expr!(sin(0));\nassert_eq!(sin_0.simplify(), expr!(0));\n\nlet cos_0 = expr!(cos(0));\nassert_eq!(cos_0.simplify(), expr!(1));\n\n// Exponential and logarithmic\nlet exp_0 = expr!(exp(0));\nassert_eq!(exp_0.simplify(), expr!(1));\n\nlet log_1 = expr!(log(1));\nassert_eq!(log_1.simplify(), expr!(0));\n",
        "python": "from mathhook import expr\n\n# Trigonometric special values\nsin_0 = expr('sin(0)')\nassert sin_0.simplify() == expr('0')\n\ncos_0 = expr('cos(0)')\nassert cos_0.simplify() == expr('1')\n\n# Exponential and logarithmic\nexp_0 = expr('exp(0)')\nassert exp_0.simplify() == expr('1')\n\nlog_1 = expr('log(1)')\nassert log_1.simplify() == expr('0')\n",
        "nodejs": "const { expr } = require('mathhook');\n\n// Trigonometric special values\nconst sin0 = expr('sin(0)');\nconsole.assert(sin0.simplify().equals(expr('0')));\n\nconst cos0 = expr('cos(0)');\nconsole.assert(cos0.simplify().equals(expr('1')));\n\n// Exponential and logarithmic\nconst exp0 = expr('exp(0)');\nconsole.assert(exp0.simplify().equals(expr('1')));\n\nconst log1 = expr('log(1)');\nconsole.assert(log1.simplify().equals(expr('0')));\n"
      }
    },
    {
      "title": "Composite Expression Evaluation",
      "explanation": "Mixed symbolic and numeric evaluation",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet y = symbol!(y);\n\n// sqrt(4) evaluates to 2, symbolic parts preserved\nlet composite = expr!((sin((x^2) + 1) * cos(y)) - sqrt(4));\nlet result = composite.simplify();\n// Result: sin(x^2 + 1) * cos(y) - 2\n",
        "python": "from mathhook import symbol, expr\n\nx = symbol('x')\ny = symbol('y')\n\n# sqrt(4) evaluates to 2, symbolic parts preserved\ncomposite = expr('sin(x^2 + 1) * cos(y) - sqrt(4)')\nresult = composite.simplify()\n# Result: sin(x^2 + 1) * cos(y) - 2\n",
        "nodejs": "const { symbol, expr } = require('mathhook');\n\nconst x = symbol('x');\nconst y = symbol('y');\n\n// sqrt(4) evaluates to 2, symbolic parts preserved\nconst composite = expr('sin(x^2 + 1) * cos(y) - sqrt(4)');\nconst result = composite.simplify();\n// Result: sin(x^2 + 1) * cos(y) - 2\n"
      }
    },
    {
      "title": "Function Composition",
      "explanation": "Nested and composed functions",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// sin(cos(x))\nlet nested = expr!(sin(cos(x)));\n\n// exp(log(x)) simplifies to x\nlet exp_log = expr!(exp(log(x)));\nlet simplified = exp_log.simplify();\n// Result: x (identity simplification)\n",
        "python": "from mathhook import symbol, expr\n\nx = symbol('x')\n\n# sin(cos(x))\nnested = expr('sin(cos(x))')\n\n# exp(log(x)) simplifies to x\nexp_log = expr('exp(log(x))')\nsimplified = exp_log.simplify()\n# Result: x\n",
        "nodejs": "const { symbol, expr } = require('mathhook');\n\nconst x = symbol('x');\n\n// sin(cos(x))\nconst nested = expr('sin(cos(x))');\n\n// exp(log(x)) simplifies to x\nconst expLog = expr('exp(log(x))');\nconst simplified = expLog.simplify();\n// Result: x\n"
      }
    },
    {
      "title": "Bulk Evaluation",
      "explanation": "Efficient numerical evaluation over multiple points",
      "code": {
        "rust": "use mathhook::functions::FunctionEvaluator;\n\nlet evaluator = FunctionEvaluator::new();\nlet points = vec![0.0, 0.5, 1.0, 1.5, 2.0];\n\n// SIMD-optimized evaluation\nif let Some(results) = evaluator.evaluate_bulk_f64(\"sin\", &points) {\n    println!(\"Results: {:?}\", results);\n}\n",
        "python": "from mathhook.functions import FunctionEvaluator\n\nevaluator = FunctionEvaluator()\npoints = [0.0, 0.5, 1.0, 1.5, 2.0]\n\n# SIMD-optimized evaluation\nresults = evaluator.evaluate_bulk('sin', points)\nprint(f\"Results: {results}\")\n",
        "nodejs": "const { FunctionEvaluator } = require('mathhook/functions');\n\nconst evaluator = new FunctionEvaluator();\nconst points = [0.0, 0.5, 1.0, 1.5, 2.0];\n\n// SIMD-optimized evaluation\nconst results = evaluator.evaluateBulk('sin', points);\nconsole.log(`Results: ${results}`);\n"
      }
    }
  ],
  "article": {
    "content": "# Function Evaluation\n\nMathHook provides a unified, intelligent function evaluation system that handles both symbolic and numerical computation. The system uses the **Universal Function Registry** architecture to dispatch function calls to specialized implementations while maintaining mathematical correctness.\n\n## Overview\n\nFunction evaluation in MathHook supports:\n\n- **Elementary functions**: sin, cos, tan, exp, log, sqrt, abs, and their inverses\n- **Hyperbolic functions**: sinh, cosh, tanh, and their inverses\n- **Special functions**: gamma, zeta, bessel functions\n- **Number theory functions**: factorial, binomial coefficients\n- **Symbolic evaluation**: Returns exact symbolic results when possible\n- **Numerical evaluation**: High-performance numerical approximations\n- **Special value recognition**: Automatically simplifies known exact values\n\n## Evaluation Architecture\n\n### Function Intelligence System\n\nEvery function in MathHook has associated **intelligence properties** that define:\n\n1. **Domain and Range**: Where the function is defined and what values it can produce\n2. **Special Values**: Known exact values (e.g., sin(0) = 0, gamma(1) = 1)\n3. **Evaluation Strategy**: How to compute the function symbolically and numerically\n4. **Mathematical Properties**: Symmetry, periodicity, derivative rules, etc.\n\n### Evaluation Flow\n\n```\nUser Expression\n      ↓\nFunction Name + Arguments\n      ↓\nUniversal Registry Lookup\n      ↓\nFunction Properties Dispatch\n      ↓\n┌─────────────────┬──────────────────┐\n│ Special Value?  │ Symbolic Input?  │ Numerical Input?\n│ → Exact Result  │ → Keep Symbolic  │ → Numerical Eval\n└─────────────────┴──────────────────┘\n```\n\n## Performance Characteristics\n\nThe function evaluation system is designed for high performance:\n\n- **Registry lookup**: O(1) constant time using hash maps\n- **Special value detection**: <50ns for known values\n- **Numerical evaluation**: <100ns for elementary functions\n- **Total dispatch overhead**: <10ns\n- **Bulk evaluation**: SIMD-optimized for arrays of values\n\n## Mathematical Correctness Guarantees\n\nMathHook's function evaluation system provides:\n\n1. **Exact symbolic computation**: Special values return exact results (not floating-point approximations)\n2. **Domain checking**: Functions respect their mathematical domains (e.g., log requires positive inputs)\n3. **SymPy validation**: All implementations validated against SymPy reference\n4. **Numerical stability**: Algorithms chosen for numerical accuracy\n"
  },
  "use_cases": [
    "Symbolic mathematics computation",
    "Numerical function evaluation",
    "Special value recognition and simplification",
    "Composite expression evaluation",
    "High-performance bulk evaluation"
  ],
  "related_topics": [
    "architecture.function-intelligence",
    "advanced.special-functions",
    "performance.benchmarking",
    "calculus.derivatives",
    "simplification.algebraic"
  ],
  "performance": {},
  "metadata": {
    "schema_version": "1.0",
    "last_updated": "2025-12-15"
  }
}