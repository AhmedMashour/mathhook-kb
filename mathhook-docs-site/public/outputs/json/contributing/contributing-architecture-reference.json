{
  "topic": "contributing.architecture-reference",
  "title": "Quick Reference for Core Math Functions",
  "description": "Module structure patterns, implementation checklists, and templates for implementing\nmath functions in MathHook. Covers elementary functions, special functions, and\nnumber theory operations.\n",
  "article": {
    "content": "# Quick Reference for Core Math Functions\n\n## Module Structure Pattern\n\n```\nsrc/core/functions/FUNCNAME/\n├── mod.rs       # Main implementation with evaluate(), properties(), simplify()\n├── data.rs      # Special values HashMap (LazyLock<SpecialValuesMap>)\n└── tests.rs     # Unit tests\n```\n\n## Implementation Checklist (Per Function)\n\n- [ ] Create module directory: `src/core/functions/FUNCNAME/`\n- [ ] Implement `mod.rs` with:\n  - [ ] `pub fn FUNCNAME(arg: &Expression) -> Result<Expression, MathError>`\n  - [ ] Special value lookups from data.rs\n  - [ ] Computed special values (general patterns)\n  - [ ] Mathematical identities (symmetry, periodicity)\n  - [ ] Numerical evaluation\n  - [ ] Symbolic return for unevaluated forms\n- [ ] Create `data.rs` with:\n  - [ ] `pub static FUNCNAME_SPECIAL_VALUES: LazyLock<SpecialValuesMap>`\n  - [ ] Exact values with LaTeX explanations\n  - [ ] Undefined/error cases (poles, domain violations)\n- [ ] Migrate/create `tests.rs`:\n  - [ ] Test all special values\n  - [ ] Test domain boundaries\n  - [ ] Test mathematical properties (symmetry, periodicity, identities)\n  - [ ] Test numerical evaluation\n  - [ ] Test error cases\n- [ ] Register in UniversalFunctionRegistry (if needed)\n- [ ] Test: `cargo test -p mathhook-core functions::FUNCNAME`\n- [ ] Verify no regressions: `cargo test`\n\n## Pattern Templates\n\n### data.rs Template (Elementary Functions)\n\n```rust\n# extern crate mathhook_book;\n# use mathhook_book::mathhook;\n# use mathhook::prelude::*;\n//! Special values for FUNCNAME function\n\nuse crate::core::Expression;\nuse std::sync::LazyLock;\nuse std::collections::HashMap;\n\npub type SpecialValuesMap = HashMap<Expression, SpecialValueResult>;\n\npub enum SpecialValueResult {\n    Exact {\n        output: Expression,\n        latex: String,\n    },\n    Error {\n        error: MathError,\n        latex: String,\n    },\n}\n\npub static FUNCNAME_SPECIAL_VALUES: LazyLock<SpecialValuesMap> = LazyLock::new(|| {\n    let mut map = SpecialValuesMap::new();\n\n    // Exact zero\n    map.insert(\n        Expression::integer(0),\n        SpecialValueResult::Exact {\n            output: Expression::integer(0),\n            latex: \"\\\\FUNCNAME(0) = 0\".to_string(),\n        },\n    );\n\n    // Common special values\n    // ...\n\n    // Undefined cases (poles)\n    map.insert(\n        Expression::div(Expression::pi(), Expression::integer(2)),\n        SpecialValueResult::Error {\n            error: MathError::Undefined {\n                expression: Expression::function(\"FUNCNAME\", vec![\n                    Expression::div(Expression::pi(), Expression::integer(2))\n                ]),\n            },\n            latex: \"\\\\FUNCNAME(\\\\frac{\\\\pi}{2}) = \\\\text{undefined}\".to_string(),\n        },\n    );\n\n    map\n});\n```\n\n### mod.rs Template (Elementary Functions)\n\n```rust\n# extern crate mathhook_book;\n# use mathhook_book::mathhook;\n# use mathhook::prelude::*;\n//! FUNCNAME function implementation\n//!\n//! Provides exact symbolic evaluation, special values, and numerical computation.\n\nuse crate::core::Expression;\nuse crate::error::MathError;\n\nmod data;\nuse data::{FUNCNAME_SPECIAL_VALUES, SpecialValueResult};\n\n#[cfg(test)]\nmod tests;\n\n/// Evaluate FUNCNAME function\n///\n/// # Arguments\n///\n/// * `arg` - The input expression\n///\n/// # Returns\n///\n/// * `Ok(Expression)` - The evaluated result\n/// * `Err(MathError)` - Domain error or undefined\n///\n/// # Examples\n///\n/// ```rust\n/// use mathhook::functions::elementary::FUNCNAME::FUNCNAME;\n/// use mathhook::{expr, symbol};\n///\n/// let x = symbol!(x);\n/// let result = FUNCNAME(&expr!(0)).unwrap();\n/// assert_eq!(result, expr!(0));\n/// ```\npub fn FUNCNAME(arg: &Expression) -> Result<Expression, MathError> {\n    // 1. Check shared special values (exact or error)\n    if let Some(result) = FUNCNAME_SPECIAL_VALUES.get(arg) {\n        match result {\n            SpecialValueResult::Exact { output, .. } => return Ok(output.clone()),\n            SpecialValueResult::Error { error, .. } => return Err(error.clone()),\n        }\n    }\n\n    // 2. Computed special values (general patterns)\n    // Example: For trig functions, handle multiples of π\n    // if let Some(pi_mult) = arg.as_pi_multiple() {\n    //     return Ok(eval_FUNCNAME_at_pi_multiple(&pi_mult));\n    // }\n\n    // 3. Mathematical identities\n    // Example: sin(-x) = -sin(x) (odd function)\n    // if let Some(neg_arg) = arg.as_negation() {\n    //     return FUNCNAME(&neg_arg).map(|result| Expression::neg(result));\n    // }\n\n    // 4. Numerical evaluation\n    if let Some(val) = arg.try_to_f64() {\n        return Ok(Expression::float(val.FUNCNAME()));  // Use appropriate std method\n    }\n\n    // 5. Unevaluated (symbolic)\n    Ok(Expression::function(\"FUNCNAME\", vec![arg.clone()]))\n}\n\n/// Dispatcher for registry integration\npub(crate) fn FUNCNAME_dispatch(args: &[Expression]) -> Result<Expression, MathError> {\n    if args.len() != 1 {\n        return Err(MathError::InvalidArgumentCount {\n            expected: 1,\n            got: args.len(),\n        });\n    }\n    FUNCNAME(&args[0])\n}\n```\n\n### tests.rs Template\n\n```rust\n# extern crate mathhook_book;\n# use mathhook_book::mathhook;\n# use mathhook::prelude::*;\n//! Tests for FUNCNAME function\n\nuse super::*;\nuse crate::{expr, symbol};\n\n#[test]\nfn test_FUNCNAME_special_values() {\n    // Test exact zero\n    assert_eq!(FUNCNAME(&expr!(0)).unwrap(), expr!(0));\n\n    // Test other special values\n    // ...\n}\n\n#[test]\nfn test_FUNCNAME_domain_errors() {\n    // Test undefined cases (poles)\n    let result = FUNCNAME(&expr!(pi / 2));\n    assert!(result.is_err());\n    if let Err(MathError::Undefined { .. }) = result {\n        // Expected\n    } else {\n        panic!(\"Expected Undefined error\");\n    }\n}\n\n#[test]\nfn test_FUNCNAME_identities() {\n    let x = symbol!(x);\n\n    // Test symmetry (odd/even function)\n    // Example: sin(-x) = -sin(x)\n    // let neg_x = expr!(-x);\n    // assert_eq!(FUNCNAME(&neg_x), expr!(- FUNCNAME(x)));\n\n    // Test periodicity\n    // Example: sin(x + 2π) = sin(x)\n}\n\n#[test]\nfn test_FUNCNAME_numerical() {\n    // Test numerical evaluation\n    use std::f64::consts::PI;\n\n    let result = FUNCNAME(&Expression::float(0.0)).unwrap();\n    assert!((result.try_to_f64().unwrap() - 0.0).abs() < 1e-10);\n\n    // More numerical tests...\n}\n\n#[test]\nfn test_FUNCNAME_symbolic() {\n    let x = symbol!(x);\n\n    // Unevaluated form\n    let result = FUNCNAME(&Expression::symbol(x)).unwrap();\n    assert_eq!(result, Expression::function(\"FUNCNAME\", vec![Expression::symbol(x)]));\n}\n```\n\n## Special Function Patterns (Gamma, Zeta, Bessel)\n\n### data.rs for Special Functions\n\n```rust\n# extern crate mathhook_book;\n# use mathhook_book::mathhook;\n# use mathhook::prelude::*;\npub static GAMMA_SPECIAL_VALUES: LazyLock<SpecialValuesMap> = LazyLock::new(|| {\n    let mut map = SpecialValuesMap::new();\n\n    // Integer values: Γ(n) = (n-1)!\n    map.insert(expr!(1), special_value!(1, \"\\\\Gamma(1) = 1\"));\n    map.insert(expr!(2), special_value!(1, \"\\\\Gamma(2) = 1\"));\n    map.insert(expr!(3), special_value!(2, \"\\\\Gamma(3) = 2\"));\n    map.insert(expr!(4), special_value!(6, \"\\\\Gamma(4) = 6\"));\n\n    // Half-integer values: Γ(1/2) = √π\n    map.insert(expr!(1/2), special_value!(sqrt(pi), \"\\\\Gamma(\\\\frac{1}{2}) = \\\\sqrt{\\\\pi}\"));\n\n    // Poles (undefined at non-positive integers)\n    map.insert_undefined(expr!(0), \"\\\\Gamma(0) = \\\\text{undefined}\");\n    map.insert_undefined(expr!(-1), \"\\\\Gamma(-1) = \\\\text{undefined}\");\n\n    map\n});\n```\n\n### Computed Special Values Pattern\n\n```rust\n# extern crate mathhook_book;\n# use mathhook_book::mathhook;\n# use mathhook::prelude::*;\n// For gamma: Handle general factorial cases\nif let Some(n) = arg.as_positive_integer() {\n    if n > 0 && n <= 20 {  // Precompute up to reasonable limit\n        return Ok(Expression::integer(factorial(n - 1)));\n    }\n}\n\n// For zeta: Handle general even integer cases\nif let Some(n) = arg.as_even_positive_integer() {\n    // Use Bernoulli numbers formula\n    return Ok(compute_zeta_even_integer(n));\n}\n```\n\n## Number Theory Functions (NO HashMap - Algorithmic)\n\n```rust\n# extern crate mathhook_book;\n# use mathhook_book::mathhook;\n# use mathhook::prelude::*;\n// gcd, lcm, factor do NOT use HashMap\n// They are purely algorithmic\n\npub fn gcd(a: &Expression, b: &Expression) -> Result<Expression, MathError> {\n    // Euclidean algorithm\n    if let (Some(a_int), Some(b_int)) = (a.as_integer(), b.as_integer()) {\n        return Ok(Expression::integer(gcd_algorithm(a_int, b_int)));\n    }\n\n    // Symbolic GCD\n    Ok(Expression::function(\"gcd\", vec![a.clone(), b.clone()]))\n}\n```\n\n## Registry Integration Pattern\n\n```rust\n# extern crate mathhook_book;\n# use mathhook_book::mathhook;\n# use mathhook::prelude::*;\n// functions/registry/elementary.rs\n\nuse crate::functions::elementary::sin::{sin_dispatch, SIN_SPECIAL_VALUES};\n\npub fn get_elementary_properties() -> Vec<(String, FunctionProperties)> {\n    vec![\n        (\n            \"sin\".to_string(),\n            FunctionProperties {\n                name: \"sin\",\n                // Derived from shared data (CANNOT drift!)\n                special_values: SIN_SPECIAL_VALUES\n                    .iter()\n                    .map(|(input, result)| match result {\n                        SpecialValueResult::Exact { output, latex } => SpecialValue {\n                            input: input.to_string(),\n                            output: output.clone(),\n                            latex_explanation: latex.clone(),\n                        },\n                        SpecialValueResult::Error { .. } => SpecialValue {\n                            input: input.to_string(),\n                            output: Expression::undefined(),\n                            latex_explanation: \"undefined\".to_string(),\n                        },\n                    })\n                    .collect(),\n                dispatch: sin_dispatch,\n                domain: \"all reals\".to_string(),\n                range: \"[-1, 1]\".to_string(),\n                period: Some(Expression::mul(vec![Expression::integer(2), Expression::pi()])),\n            },\n        ),\n        // More functions...\n    ]\n}\n```\n\n## Critical Patterns\n\n### 1. Single Source of Truth\n- Special values defined ONCE in data.rs\n- Registry derives from data.rs (no duplication)\n- Implementation uses data.rs directly (no hardcoded values)\n\n### 2. Error Handling\n- Domain violations return `Err(MathError::DomainError { ... })`\n- Undefined cases (poles) use `SpecialValueResult::Error`\n- Symbolic unevaluated forms for generic expressions\n\n### 3. Mathematical Correctness\n- Exact symbolic values (use rationals, not floats)\n- Handle symmetry (odd/even functions)\n- Handle periodicity (trig functions)\n- Handle domain restrictions (log, sqrt, etc.)\n\n### 4. Testing Requirements\n- Test ALL special values from data.rs\n- Test domain boundaries and error cases\n- Test mathematical properties (identities, symmetry)\n- Test numerical evaluation accuracy\n- Test symbolic unevaluated forms\n\n## Migration Workflow\n\n### For Refactored Functions (7 functions)\n\n1. **Extract current implementation** from special.rs\n2. **Create module directory** `src/core/functions/FUNCNAME/`\n3. **Create data.rs** with special values from hardcoded matches\n4. **Migrate mod.rs** to use data.rs lookups\n5. **Migrate tests** from special.rs to tests.rs\n6. **Run tests** to verify no regressions\n7. **Update registry** (if needed)\n\n### For New Implementations (21 functions)\n\n1. **Create module directory** `src/core/functions/FUNCNAME/`\n2. **Create data.rs** with special values\n3. **Implement mod.rs** following pattern\n4. **Create tests.rs** with coverage\n5. **Register in registry** (elementary.rs, polynomials.rs, etc.)\n6. **Run tests** and verify correctness\n\n## Verification Commands\n\n```bash\n# Test individual function\ncargo test -p mathhook-core functions::FUNCNAME\n\n# Test all functions\ncargo test -p mathhook-core functions\n\n# Full test suite (no regressions)\ncargo test\n\n# Doctests\ncargo test --doc\n\n# Check Expression size (must remain 32 bytes)\ncargo test expression_size\n```\n\n## Success Criteria\n\n- ✅ All functions pass individual tests\n- ✅ All functions pass integration tests\n- ✅ No test regressions (full suite passes)\n- ✅ Expression size remains 32 bytes\n- ✅ Documentation complete with examples\n- ✅ No hardcoded special values in implementation (only in data.rs)\n- ✅ Registry correctly derives from data.rs\n"
  },
  "related_topics": [
    "contributing.development",
    "contributing.testing",
    "contributing.style",
    "contributing.correctness"
  ],
  "metadata": {
    "schema_version": "1.0"
  }
}