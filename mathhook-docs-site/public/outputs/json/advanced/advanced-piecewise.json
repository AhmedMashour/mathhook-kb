{
  "topic": "advanced.piecewise",
  "title": "Piecewise Functions",
  "description": "Define functions with different formulas in different regions, essential for\nmodeling discontinuous behavior, conditional logic, step functions, and\nthreshold-based systems.\n",
  "mathematical_definition": "Piecewise function:\n$$f(x) = \\begin{cases}\nf_1(x) & \\text{if } C_1(x) \\\\\nf_2(x) & \\text{if } C_2(x) \\\\\n\\vdots & \\\\\nf_n(x) & \\text{if } C_n(x) \\\\\nf_{\\text{default}} & \\text{otherwise}\n\\end{cases}$$\n",
  "code_refs": {
    "rust": "mathhook_core::piecewise",
    "python": "mathhook.piecewise",
    "nodejs": "mathhook.piecewise"
  },
  "examples": [
    {
      "title": "Absolute Value Function",
      "explanation": "|x| = { x if x ≥ 0, -x if x < 0 }",
      "code": {
        "rust": "let x = symbol!(x);\n\nlet abs_x = Expression::piecewise(\n    vec![\n        (expr!(x), expr!(x >= 0)),\n        (expr!(-x), expr!(x < 0)),\n    ],\n    None,\n);\n",
        "python": "from sympy import symbols, Piecewise\n\nx = symbols('x')\nabs_x = Piecewise((x, x >= 0), (-x, x < 0))\n",
        "nodejs": "const x = symbol('x');\n\nconst abs_x = piecewise([\n    [x, ge(x, 0)],\n    [neg(x), lt(x, 0)]\n]);\n"
      }
    },
    {
      "title": "Heaviside Step Function",
      "explanation": "H(x) = { 0 if x < 0, 1 if x ≥ 0 }",
      "code": {
        "rust": "let x = symbol!(x);\n\nlet heaviside = Expression::piecewise(\n    vec![\n        (expr!(0), expr!(x < 0)),\n        (expr!(1), expr!(x >= 0)),\n    ],\n    None,\n);\n",
        "python": "from sympy import symbols, Heaviside\n\nx = symbols('x')\nH = Heaviside(x)  # Built-in Heaviside function\n",
        "nodejs": "const x = symbol('x');\n\nconst H = piecewise([\n    [0, lt(x, 0)],\n    [1, ge(x, 0)]\n]);\n"
      }
    },
    {
      "title": "Tax Bracket Example",
      "explanation": "Progressive tax with income thresholds",
      "code": {
        "rust": "let income = symbol!(income);\n\n// 10% on first $10k, 12% on next $30k, 22% on remainder\nlet tax = Expression::piecewise(\n    vec![\n        (expr!(0.10 * income), expr!(income <= 10000)),\n        (expr!(1000 + 0.12 * (income - 10000)), expr!(income <= 40000)),\n    ],\n    Some(expr!(4600 + 0.22 * (income - 40000))),\n);\n\n// Calculate tax for $50,000\nlet tax_owed = tax.substitute(&income, &expr!(50000));\n// Result: 4600 + 0.22 * 10000 = $6,800\n",
        "python": "from sympy import symbols, Piecewise\n\nincome = symbols('income')\n\ntax = Piecewise(\n    (0.10 * income, income <= 10000),\n    (1000 + 0.12 * (income - 10000), income <= 40000),\n    (4600 + 0.22 * (income - 40000), True)\n)\n\ntax_owed = tax.subs(income, 50000)\n# Result: 6800\n",
        "nodejs": "const income = symbol('income');\n\nconst tax = piecewise([\n    [mul(0.10, income), le(income, 10000)],\n    [add(1000, mul(0.12, sub(income, 10000))), le(income, 40000)],\n    [add(4600, mul(0.22, sub(income, 40000))), true]\n]);\n\nconst tax_owed = tax.subs(income, 50000);\n"
      }
    },
    {
      "title": "Differentiation of Piecewise",
      "explanation": "Derivative computed piece-by-piece",
      "code": {
        "rust": "let x = symbol!(x);\n\n// f(x) = { x^2 if x ≥ 0, -x^2 if x < 0 }\nlet f = Expression::piecewise(\n    vec![\n        (expr!(x^2), expr!(x >= 0)),\n        (expr!(-x^2), expr!(x < 0)),\n    ],\n    None,\n);\n\n// Derivative\nlet df = f.derivative(&x, 1);\n// Result: { 2x if x ≥ 0, -2x if x < 0 }\n",
        "python": "from sympy import symbols, Piecewise, diff\n\nx = symbols('x')\nf = Piecewise((x**2, x >= 0), (-x**2, x < 0))\n\ndf = diff(f, x)\n# Result: Piecewise((2*x, x > 0), (-2*x, x < 0))\n",
        "nodejs": "const x = symbol('x');\n\nconst f = piecewise([\n    [pow(x, 2), ge(x, 0)],\n    [neg(pow(x, 2)), lt(x, 0)]\n]);\n\nconst df = diff(f, x);\n"
      }
    }
  ],
  "use_cases": [
    "Physics: Step functions, potential barriers",
    "Economics: Tax brackets, tiered pricing",
    "Engineering: Saturating amplifiers, clipping",
    "Signal processing: Filters, thresholding"
  ],
  "related_topics": [
    "core.functions",
    "operations.solving",
    "operations.differentiation",
    "operations.integration",
    "advanced.assumptions"
  ],
  "metadata": {
    "schema_version": "1.0"
  }
}