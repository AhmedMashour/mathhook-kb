{
  "topic": "advanced.pde.classification",
  "title": "PDE Classification",
  "description": "Mathematical classification of partial differential equations into elliptic, parabolic,\nand hyperbolic types using the discriminant formula. Different PDE types require\ncompletely different solution methods and have distinct physical interpretations.\n",
  "mathematical_definition": "For a general second-order PDE:\n$$A \\frac{\\partial^2 u}{\\partial x^2} + B \\frac{\\partial^2 u}{\\partial x \\partial y} + C \\frac{\\partial^2 u}{\\partial y^2} + \\text{lower order terms} = 0$$\n\nThe **discriminant** is:\n$$\\Delta = B^2 - 4AC$$\n\n**Classification:**\n- $\\Delta < 0$ → **Elliptic** (e.g., Laplace: $u_{xx} + u_{yy} = 0$)\n- $\\Delta = 0$ → **Parabolic** (e.g., Heat: $u_t = u_{xx}$)\n- $\\Delta > 0$ → **Hyperbolic** (e.g., Wave: $u_{tt} = c^2 u_{xx}$)\n",
  "code_refs": {
    "rust": "mathhook_core::pde::classification",
    "python": "mathhook.pde.classification",
    "nodejs": "mathhook.pde.classification"
  },
  "examples": [
    {
      "title": "Wave Equation Classification (Hyperbolic)",
      "explanation": "Wave equation has positive discriminant and is classified as hyperbolic",
      "code": {
        "rust": "let u = symbol!(u);\nlet x = symbol!(x);\nlet t = symbol!(t);\n\n// Wave equation structure\nlet equation = expr!(mul: x, t);\nlet pde = Pde::new(equation, u, vec![x, t]);\n\n// Automatic classification\nlet pde_type = pde.pde_type();\nassert_eq!(pde_type, Some(PdeType::Hyperbolic));\n\n// Discriminant computation\nlet disc = pde.compute_discriminant();\nassert!(disc > 0.0);\nassert_eq!(disc, 4.0);\n",
        "python": "u = symbol('u')\nx = symbol('x')\nt = symbol('t')\n\n# Wave equation structure\nequation = expr(mul=[x, t])\npde = Pde.new(equation, u, [x, t])\n\n# Automatic classification\npde_type = pde.pde_type()\nassert pde_type == PdeType.Hyperbolic\n\n# Discriminant computation\ndisc = pde.compute_discriminant()\nassert disc > 0.0\nassert disc == 4.0\n",
        "nodejs": "const u = symbol('u');\nconst x = symbol('x');\nconst t = symbol('t');\n\n// Wave equation structure\nconst equation = expr({ mul: [x, t] });\nconst pde = Pde.new(equation, u, [x, t]);\n\n// Automatic classification\nconst pdeType = pde.pdeType();\nassert(pdeType === PdeType.Hyperbolic);\n\n// Discriminant computation\nconst disc = pde.computeDiscriminant();\nassert(disc > 0.0);\nassert(disc === 4.0);\n"
      }
    },
    {
      "title": "Heat Equation Classification (Parabolic)",
      "explanation": "Heat equation has zero discriminant and is classified as parabolic",
      "code": {
        "rust": "let u = symbol!(u);\nlet x = symbol!(x);\nlet t = symbol!(t);\n\n// Heat equation structure\nlet equation = expr!(add: x, t);\nlet pde = Pde::new(equation, u, vec![x, t]);\n\n// Automatic classification\nlet pde_type = pde.pde_type();\nassert_eq!(pde_type, Some(PdeType::Parabolic));\n\n// Discriminant\nlet disc = pde.compute_discriminant();\nassert_eq!(disc.abs(), 0.0);\n",
        "python": "u = symbol('u')\nx = symbol('x')\nt = symbol('t')\n\n# Heat equation structure\nequation = expr(add=[x, t])\npde = Pde.new(equation, u, [x, t])\n\n# Automatic classification\npde_type = pde.pde_type()\nassert pde_type == PdeType.Parabolic\n\n# Discriminant\ndisc = pde.compute_discriminant()\nassert abs(disc) == 0.0\n",
        "nodejs": "const u = symbol('u');\nconst x = symbol('x');\nconst t = symbol('t');\n\n// Heat equation structure\nconst equation = expr({ add: [x, t] });\nconst pde = Pde.new(equation, u, [x, t]);\n\n// Automatic classification\nconst pdeType = pde.pdeType();\nassert(pdeType === PdeType.Parabolic);\n\n// Discriminant\nconst disc = pde.computeDiscriminant();\nassert(Math.abs(disc) === 0.0);\n"
      }
    },
    {
      "title": "Laplace Equation Classification (Elliptic)",
      "explanation": "Laplace equation has negative discriminant and is classified as elliptic",
      "code": {
        "rust": "let u = symbol!(u);\nlet x = symbol!(x);\nlet y = symbol!(y);\n\n// Laplace equation structure\nlet equation = expr!(add: x, y);\nlet pde = Pde::new(equation, u, vec![x, y]);\n\n// Automatic classification\nlet pde_type = pde.pde_type();\nassert_eq!(pde_type, Some(PdeType::Elliptic));\n\n// Discriminant\nlet disc = pde.compute_discriminant();\nassert!(disc < 0.0);\nassert_eq!(disc, -4.0);\n",
        "python": "u = symbol('u')\nx = symbol('x')\ny = symbol('y')\n\n# Laplace equation structure\nequation = expr(add=[x, y])\npde = Pde.new(equation, u, [x, y])\n\n# Automatic classification\npde_type = pde.pde_type()\nassert pde_type == PdeType.Elliptic\n\n# Discriminant\ndisc = pde.compute_discriminant()\nassert disc < 0.0\nassert disc == -4.0\n",
        "nodejs": "const u = symbol('u');\nconst x = symbol('x');\nconst y = symbol('y');\n\n// Laplace equation structure\nconst equation = expr({ add: [x, y] });\nconst pde = Pde.new(equation, u, [x, y]);\n\n// Automatic classification\nconst pdeType = pde.pdeType();\nassert(pdeType === PdeType.Elliptic);\n\n// Discriminant\nconst disc = pde.computeDiscriminant();\nassert(disc < 0.0);\nassert(disc === -4.0);\n"
      }
    }
  ],
  "article": {
    "content": "# PDE Classification\n\n## Why Classification Matters\n\nDifferent PDE types require completely different solution methods:\n- **Elliptic**: Boundary value problems, steady-state\n- **Parabolic**: Initial value + boundary, diffusion\n- **Hyperbolic**: Initial value + boundary, wave propagation\n\nUsing the wrong method **WILL FAIL** or produce nonsense results.\n\n## Mathematical Classification Theory\n\n### The Discriminant Formula\n\nFor a general second-order PDE:\n\n$$A \\frac{\\partial^2 u}{\\partial x^2} + B \\frac{\\partial^2 u}{\\partial x \\partial y} + C \\frac{\\partial^2 u}{\\partial y^2} + \\text{lower order terms} = 0$$\n\nThe **discriminant** is:\n\n$$\\Delta = B^2 - 4AC$$\n\n### Classification Categories\n\n| Discriminant | Type | Canonical Form | Prototype |\n|--------------|------|----------------|-----------|\n| $\\Delta < 0$ | **Elliptic** | $u_{xx} + u_{yy} = 0$ | Laplace |\n| $\\Delta = 0$ | **Parabolic** | $u_t = u_{xx}$ | Heat |\n| $\\Delta > 0$ | **Hyperbolic** | $u_{tt} = c^2 u_{xx}$ | Wave |\n\n### Physical Interpretation\n\n#### Elliptic ($\\Delta < 0$)\n\n**Characteristics**: No real characteristics (complex)\n\n**Physical Meaning**: Equilibrium states, no time evolution\n\n**Properties**:\n- Smooth solutions (infinitely differentiable if coefficients are smooth)\n- Maximum principle: solution maximum on boundary\n- Propagation speed: **infinite** (disturbance felt everywhere instantly)\n\n**Examples**:\n- Laplace's equation: $\\nabla^2 u = 0$ (electrostatics, steady heat)\n- Poisson's equation: $\\nabla^2 u = f$ (gravity, charged regions)\n- Minimal surface equation: $(1 + u_y^2) u_{xx} - 2u_x u_y u_{xy} + (1 + u_x^2) u_{yy} = 0$\n\n#### Parabolic ($\\Delta = 0$)\n\n**Characteristics**: One family of real characteristics\n\n**Physical Meaning**: Diffusion processes, irreversible evolution\n\n**Properties**:\n- Smoothing effect (rough initial data becomes smooth)\n- Infinite propagation speed (finite but small amplitude)\n- Irreversible in time (cannot reverse diffusion without external forcing)\n\n**Examples**:\n- Heat equation: $u_t = \\alpha u_{xx}$ (thermal diffusion)\n- Black-Scholes equation: $\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + rS\\frac{\\partial V}{\\partial S} - rV = 0$ (option pricing)\n- Fokker-Planck equation: $\\frac{\\partial p}{\\partial t} = \\frac{\\partial^2}{\\partial x^2}(D p) - \\frac{\\partial}{\\partial x}(\\mu p)$ (stochastic processes)\n\n#### Hyperbolic ($\\Delta > 0$)\n\n**Characteristics**: Two families of real characteristics\n\n**Physical Meaning**: Wave propagation, reversible evolution\n\n**Properties**:\n- Finite propagation speed $c$ (disturbances travel along characteristics)\n- Preservation of discontinuities (shocks can form)\n- Reversible in time (wave equation is time-symmetric)\n\n**Examples**:\n- Wave equation: $u_{tt} = c^2 u_{xx}$ (vibrations, sound)\n- Telegraph equation: $u_{tt} + 2\\alpha u_t = c^2 u_{xx}$ (damped waves)\n- Beam equation: $u_{tt} + \\gamma u_{xxxx} = 0$ (elastic beam vibrations)\n\n## Discriminant Computation in MathHook\n\n### Current Implementation Limitations\n\nMathHook currently uses **pattern matching** instead of symbolic differentiation for coefficient extraction.\n\n**Why Pattern Matching?**:\n- Symbolic differentiation of coefficients requires extracting $A$, $B$, $C$ from PDE\n- This requires: $A = \\frac{\\partial^2}{\\partial x^2}(\\text{equation})$ evaluated symbolically\n- MathHook's differentiation module focuses on expressions, not PDE coefficient extraction\n- Pattern matching works for standard equations (heat, wave, Laplace)\n\n**Future Enhancement**:\nPhase 2 will implement full symbolic coefficient extraction.\n\n## Variable Naming Heuristics\n\nMathHook infers PDE type from variable names:\n\n### Time-Space PDEs\n\nVariables named 't' or 'time' → considered temporal\nVariables named 'x', 'y', 'z', or 'space' → considered spatial\n\n**Heat/Wave Equation Detection**:\n- Requires exactly 2 variables\n- One temporal (`t` or `time`)\n- One spatial (`x` or `space`)\n- Heat: Additive structure (first-order time derivative)\n- Wave: Multiplicative structure (second-order time derivative)\n\n### Spatial-Only PDEs\n\nVariables named 'x' and 'y' → spatial coordinates\n\n**Laplace Equation Detection**:\n- Requires 2+ spatial variables\n- No temporal variable\n- Additive structure\n\n### Custom Variable Names\n\n**⚠️ Warning**: Non-standard variable names may not classify correctly.\n\n## Classification Edge Cases\n\n### Mixed-Type PDEs\n\nSome PDEs change type based on region:\n\n**Tricomi Equation**: $y u_{xx} + u_{yy} = 0$\n\n- $y > 0$: Elliptic ($\\Delta = -4y < 0$)\n- $y = 0$: Parabolic ($\\Delta = 0$)\n- $y < 0$: Hyperbolic ($\\Delta = -4y > 0$)\n\n**⚠️ MathHook does NOT handle mixed-type PDEs currently**.\n\n### Degenerate Cases\n\n**Equation**: $u_{xx} = 0$\n\nThis is technically a **degenerate elliptic** PDE (only one second derivative):\n- Discriminant: $\\Delta = 0 - 4(1)(0) = 0$ (parabolic by formula)\n- But no time evolution (elliptic by behavior)\n\n**MathHook Classification**: Depends on variable names. Use with caution.\n"
  },
  "use_cases": [
    "Determining appropriate solution method for a PDE",
    "Understanding physical behavior of PDE solutions",
    "Selecting numerical methods based on PDE type",
    "Analyzing stability and convergence properties",
    "Teaching fundamental PDE theory"
  ],
  "related_topics": [
    "advanced.pde.boundary_conditions",
    "advanced.pde.method_of_characteristics",
    "calculus.heat_equation",
    "calculus.wave_equation",
    "calculus.laplace_equation"
  ],
  "performance": {
    "complexity": "O(1)",
    "typical_time": "<1ms"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}