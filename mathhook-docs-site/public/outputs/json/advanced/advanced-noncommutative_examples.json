{
  "topic": "advanced.noncommutative_examples",
  "title": "Noncommutative Algebra Examples",
  "description": "Comprehensive examples of noncommutative algebra in MathHook covering\nquantum mechanics operators, matrix algebra, quaternion rotations, and\nbulk symbol creation patterns.\n",
  "mathematical_definition": "**Noncommutative algebra**: An algebraic structure where multiplication\nis not commutative, i.e., $AB \\neq BA$ in general.\n\nKey examples:\n- **Matrix multiplication**: $\\mathbf{A}\\mathbf{B} \\neq \\mathbf{B}\\mathbf{A}$\n- **Quantum operators**: $[\\hat{x}, \\hat{p}] = \\hat{x}\\hat{p} - \\hat{p}\\hat{x} = i\\hbar$\n- **Quaternions**: $ij = k$, $ji = -k$\n",
  "code_refs": {
    "rust": "mathhook_core::noncommutative",
    "python": "mathhook.noncommutative",
    "nodejs": "mathhook.noncommutative"
  },
  "examples": [
    {
      "title": "Quantum Commutator",
      "explanation": "Position-momentum canonical commutation relation [x,p] = iℏ",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x; operator);  // Position operator\nlet p = symbol!(p; operator);  // Momentum operator\n\n// Commutator: [x, p] = xp - px\nlet xp = expr!(x * p);\nlet px = expr!(p * x);\nlet commutator = expr!(xp - px);\n\n// These are structurally different (noncommutative)\nassert_ne!(xp.to_string(), px.to_string());\n\n// LaTeX output preserves operator hats\nlet latex = commutator.to_latex(None).unwrap();\n// Output: \\hat{x}\\hat{p} - \\hat{p}\\hat{x}\n",
        "python": "from mathhook import symbol, expr\n\n# Create operator symbols\nx = symbol('x', type='operator')  # Position operator\np = symbol('p', type='operator')  # Momentum operator\n\n# Commutator: [x, p] = xp - px\nxp = x * p\npx = p * x\ncommutator = xp - px\n\n# These are structurally different (noncommutative)\nassert str(xp) != str(px)\n\n# LaTeX output preserves operator hats\nlatex = commutator.to_latex()\n# Output: \\hat{x}\\hat{p} - \\hat{p}\\hat{x}\n",
        "nodejs": "const { symbol, expr } = require('mathhook');\n\n// Create operator symbols\nconst x = symbol('x', {type: 'operator'});  // Position operator\nconst p = symbol('p', {type: 'operator'});  // Momentum operator\n\n// Commutator: [x, p] = xp - px\nconst xp = x.mul(p);\nconst px = p.mul(x);\nconst commutator = xp.sub(px);\n\n// These are structurally different (noncommutative)\nconsole.log(xp.toString() !== px.toString());  // true\n\n// LaTeX output preserves operator hats\nconst latex = commutator.toLatex();\n// Output: \\hat{x}\\hat{p} - \\hat{p}\\hat{x}\n"
      }
    },
    {
      "title": "Angular Momentum Operators",
      "explanation": "Quantum angular momentum with [Lx, Ly] = iℏLz",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet lx = symbol!(Lx; operator);\nlet ly = symbol!(Ly; operator);\nlet lz = symbol!(Lz; operator);\n\n// Lx*Ly product\nlet lx_ly = expr!(lx * ly);\n\n// Ly*Lx product\nlet ly_lx = expr!(ly * lx);\n\n// These are NOT equal (noncommutative)\nassert_ne!(lx_ly.to_string(), ly_lx.to_string());\n\n// Commutator [Lx, Ly] = Lx*Ly - Ly*Lx\nlet commutator = expr!(lx_ly - ly_lx);\n// In quantum mechanics, this equals i*hbar*Lz\n",
        "python": "from mathhook import symbol, expr\n\nlx = symbol('Lx', type='operator')\nly = symbol('Ly', type='operator')\nlz = symbol('Lz', type='operator')\n\n# Lx*Ly product\nlx_ly = lx * ly\n\n# Ly*Lx product\nly_lx = ly * lx\n\n# These are NOT equal (noncommutative)\nassert str(lx_ly) != str(ly_lx)\n\n# Commutator [Lx, Ly] = Lx*Ly - Ly*Lx\ncommutator = lx_ly - ly_lx\n# In quantum mechanics, this equals i*hbar*Lz\n",
        "nodejs": "const { symbol } = require('mathhook');\n\nconst lx = symbol('Lx', {type: 'operator'});\nconst ly = symbol('Ly', {type: 'operator'});\nconst lz = symbol('Lz', {type: 'operator'});\n\n// Lx*Ly product\nconst lx_ly = lx.mul(ly);\n\n// Ly*Lx product\nconst ly_lx = ly.mul(lx);\n\n// These are NOT equal (noncommutative)\nconsole.log(lx_ly.toString() !== ly_lx.toString());  // true\n"
      }
    },
    {
      "title": "Matrix Equation Left Division",
      "explanation": "Solve A*X = B using left division X = A^(-1)*B",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet solver = MatrixEquationSolver::new();\nlet A = symbol!(A; matrix);\nlet X = symbol!(X; matrix);\nlet B = symbol!(B; matrix);\n\n// Equation: A*X - B = 0 (i.e., A*X = B)\nlet equation = expr!((A * X) - B);\n\nlet result = solver.solve(&equation, &X);\n// Returns: X = A^(-1)*B (left multiplication by inverse)\n\n// Note: We multiply by A^(-1) on the LEFT because X is on the right of A\n",
        "python": "from mathhook import symbol, MatrixEquationSolver\n\nsolver = MatrixEquationSolver()\nA = symbol('A', type='matrix')\nX = symbol('X', type='matrix')\nB = symbol('B', type='matrix')\n\n# Equation: A*X = B\nequation = A * X - B\n\nresult = solver.solve(equation, X)\n# Returns: X = A.inv() * B (left multiplication by inverse)\n\n# Note: We multiply by A^(-1) on the LEFT because X is on the right of A\n",
        "nodejs": "const { symbol, MatrixEquationSolver } = require('mathhook');\n\nconst solver = new MatrixEquationSolver();\nconst A = symbol('A', {type: 'matrix'});\nconst X = symbol('X', {type: 'matrix'});\nconst B = symbol('B', {type: 'matrix'});\n\n// Equation: A*X = B\nconst equation = A.mul(X).sub(B);\n\nconst result = solver.solve(equation, X);\n// Returns: X = A.inv().mul(B) (left multiplication by inverse)\n"
      }
    },
    {
      "title": "Matrix Equation Right Division",
      "explanation": "Solve X*A = B using right division X = B*A^(-1)",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet solver = MatrixEquationSolver::new();\nlet A = symbol!(A; matrix);\nlet X = symbol!(X; matrix);\nlet B = symbol!(B; matrix);\n\n// Equation: X*A - B = 0 (i.e., X*A = B)\nlet equation = expr!((X * A) - B);\n\nlet result = solver.solve(&equation, &X);\n// Returns: X = B*A^(-1) (right multiplication by inverse)\n\n// Note: We multiply by A^(-1) on the RIGHT because X is on the left of A\n",
        "python": "from mathhook import symbol, MatrixEquationSolver\n\nsolver = MatrixEquationSolver()\nA = symbol('A', type='matrix')\nX = symbol('X', type='matrix')\nB = symbol('B', type='matrix')\n\n# Equation: X*A = B\nequation = X * A - B\n\nresult = solver.solve(equation, X)\n# Returns: X = B * A.inv() (right multiplication by inverse)\n\n# Note: We multiply by A^(-1) on the RIGHT because X is on the left of A\n",
        "nodejs": "const { symbol, MatrixEquationSolver } = require('mathhook');\n\nconst solver = new MatrixEquationSolver();\nconst A = symbol('A', {type: 'matrix'});\nconst X = symbol('X', {type: 'matrix'});\nconst B = symbol('B', {type: 'matrix'});\n\n// Equation: X*A = B\nconst equation = X.mul(A).sub(B);\n\nconst result = solver.solve(equation, X);\n// Returns: X = B.mul(A.inv()) (right multiplication by inverse)\n"
      }
    },
    {
      "title": "Quaternion Multiplication",
      "explanation": "Noncommutative quaternion basis multiplication i*j = k, j*i = -k",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet i = symbol!(i; quaternion);\nlet j = symbol!(j; quaternion);\nlet k = symbol!(k; quaternion);\n\n// i*j = k\nlet ij = expr!(i * j);\n\n// j*i = -k (different!)\nlet ji = expr!(j * i);\n\n// Order matters - multiplication is noncommutative\nassert_ne!(ij.to_string(), ji.to_string());\n\n// All quaternion products\n// i*j = k, j*i = -k\n// j*k = i, k*j = -i\n// k*i = j, i*k = -j\n",
        "python": "from mathhook import symbol\n\ni = symbol('i', type='quaternion')\nj = symbol('j', type='quaternion')\nk = symbol('k', type='quaternion')\n\n# i*j = k\nij = i * j\n\n# j*i = -k (different!)\nji = j * i\n\n# Order matters - multiplication is noncommutative\nassert str(ij) != str(ji)\n\n# All quaternion products:\n# i*j = k, j*i = -k\n# j*k = i, k*j = -i\n# k*i = j, i*k = -j\n",
        "nodejs": "const { symbol } = require('mathhook');\n\nconst i = symbol('i', {type: 'quaternion'});\nconst j = symbol('j', {type: 'quaternion'});\nconst k = symbol('k', {type: 'quaternion'});\n\n// i*j = k\nconst ij = i.mul(j);\n\n// j*i = -k (different!)\nconst ji = j.mul(i);\n\n// Order matters - multiplication is noncommutative\nconsole.log(ij.toString() !== ji.toString());  // true\n"
      }
    },
    {
      "title": "3D Rotation with Quaternions",
      "explanation": "Rotating a vector v by quaternion q: v' = q*v*conj(q)",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet q = symbol!(q; quaternion);       // Rotation quaternion\nlet v = symbol!(v; quaternion);       // Vector as pure quaternion\nlet q_conj = symbol!(q_conj; quaternion); // Conjugate of q\n\n// Rotation formula: v' = q*v*q_conj\nlet rotation = expr!(q * v * q_conj);\n\n// The order matters:\n// q * v * q_conj ≠ q_conj * v * q\n",
        "python": "from mathhook import symbol\n\nq = symbol('q', type='quaternion')       # Rotation quaternion\nv = symbol('v', type='quaternion')       # Vector as pure quaternion\nq_conj = symbol('q_conj', type='quaternion')  # Conjugate of q\n\n# Rotation formula: v' = q*v*q_conj\nrotation = q * v * q_conj\n\n# The order matters:\n# q * v * q_conj ≠ q_conj * v * q\n",
        "nodejs": "const { symbol } = require('mathhook');\n\nconst q = symbol('q', {type: 'quaternion'});       // Rotation quaternion\nconst v = symbol('v', {type: 'quaternion'});       // Vector as pure quaternion\nconst q_conj = symbol('q_conj', {type: 'quaternion'});  // Conjugate of q\n\n// Rotation formula: v' = q*v*q_conj\nconst rotation = q.mul(v).mul(q_conj);\n\n// The order matters:\n// q * v * q_conj ≠ q_conj * v * q\n"
      }
    },
    {
      "title": "Bulk Symbol Creation",
      "explanation": "Create multiple symbols at once using the symbols![] macro",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Multiple scalars (default type)\nlet scalars = symbols![x, y, z];\nlet x = &scalars[0];\nlet y = &scalars[1];\nlet z = &scalars[2];\n\n// Multiple matrices\nlet matrices = symbols![A, B, C => matrix];\nlet A = &matrices[0];\nlet B = &matrices[1];\nlet C = &matrices[2];\n\n// Multiple operators\nlet operators = symbols![p, x_op, H => operator];\nlet p = &operators[0];\nlet x_op = &operators[1];\nlet H = &operators[2];\n\n// Multiple quaternions\nlet quaternions = symbols![i, j, k => quaternion];\nlet i = &quaternions[0];\nlet j = &quaternions[1];\nlet k = &quaternions[2];\n",
        "python": "from mathhook import symbols\n\n# Multiple scalars (default type)\nx, y, z = symbols('x y z')\n\n# Multiple matrices\nA, B, C = symbols('A B C', type='matrix')\n\n# Multiple operators\np, x_op, H = symbols('p x_op H', type='operator')\n\n# Multiple quaternions\ni, j, k = symbols('i j k', type='quaternion')\n",
        "nodejs": "const { symbols } = require('mathhook');\n\n// Multiple scalars (default type)\nconst [x, y, z] = symbols(['x', 'y', 'z']);\n\n// Multiple matrices\nconst [A, B, C] = symbols(['A', 'B', 'C'], {type: 'matrix'});\n\n// Multiple operators\nconst [p, x_op, H] = symbols(['p', 'x_op', 'H'], {type: 'operator'});\n\n// Multiple quaternions\nconst [i, j, k] = symbols(['i', 'j', 'k'], {type: 'quaternion'});\n"
      }
    },
    {
      "title": "Complete Workflow Example",
      "explanation": "End-to-end example: create symbols, build equation, solve, format as LaTeX",
      "code": {
        "rust": "use mathhook::prelude::*;\nuse mathhook::educational::message_registry::{\n    MessageBuilder, MessageCategory, MessageType\n};\n\n// 1. Create matrix symbols\nlet A = symbol!(A; matrix);\nlet X = symbol!(X; matrix);\nlet B = symbol!(B; matrix);\n\n// 2. Build equation: A*X = B\nlet equation = expr!((A * X) - B);\n\n// 3. Solve equation\nlet solver = MatrixEquationSolver::new();\nlet result = solver.solve(&equation, &X);\n\n// 4. Format solution as LaTeX\nif let SolverResult::Single(solution) = result {\n    let latex = solution.to_latex(None).unwrap();\n    println!(\"Solution: {}\", latex);\n    // Output: \\mathbf{A}^{-1} \\cdot \\mathbf{B}\n}\n\n// 5. Get educational explanation\nlet msg = MessageBuilder::new(\n    MessageCategory::NoncommutativeAlgebra,\n    MessageType::LeftMultiplyInverse,\n    0\n).build();\n\nif let Some(message) = msg {\n    println!(\"Explanation: {}\", message.description);\n}\n",
        "python": "from mathhook import symbol, MatrixEquationSolver, SolverResult\nfrom mathhook.educational import MessageBuilder, MessageCategory, MessageType\n\n# 1. Create matrix symbols\nA = symbol('A', type='matrix')\nX = symbol('X', type='matrix')\nB = symbol('B', type='matrix')\n\n# 2. Build equation: A*X = B\nequation = A * X - B\n\n# 3. Solve equation\nsolver = MatrixEquationSolver()\nresult = solver.solve(equation, X)\n\n# 4. Format solution as LaTeX\nif isinstance(result, SolverResult.Single):\n    latex = result.solution.to_latex()\n    print(f\"Solution: {latex}\")\n    # Output: \\mathbf{A}^{-1} \\cdot \\mathbf{B}\n\n# 5. Get educational explanation\nmsg = MessageBuilder(\n    MessageCategory.NoncommutativeAlgebra,\n    MessageType.LeftMultiplyInverse,\n    step=0\n).build()\n\nif msg:\n    print(f\"Explanation: {msg.description}\")\n",
        "nodejs": "const { symbol, MatrixEquationSolver, SolverResult } = require('mathhook');\nconst { MessageBuilder, MessageCategory, MessageType } = require('mathhook/educational');\n\n// 1. Create matrix symbols\nconst A = symbol('A', {type: 'matrix'});\nconst X = symbol('X', {type: 'matrix'});\nconst B = symbol('B', {type: 'matrix'});\n\n// 2. Build equation: A*X = B\nconst equation = A.mul(X).sub(B);\n\n// 3. Solve equation\nconst solver = new MatrixEquationSolver();\nconst result = solver.solve(equation, X);\n\n// 4. Format solution as LaTeX\nif (result instanceof SolverResult.Single) {\n    const latex = result.solution.toLatex();\n    console.log(`Solution: ${latex}`);\n    // Output: \\mathbf{A}^{-1} \\cdot \\mathbf{B}\n}\n\n// 5. Get educational explanation\nconst msg = new MessageBuilder(\n    MessageCategory.NoncommutativeAlgebra,\n    MessageType.LeftMultiplyInverse,\n    0\n).build();\n\nif (msg) {\n    console.log(`Explanation: ${msg.description}`);\n}\n"
      }
    }
  ],
  "article": {
    "content": "# Noncommutative Algebra Examples\n\nThis guide provides practical examples of working with noncommutative\nalgebra in MathHook across different domains.\n\n## Quantum Mechanics\n\n### Position and Momentum Operators\nThe canonical commutation relation: $[x, p] = xp - px = i\\hbar$\n\n### Hamiltonian Eigenvalue Equation\nSolving $H|\\psi\\rangle = E|\\psi\\rangle$\n\n### Angular Momentum Operators\nQuantum angular momentum: $[L_x, L_y] = i\\hbar L_z$\n\n## Matrix Algebra\n\n### Left vs Right Division\n- **Left division**: $AX = B \\Rightarrow X = A^{-1}B$\n- **Right division**: $XA = B \\Rightarrow X = BA^{-1}$\n\nOrder of multiplication matters when the unknown is on different sides.\n\n## Quaternion Rotations\n\n### Basis Elements\nQuaternion basis $\\{1, i, j, k\\}$ with:\n- $ij = k$, $ji = -k$\n- $jk = i$, $kj = -i$\n- $ki = j$, $ik = -j$\n\n### 3D Rotations\nRotating vector $v$ by quaternion $q$: $v' = qv\\bar{q}$\n"
  },
  "use_cases": [
    "Quantum mechanics: computing commutators and expectation values",
    "Linear algebra: solving matrix equations with correct left/right multiplication",
    "Computer graphics: 3D rotations using quaternions",
    "Robotics: orientation representation and interpolation",
    "Physics simulations: angular momentum and spin calculations"
  ],
  "related_topics": [
    "advanced.noncommutative_algebra",
    "advanced.noncommutative_api_reference",
    "advanced.matrices",
    "educational.messages"
  ],
  "metadata": {
    "schema_version": "1.0"
  }
}