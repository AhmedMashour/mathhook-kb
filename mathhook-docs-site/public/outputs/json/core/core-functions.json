{
  "topic": "core.functions",
  "title": "Function System",
  "description": "MathHook provides a comprehensive mathematical function system with intelligent evaluation,\nsymbolic manipulation, and educational explanations. Functions are first-class expressions\nsupporting exact symbolic computation and high-performance numerical evaluation through\na modular intelligence architecture.\n",
  "mathematical_definition": "Functions in MathHook follow standard mathematical definitions:\n\n**Trigonometric**: $$\\sin(x), \\cos(x), \\tan(x)$$ with periodicity $$2\\pi$$\n\n**Exponential/Logarithmic**: $$e^x, \\ln(x), \\log_b(x) = \\frac{\\ln(x)}{\\ln(b)}$$\n\n**Special Functions**: $$\\Gamma(n) = \\int_0^{\\infty} t^{n-1} e^{-t} dt$$\n",
  "code_refs": {
    "rust": "mathhook_core::functions",
    "python": "mathhook.functions",
    "nodejs": "mathhook-node.functions"
  },
  "examples": [
    {
      "title": "Creating Functions with Macros",
      "explanation": "Using function! and expr! macros for ergonomic function creation",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Single argument functions\nlet sine = function!(sin, x);\nlet cosine = function!(cos, x);\n\n// Multi-argument functions\nlet log_base = function!(log, x, 10);\n\n// Using expr! macro\nlet trig_identity = expr!(sin(x)^2 + cos(x)^2);\nassert_eq!(trig_identity.simplify(), Expression::integer(1));\n",
        "python": "from mathhook import symbol, function, expr\n\nx = symbol('x')\n\n# Single argument functions\nsine = function('sin', x)\ncosine = function('cos', x)\n\n# Multi-argument functions\nlog_base = function('log', x, 10)\n\n# Using expr\ntrig_identity = expr('sin(x)^2 + cos(x)^2')\nassert trig_identity.simplify() == 1\n",
        "nodejs": "const { symbol, func, expr } = require('mathhook-node');\n\nconst x = symbol('x');\n\n// Single argument functions\nconst sine = func('sin', x);\nconst cosine = func('cos', x);\n\n// Multi-argument functions\nconst logBase = func('log', x, 10);\n\n// Using expr\nconst trigIdentity = expr('sin(x)^2 + cos(x)^2');\nconsole.assert(trigIdentity.simplify().equals(1));\n"
      }
    },
    {
      "title": "Trigonometric Functions with Exact Values",
      "explanation": "Automatic recognition of exact trigonometric values at special angles",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Exact values recognized\nassert_eq!(expr!(sin(0)), expr!(0));\nassert_eq!(expr!(sin(pi/6)), expr!(1/2));\nassert_eq!(expr!(sin(pi/4)), expr!(sqrt(2)/2));\nassert_eq!(expr!(sin(pi/2)), expr!(1));\n\nassert_eq!(expr!(cos(0)), expr!(1));\nassert_eq!(expr!(cos(pi/3)), expr!(1/2));\nassert_eq!(expr!(cos(pi/2)), expr!(0));\n",
        "python": "from mathhook import expr\n\n# Exact values recognized\nassert expr('sin(0)') == 0\nassert expr('sin(pi/6)') == expr('1/2')\nassert expr('sin(pi/4)') == expr('sqrt(2)/2')\nassert expr('sin(pi/2)') == 1\n\nassert expr('cos(0)') == 1\nassert expr('cos(pi/3)') == expr('1/2')\nassert expr('cos(pi/2)') == 0\n",
        "nodejs": "const { expr } = require('mathhook-node');\n\n// Exact values recognized\nconsole.assert(expr('sin(0)').equals(0));\nconsole.assert(expr('sin(pi/6)').equals(expr('1/2')));\nconsole.assert(expr('sin(pi/4)').equals(expr('sqrt(2)/2')));\nconsole.assert(expr('sin(pi/2)').equals(1));\n\nconsole.assert(expr('cos(0)').equals(1));\nconsole.assert(expr('cos(pi/3)').equals(expr('1/2')));\nconsole.assert(expr('cos(pi/2)').equals(0));\n"
      }
    },
    {
      "title": "Logarithm and Exponential Identities",
      "explanation": "Automatic application of logarithm laws and exponential identities",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet a = symbol!(a);\nlet b = symbol!(b);\nlet n = symbol!(n);\n\n// Logarithm laws\nassert_eq!(expr!(ln(a*b)).expand(), expr!(ln(a) + ln(b)));\nassert_eq!(expr!(ln(a/b)).expand(), expr!(ln(a) - ln(b)));\nassert_eq!(expr!(ln(a^n)).expand(), expr!(n*ln(a)));\n\n// Exponential identities\nassert_eq!(expr!(e^(ln(a))).simplify(), a);\nassert_eq!(expr!(ln(e^a)).simplify(), a);\n",
        "python": "from mathhook import symbol, expr\n\na = symbol('a')\nb = symbol('b')\nn = symbol('n')\n\n# Logarithm laws\nassert expr('ln(a*b)').expand() == expr('ln(a) + ln(b)')\nassert expr('ln(a/b)').expand() == expr('ln(a) - ln(b)')\nassert expr('ln(a^n)').expand() == expr('n*ln(a)')\n\n# Exponential identities\nassert expr('e^(ln(a))').simplify() == a\nassert expr('ln(e^a)').simplify() == a\n",
        "nodejs": "const { symbol, expr } = require('mathhook-node');\n\nconst a = symbol('a');\nconst b = symbol('b');\nconst n = symbol('n');\n\n// Logarithm laws\nconsole.assert(expr('ln(a*b)').expand().equals(expr('ln(a) + ln(b)')));\nconsole.assert(expr('ln(a/b)').expand().equals(expr('ln(a) - ln(b)')));\nconsole.assert(expr('ln(a^n)').expand().equals(expr('n*ln(a)')));\n\n// Exponential identities\nconsole.assert(expr('e^(ln(a))').simplify().equals(a));\nconsole.assert(expr('ln(e^a)').simplify().equals(a));\n"
      }
    },
    {
      "title": "Function Derivatives (Automatic Chain Rule)",
      "explanation": "Functions know their derivatives with automatic chain rule application",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Basic derivatives\nassert_eq!(expr!(sin(x)).derivative(&x, 1), expr!(cos(x)));\nassert_eq!(expr!(cos(x)).derivative(&x, 1), expr!(-sin(x)));\nassert_eq!(expr!(exp(x)).derivative(&x, 1), expr!(exp(x)));\nassert_eq!(expr!(ln(x)).derivative(&x, 1), expr!(1/x));\n\n// Chain rule automatic\nlet f = expr!(sin(x^2));\nassert_eq!(f.derivative(&x, 1), expr!(2*x*cos(x^2)));\n",
        "python": "from mathhook import symbol, expr\n\nx = symbol('x')\n\n# Basic derivatives\nassert expr('sin(x)').derivative(x) == expr('cos(x)')\nassert expr('cos(x)').derivative(x) == expr('-sin(x)')\nassert expr('exp(x)').derivative(x) == expr('exp(x)')\nassert expr('ln(x)').derivative(x) == expr('1/x')\n\n# Chain rule automatic\nf = expr('sin(x^2)')\nassert f.derivative(x) == expr('2*x*cos(x^2)')\n",
        "nodejs": "const { symbol, expr } = require('mathhook-node');\n\nconst x = symbol('x');\n\n// Basic derivatives\nconsole.assert(expr('sin(x)').derivative(x).equals(expr('cos(x)')));\nconsole.assert(expr('cos(x)').derivative(x).equals(expr('-sin(x)')));\nconsole.assert(expr('exp(x)').derivative(x).equals(expr('exp(x)')));\nconsole.assert(expr('ln(x)').derivative(x).equals(expr('1/x')));\n\n// Chain rule automatic\nconst f = expr('sin(x^2)');\nconsole.assert(f.derivative(x).equals(expr('2*x*cos(x^2)')));\n"
      }
    },
    {
      "title": "Special Functions (Gamma and Bessel)",
      "explanation": "Advanced special functions for scientific and engineering applications",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Gamma function (factorial generalization)\nassert_eq!(expr!(gamma(1)), expr!(1));   // Γ(1) = 0! = 1\nassert_eq!(expr!(gamma(5)), expr!(24));  // Γ(5) = 4! = 24\nassert_eq!(expr!(gamma(1/2)), expr!(sqrt(pi)));\n\n// Bessel functions (wave propagation)\nlet x = symbol!(x);\nlet bessel_j0 = expr!(bessel_j(0, x));\nlet bessel_y0 = expr!(bessel_y(0, x));\n",
        "python": "from mathhook import expr, symbol\n\n# Gamma function\nassert expr('gamma(1)') == 1\nassert expr('gamma(5)') == 24\nassert expr('gamma(1/2)') == expr('sqrt(pi)')\n\n# Bessel functions\nx = symbol('x')\nbessel_j0 = expr('bessel_j(0, x)')\nbessel_y0 = expr('bessel_y(0, x)')\n",
        "nodejs": "const { expr, symbol } = require('mathhook-node');\n\n// Gamma function\nconsole.assert(expr('gamma(1)').equals(1));\nconsole.assert(expr('gamma(5)').equals(24));\nconsole.assert(expr('gamma(1/2)').equals(expr('sqrt(pi)')));\n\n// Bessel functions\nconst x = symbol('x');\nconst besselJ0 = expr('bessel_j(0, x)');\nconst besselY0 = expr('bessel_y(0, x)');\n"
      }
    },
    {
      "title": "Real-World Physics Application",
      "explanation": "Damped harmonic oscillator using exponential and trigonometric functions",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Damped harmonic motion: x(t) = A*e^(-γt)*cos(ωt + φ)\nlet t = symbol!(t);\nlet A = expr!(1);\nlet gamma = expr!(0.1);\nlet omega = expr!(2*pi);\nlet phi = expr!(0);\n\nlet position = expr!(A * e^(-gamma*t) * cos(omega*t + phi));\nlet velocity = position.derivative(&t, 1);\nlet acceleration = velocity.derivative(&t, 1);\n\n// Verify: ẍ + 2γẋ + ω²x = 0\nlet lhs = expr!(acceleration + 2*gamma*velocity + (omega^2)*position);\nassert_eq!(lhs.simplify(), expr!(0));\n",
        "python": "from mathhook import symbol, expr\n\n# Damped harmonic motion\nt = symbol('t')\nposition = expr('e^(-0.1*t) * cos(2*pi*t)')\nvelocity = position.derivative(t)\nacceleration = velocity.derivative(t)\n\n# Differential equation verification\ngamma = 0.1\nomega = expr('2*pi')\nlhs = expr(f'acceleration + 2*{gamma}*velocity + omega^2*position')\n# Should simplify to 0\n",
        "nodejs": "const { symbol, expr } = require('mathhook-node');\n\n// Damped harmonic motion\nconst t = symbol('t');\nconst position = expr('e^(-0.1*t) * cos(2*pi*t)');\nconst velocity = position.derivative(t);\nconst acceleration = velocity.derivative(t);\n\n// Differential equation verification\nconst gamma = 0.1;\nconst omega = expr('2*pi');\n// Should satisfy: ẍ + 2γẋ + ω²x = 0\n"
      }
    }
  ],
  "article": {
    "content": "[Full markdown content preserved from functions.md - truncated in this example for brevity]\n"
  },
  "use_cases": [
    "Trigonometry and periodic phenomena in physics",
    "Exponential growth/decay models in biology and finance",
    "Signal processing with Fourier transforms",
    "Quantum mechanics with special functions",
    "Engineering transfer functions and control theory"
  ],
  "related_topics": [
    "core.expressions",
    "core.constants",
    "operations.differentiation",
    "operations.integration",
    "advanced.special-functions"
  ],
  "performance": {
    "complexity": "O(1) for function lookup, O(n) for evaluation where n is expression size",
    "typical_time": "< 100ns for symbolic operations, < 10ns for numerical evaluation"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}