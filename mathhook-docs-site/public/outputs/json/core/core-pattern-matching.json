{
  "topic": "core.pattern-matching",
  "title": "Pattern Matching",
  "description": "Pattern matching is a powerful technique in MathHook for identifying, transforming,\nand simplifying mathematical expressions. MathHook combines Rust's native pattern\nmatching with specialized mathematical pattern recognition to enable sophisticated\nsymbolic manipulation including algebraic identities, calculus rules, and\ntrigonometric transformations.\n",
  "mathematical_definition": "**Common Mathematical Patterns:**\n\n- **Difference of Squares**: $$a^2 - b^2 = (a + b)(a - b)$$\n- **Perfect Square**: $$a^2 + 2ab + b^2 = (a + b)^2$$\n- **Power Rule**: $$\\frac{d}{dx}(x^n) = nx^{n-1}$$\n- **Chain Rule**: $$\\frac{d}{dx}f(g(x)) = f'(g(x)) \\cdot g'(x)$$\n- **Pythagorean Identity**: $$\\sin^2(x) + \\cos^2(x) = 1$$\n",
  "code_refs": {
    "rust": "mathhook_core::pattern",
    "python": "mathhook.pattern",
    "nodejs": "mathhook-node.pattern"
  },
  "examples": [
    {
      "title": "Rust Native Pattern Matching on Expressions",
      "explanation": "Using Rust's match statement to analyze expression structure",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nfn analyze_expression(expr: &Expression) -> String {\n    match expr {\n        Expression::Integer(n) => format!(\"Integer: {}\", n),\n        Expression::Symbol(s) => format!(\"Variable: {}\", s.name()),\n        Expression::Add(terms) => format!(\"Sum of {} terms\", terms.len()),\n        Expression::Mul(factors) => format!(\"Product of {} factors\", factors.len()),\n        Expression::Pow(base, exp) => format!(\"Power: ({})^({})\", base, exp),\n        Expression::Function { name, args } => {\n            format!(\"Function {}: {} args\", name, args.len())\n        }\n        _ => \"Other expression type\".to_string(),\n    }\n}\n\nlet expr = expr!(x^2 + 2*x + 1);\nprintln!(\"{}\", analyze_expression(&expr));\n",
        "python": "from mathhook import Expression, expr\n\ndef analyze_expression(e):\n    if e.is_integer():\n        return f\"Integer: {e.value()}\"\n    elif e.is_symbol():\n        return f\"Variable: {e.name()}\"\n    elif e.is_add():\n        return f\"Sum of {len(e.terms())} terms\"\n    elif e.is_mul():\n        return f\"Product of {len(e.factors())} factors\"\n    elif e.is_pow():\n        return f\"Power: ({e.base()})^({e.exponent()})\"\n    elif e.is_function():\n        return f\"Function {e.name()}: {len(e.args())} args\"\n    else:\n        return \"Other expression type\"\n\nexpr_val = expr('x^2 + 2*x + 1')\nprint(analyze_expression(expr_val))\n",
        "nodejs": "const { Expression, expr } = require('mathhook-node');\n\nfunction analyzeExpression(e) {\n    if (e.isInteger()) {\n        return `Integer: ${e.value()}`;\n    } else if (e.isSymbol()) {\n        return `Variable: ${e.name()}`;\n    } else if (e.isAdd()) {\n        return `Sum of ${e.terms().length} terms`;\n    } else if (e.isMul()) {\n        return `Product of ${e.factors().length} factors`;\n    } else if (e.isPow()) {\n        return `Power: (${e.base()})^(${e.exponent()})`;\n    } else if (e.isFunction()) {\n        return `Function ${e.name()}: ${e.args().length} args`;\n    }\n    return 'Other expression type';\n}\n\nconst exprVal = expr('x^2 + 2*x + 1');\nconsole.log(analyzeExpression(exprVal));\n"
      }
    },
    {
      "title": "Algebraic Pattern: Difference of Squares",
      "explanation": "Recognizing and factoring difference of squares pattern",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet a = symbol!(a);\nlet b = symbol!(b);\n\n// Pattern: a² - b² = (a + b)(a - b)\nlet diff_squares = expr!(a^2 - b^2);\nlet factored = diff_squares.factor();\nassert_eq!(factored, expr!((a + b) * (a - b)));\n\n// Recognizes in complex forms\nlet x = symbol!(x);\nlet example = expr!(x^4 - 16);\nlet factored_example = example.factor();\n// (x² + 4)(x² - 4)\nassert_eq!(factored_example, expr!((x^2 + 4) * (x^2 - 4)));\n",
        "python": "from mathhook import symbol, expr\n\na = symbol('a')\nb = symbol('b')\n\n# Pattern: a² - b² = (a + b)(a - b)\ndiff_squares = expr('a^2 - b^2')\nfactored = diff_squares.factor()\nassert factored == expr('(a + b) * (a - b)')\n\n# Complex forms\nx = symbol('x')\nexample = expr('x^4 - 16')\nfactored_example = example.factor()\nassert factored_example == expr('(x^2 + 4) * (x^2 - 4)')\n",
        "nodejs": "const { symbol, expr } = require('mathhook-node');\n\nconst a = symbol('a');\nconst b = symbol('b');\n\n// Pattern: a² - b² = (a + b)(a - b)\nconst diffSquares = expr('a^2 - b^2');\nconst factored = diffSquares.factor();\nconsole.assert(factored.equals(expr('(a + b) * (a - b)')));\n\n// Complex forms\nconst x = symbol('x');\nconst example = expr('x^4 - 16');\nconst factoredExample = example.factor();\nconsole.assert(factoredExample.equals(expr('(x^2 + 4) * (x^2 - 4)')));\n"
      }
    },
    {
      "title": "Calculus Pattern: Power Rule Derivative",
      "explanation": "Automatic pattern recognition for power rule differentiation",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Pattern: d/dx(x^n) = n*x^(n-1)\nlet f = expr!(x^5);\nlet df = f.derivative(&x, 1);\nassert_eq!(df, expr!(5 * x^4));\n\n// Works for any power\nlet sqrt_x = expr!(x^(1/2));\nlet d_sqrt = sqrt_x.derivative(&x, 1);\nassert_eq!(d_sqrt, expr!((1/2) * x^(-1/2)));\n",
        "python": "from mathhook import symbol, expr\n\nx = symbol('x')\n\n# Pattern: d/dx(x^n) = n*x^(n-1)\nf = expr('x^5')\ndf = f.derivative(x)\nassert df == expr('5 * x^4')\n\n# Works for any power\nsqrt_x = expr('x^(1/2)')\nd_sqrt = sqrt_x.derivative(x)\nassert d_sqrt == expr('(1/2) * x^(-1/2)')\n",
        "nodejs": "const { symbol, expr } = require('mathhook-node');\n\nconst x = symbol('x');\n\n// Pattern: d/dx(x^n) = n*x^(n-1)\nconst f = expr('x^5');\nconst df = f.derivative(x);\nconsole.assert(df.equals(expr('5 * x^4')));\n\n// Works for any power\nconst sqrtX = expr('x^(1/2)');\nconst dSqrt = sqrtX.derivative(x);\nconsole.assert(dSqrt.equals(expr('(1/2) * x^(-1/2)')));\n"
      }
    },
    {
      "title": "Calculus Pattern: Chain Rule",
      "explanation": "Automatic chain rule application for composite functions",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Pattern: d/dx f(g(x)) = f'(g(x)) * g'(x)\nlet f = expr!(sin(x^2));\n// sin(u) where u = x²\n// Derivative: cos(u) * du/dx = cos(x²) * 2x\nlet df = f.derivative(&x, 1);\nassert_eq!(df, expr!(2*x*cos(x^2)));\n\n// Nested composition\nlet nested = expr!(sin(cos(x)));\nlet d_nested = nested.derivative(&x, 1);\n// cos(cos(x)) * (-sin(x))\nassert_eq!(d_nested, expr!(-sin(x)*cos(cos(x))));\n",
        "python": "from mathhook import symbol, expr\n\nx = symbol('x')\n\n# Pattern: chain rule\nf = expr('sin(x^2)')\ndf = f.derivative(x)\nassert df == expr('2*x*cos(x^2)')\n\n# Nested composition\nnested = expr('sin(cos(x))')\nd_nested = nested.derivative(x)\nassert d_nested == expr('-sin(x)*cos(cos(x))')\n",
        "nodejs": "const { symbol, expr } = require('mathhook-node');\n\nconst x = symbol('x');\n\n// Chain rule\nconst f = expr('sin(x^2)');\nconst df = f.derivative(x);\nconsole.assert(df.equals(expr('2*x*cos(x^2)')));\n\n// Nested composition\nconst nested = expr('sin(cos(x))');\nconst dNested = nested.derivative(x);\nconsole.assert(dNested.equals(expr('-sin(x)*cos(cos(x))')));\n"
      }
    },
    {
      "title": "Trigonometric Pattern: Pythagorean Identity",
      "explanation": "Automatic simplification using trigonometric identities",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Pattern: sin²(x) + cos²(x) = 1\nlet identity = expr!(sin(x)^2 + cos(x)^2);\nassert_eq!(identity.simplify(), expr!(1));\n\n// Pattern: 1 + tan²(x) = sec²(x)\nlet tan_identity = expr!(1 + tan(x)^2);\nassert_eq!(tan_identity.simplify(), expr!(sec(x)^2));\n\n// Pattern: 1 + cot²(x) = csc²(x)\nlet cot_identity = expr!(1 + cot(x)^2);\nassert_eq!(cot_identity.simplify(), expr!(csc(x)^2));\n",
        "python": "from mathhook import symbol, expr\n\nx = symbol('x')\n\n# Pythagorean identities\nidentity = expr('sin(x)^2 + cos(x)^2')\nassert identity.simplify() == 1\n\ntan_identity = expr('1 + tan(x)^2')\nassert tan_identity.simplify() == expr('sec(x)^2')\n\ncot_identity = expr('1 + cot(x)^2')\nassert cot_identity.simplify() == expr('csc(x)^2')\n",
        "nodejs": "const { symbol, expr } = require('mathhook-node');\n\nconst x = symbol('x');\n\n// Pythagorean identities\nconst identity = expr('sin(x)^2 + cos(x)^2');\nconsole.assert(identity.simplify().equals(1));\n\nconst tanIdentity = expr('1 + tan(x)^2');\nconsole.assert(tanIdentity.simplify().equals(expr('sec(x)^2')));\n\nconst cotIdentity = expr('1 + cot(x)^2');\nconsole.assert(cotIdentity.simplify().equals(expr('csc(x)^2')));\n"
      }
    },
    {
      "title": "Logarithm Pattern: Log Laws",
      "explanation": "Automatic application of logarithm expansion and combination rules",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet a = symbol!(a);\nlet b = symbol!(b);\nlet n = symbol!(n);\n\n// Pattern: ln(a*b) = ln(a) + ln(b)\nlet log_product = expr!(ln(a*b));\nassert_eq!(log_product.expand(), expr!(ln(a) + ln(b)));\n\n// Pattern: ln(a/b) = ln(a) - ln(b)\nlet log_quotient = expr!(ln(a/b));\nassert_eq!(log_quotient.expand(), expr!(ln(a) - ln(b)));\n\n// Pattern: ln(a^n) = n*ln(a)\nlet log_power = expr!(ln(a^n));\nassert_eq!(log_power.expand(), expr!(n*ln(a)));\n",
        "python": "from mathhook import symbol, expr\n\na = symbol('a')\nb = symbol('b')\nn = symbol('n')\n\n# Log laws\nlog_product = expr('ln(a*b)')\nassert log_product.expand() == expr('ln(a) + ln(b)')\n\nlog_quotient = expr('ln(a/b)')\nassert log_quotient.expand() == expr('ln(a) - ln(b)')\n\nlog_power = expr('ln(a^n)')\nassert log_power.expand() == expr('n*ln(a)')\n",
        "nodejs": "const { symbol, expr } = require('mathhook-node');\n\nconst a = symbol('a');\nconst b = symbol('b');\nconst n = symbol('n');\n\n// Log laws\nconst logProduct = expr('ln(a*b)');\nconsole.assert(logProduct.expand().equals(expr('ln(a) + ln(b)')));\n\nconst logQuotient = expr('ln(a/b)');\nconsole.assert(logQuotient.expand().equals(expr('ln(a) - ln(b)')));\n\nconst logPower = expr('ln(a^n)');\nconsole.assert(logPower.expand().equals(expr('n*ln(a)')));\n"
      }
    },
    {
      "title": "Custom Pattern Matcher: Polynomial Detection",
      "explanation": "Implementing custom pattern recognition for polynomial expressions",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n/// Pattern matcher for polynomial expressions\nfn is_polynomial(expr: &Expression, var: &Symbol) -> bool {\n    match expr {\n        // Constant term\n        Expression::Integer(_) | Expression::Rational(_) => true,\n\n        // Variable itself\n        Expression::Symbol(s) if s == var => true,\n\n        // Power of variable\n        Expression::Pow(base, exp) => {\n            matches!(**base, Expression::Symbol(ref s) if s == var) &&\n            matches!(**exp, Expression::Integer(n) if n >= 0)\n        }\n\n        // Sum or product of polynomials\n        Expression::Add(terms) | Expression::Mul(factors) => {\n            terms.iter().all(|t| is_polynomial(t, var)) ||\n            factors.iter().all(|f| is_polynomial(f, var))\n        }\n\n        _ => false,\n    }\n}\n\nlet x = symbol!(x);\nassert!(is_polynomial(&expr!(x^2 + 3*x + 1), &x));\nassert!(!is_polynomial(&expr!(sin(x)), &x));\n",
        "python": "from mathhook import Expression, symbol, expr\n\ndef is_polynomial(e, var):\n    if e.is_integer() or e.is_rational():\n        return True\n    elif e.is_symbol():\n        return e == var\n    elif e.is_pow():\n        base = e.base()\n        exp = e.exponent()\n        return (base.is_symbol() and base == var and\n                exp.is_integer() and exp.value() >= 0)\n    elif e.is_add() or e.is_mul():\n        terms = e.terms() if e.is_add() else e.factors()\n        return all(is_polynomial(t, var) for t in terms)\n    return False\n\nx = symbol('x')\nassert is_polynomial(expr('x^2 + 3*x + 1'), x)\nassert not is_polynomial(expr('sin(x)'), x)\n",
        "nodejs": "const { Expression, symbol, expr } = require('mathhook-node');\n\nfunction isPolynomial(e, varSym) {\n    if (e.isInteger() || e.isRational()) {\n        return true;\n    } else if (e.isSymbol()) {\n        return e.equals(varSym);\n    } else if (e.isPow()) {\n        const base = e.base();\n        const exp = e.exponent();\n        return base.isSymbol() && base.equals(varSym) &&\n               exp.isInteger() && exp.value() >= 0;\n    } else if (e.isAdd() || e.isMul()) {\n        const terms = e.isAdd() ? e.terms() : e.factors();\n        return terms.every(t => isPolynomial(t, varSym));\n    }\n    return false;\n}\n\nconst x = symbol('x');\nconsole.assert(isPolynomial(expr('x^2 + 3*x + 1'), x));\nconsole.assert(!isPolynomial(expr('sin(x)'), x));\n"
      }
    }
  ],
  "use_cases": [
    "Algebraic simplification and identity application",
    "Automatic differentiation rule selection",
    "Integral pattern recognition for substitution",
    "Polynomial factorization and expansion",
    "Trigonometric identity application",
    "Custom transformation rules for domain-specific problems"
  ],
  "related_topics": [
    "core.expressions",
    "operations.simplification",
    "operations.differentiation",
    "operations.integration",
    "operations.expansion-factoring"
  ],
  "performance": {
    "complexity": "O(n) for pattern matching on expression tree of size n",
    "typical_time": "< 100ns for simple patterns, < 1ms for complex recursive patterns"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}