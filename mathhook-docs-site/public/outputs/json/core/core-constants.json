{
  "topic": "core.constants",
  "title": "Mathematical Constants",
  "description": "MathHook provides built-in mathematical constants with exact symbolic representation\nand high-precision numerical evaluation. Constants include π, e, i (imaginary unit),\ngolden ratio (φ), Euler-Mascheroni constant (γ), infinity, and undefined values.\nAll constants preserve mathematical exactness throughout symbolic computations.\n",
  "mathematical_definition": "**Fundamental Constants:**\n\n- **Pi**: $$\\pi = 3.14159265358979323846\\ldots$$ (ratio of circle's circumference to diameter)\n- **Euler's Number**: $$e = 2.71828182845904523536\\ldots = \\lim_{n \\to \\infty} \\left(1 + \\frac{1}{n}\\right)^n$$\n- **Imaginary Unit**: $$i^2 = -1$$\n- **Golden Ratio**: $$\\varphi = \\frac{1 + \\sqrt{5}}{2} = 1.618033988749895\\ldots$$\n- **Euler-Mascheroni**: $$\\gamma = \\lim_{n \\to \\infty} \\left(\\sum_{k=1}^{n} \\frac{1}{k} - \\ln(n)\\right) = 0.5772156649015329\\ldots$$\n",
  "code_refs": {
    "rust": "mathhook_core::constants",
    "python": "mathhook.constants",
    "nodejs": "mathhook-node.constants"
  },
  "examples": [
    {
      "title": "Using Pi in Expressions",
      "explanation": "Pi constant for exact trigonometric and geometric calculations",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet pi = Expression::pi();\nlet r = symbol!(r);\n\n// Circle area: A = πr²\nlet area = expr!(pi * r^2);\n\n// Circumference: C = 2πr\nlet circumference = expr!(2*pi*r);\n\n// Exact trigonometric values\nassert_eq!(expr!(sin(pi)), expr!(0));\nassert_eq!(expr!(cos(pi)), expr!(-1));\nassert_eq!(expr!(sin(pi/2)), expr!(1));\n",
        "python": "from mathhook import Expression, symbol, expr\n\npi = Expression.pi()\nr = symbol('r')\n\n# Circle area\narea = expr('pi * r^2')\n\n# Circumference\ncircumference = expr('2*pi*r')\n\n# Exact trig values\nassert expr('sin(pi)') == 0\nassert expr('cos(pi)') == -1\nassert expr('sin(pi/2)') == 1\n",
        "nodejs": "const { Expression, symbol, expr } = require('mathhook-node');\n\nconst pi = Expression.pi();\nconst r = symbol('r');\n\n// Circle area\nconst area = expr('pi * r^2');\n\n// Circumference\nconst circumference = expr('2*pi*r');\n\n// Exact trig values\nconsole.assert(expr('sin(pi)').equals(0));\nconsole.assert(expr('cos(pi)').equals(-1));\nconsole.assert(expr('sin(pi/2)').equals(1));\n"
      }
    },
    {
      "title": "Euler's Number (e) and Natural Logarithm",
      "explanation": "Using e for exponential growth and logarithmic identities",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet e = Expression::e();\nlet x = symbol!(x);\n\n// Exponential growth\nlet growth = expr!(e^(r*t));\n\n// Logarithm identities\nassert_eq!(expr!(ln(e)), expr!(1));\nassert_eq!(expr!(ln(e^x)).simplify(), x);\nassert_eq!(expr!(e^(ln(x))).simplify(), x);\n\n// Derivative property: d/dx(e^x) = e^x\nlet exp_x = expr!(e^x);\nassert_eq!(exp_x.derivative(&x, 1), exp_x);\n",
        "python": "from mathhook import Expression, symbol, expr\n\ne = Expression.e()\nx = symbol('x')\n\n# Exponential growth\ngrowth = expr('e^(r*t)')\n\n# Logarithm identities\nassert expr('ln(e)') == 1\nassert expr('ln(e^x)').simplify() == x\nassert expr('e^(ln(x))').simplify() == x\n\n# Derivative property\nexp_x = expr('e^x')\nassert exp_x.derivative(x) == exp_x\n",
        "nodejs": "const { Expression, symbol, expr } = require('mathhook-node');\n\nconst e = Expression.e();\nconst x = symbol('x');\n\n// Exponential growth\nconst growth = expr('e^(r*t)');\n\n// Logarithm identities\nconsole.assert(expr('ln(e)').equals(1));\nconsole.assert(expr('ln(e^x)').simplify().equals(x));\nconsole.assert(expr('e^(ln(x))').simplify().equals(x));\n\n// Derivative property\nconst expX = expr('e^x');\nconsole.assert(expX.derivative(x).equals(expX));\n"
      }
    },
    {
      "title": "Imaginary Unit (i) and Euler's Identity",
      "explanation": "Complex numbers and the most beautiful equation in mathematics",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet i = Expression::i();\n\n// Complex numbers\nlet z = expr!(3 + 4*i);\nlet magnitude = expr!(sqrt((3^2) + (4^2)));\nassert_eq!(magnitude.simplify(), expr!(5));\n\n// Euler's identity: e^(iπ) + 1 = 0\nlet euler_identity = expr!(e^(i*pi) + 1);\nassert_eq!(euler_identity.simplify(), expr!(0));\n\n// Powers of i\nassert_eq!(expr!(i^2).simplify(), expr!(-1));\nassert_eq!(expr!(i^3).simplify(), expr!(-i));\nassert_eq!(expr!(i^4).simplify(), expr!(1));\n",
        "python": "from mathhook import Expression, expr\n\ni = Expression.i()\n\n# Complex numbers\nz = expr('3 + 4*i')\nmagnitude = expr('sqrt(3^2 + 4^2)')\nassert magnitude.simplify() == 5\n\n# Euler's identity\neuler = expr('e^(i*pi) + 1')\nassert euler.simplify() == 0\n\n# Powers of i\nassert expr('i^2').simplify() == -1\nassert expr('i^3').simplify() == expr('-i')\nassert expr('i^4').simplify() == 1\n",
        "nodejs": "const { Expression, expr } = require('mathhook-node');\n\nconst i = Expression.i();\n\n// Complex numbers\nconst z = expr('3 + 4*i');\nconst magnitude = expr('sqrt(3^2 + 4^2)');\nconsole.assert(magnitude.simplify().equals(5));\n\n// Euler's identity\nconst euler = expr('e^(i*pi) + 1');\nconsole.assert(euler.simplify().equals(0));\n\n// Powers of i\nconsole.assert(expr('i^2').simplify().equals(-1));\nconsole.assert(expr('i^3').simplify().equals(expr('-i')));\nconsole.assert(expr('i^4').simplify().equals(1));\n"
      }
    },
    {
      "title": "Golden Ratio and Fibonacci Connection",
      "explanation": "Golden ratio in geometry and its relationship to Fibonacci sequence",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet phi = Expression::golden_ratio();\n\n// Exact form: φ = (1 + √5) / 2\nlet phi_exact = expr!((1 + sqrt(5)) / 2);\nassert_eq!(phi.simplify(), phi_exact.simplify());\n\n// Golden ratio property: φ² = φ + 1\nassert_eq!(expr!(phi^2).simplify(), expr!(phi + 1));\n\n// Fibonacci limit: lim F(n+1)/F(n) = φ\n// φ ≈ 1.618033988749895\n",
        "python": "from mathhook import Expression, expr\n\nphi = Expression.golden_ratio()\n\n# Exact form\nphi_exact = expr('(1 + sqrt(5)) / 2')\nassert phi.simplify() == phi_exact.simplify()\n\n# Golden ratio property\nassert expr('phi^2').simplify() == expr('phi + 1')\n\n# Numerical value\n# φ ≈ 1.618033988749895\n",
        "nodejs": "const { Expression, expr } = require('mathhook-node');\n\nconst phi = Expression.goldenRatio();\n\n// Exact form\nconst phiExact = expr('(1 + sqrt(5)) / 2');\nconsole.assert(phi.simplify().equals(phiExact.simplify()));\n\n// Golden ratio property\nconsole.assert(expr('phi^2').simplify().equals(expr('phi + 1')));\n"
      }
    },
    {
      "title": "Infinity and Undefined Values",
      "explanation": "Working with unbounded limits and indeterminate forms",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet inf = Expression::infinity();\nlet neg_inf = Expression::negative_infinity();\n\n// Defined operations\nassert_eq!(expr!(infinity + 1), expr!(infinity));\nassert_eq!(expr!(infinity * 2), expr!(infinity));\nassert_eq!(expr!(1 / infinity).simplify(), expr!(0));\n\n// Limits\nlet x = symbol!(x);\nlet limit = expr!(lim(1/x, x, infinity));\nassert_eq!(limit.simplify(), expr!(0));\n\n// Undefined forms (indeterminate)\n// infinity - infinity → Undefined\n// infinity / infinity → Undefined\n// 0 * infinity → Undefined\n",
        "python": "from mathhook import Expression, symbol, expr\n\ninf = Expression.infinity()\n\n# Defined operations\nassert expr('infinity + 1') == inf\nassert expr('infinity * 2') == inf\nassert expr('1 / infinity').simplify() == 0\n\n# Limits\nx = symbol('x')\nlimit = expr('lim(1/x, x, infinity)')\nassert limit.simplify() == 0\n\n# Indeterminate forms return Undefined\n",
        "nodejs": "const { Expression, symbol, expr } = require('mathhook-node');\n\nconst inf = Expression.infinity();\n\n// Defined operations\nconsole.assert(expr('infinity + 1').equals(inf));\nconsole.assert(expr('infinity * 2').equals(inf));\nconsole.assert(expr('1 / infinity').simplify().equals(0));\n\n// Limits\nconst x = symbol('x');\nconst limit = expr('lim(1/x, x, infinity)');\nconsole.assert(limit.simplify().equals(0));\n"
      }
    },
    {
      "title": "Real-World Physics: Harmonic Motion",
      "explanation": "Using π and e in simple harmonic oscillator equations",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Simple harmonic oscillator: x(t) = A*cos(ω*t + φ)\nlet t = symbol!(t);\nlet A = expr!(2);\nlet omega = expr!(pi);\nlet phi = expr!(pi/4);\n\nlet position = expr!(A * cos(omega*t + phi));\nlet velocity = position.derivative(&t, 1);\nlet acceleration = velocity.derivative(&t, 1);\n\n// Verify: a = -ω²x\nassert_eq!(acceleration, expr!(-(omega^2) * position));\n",
        "python": "from mathhook import symbol, expr\n\n# Harmonic oscillator\nt = symbol('t')\nposition = expr('2 * cos(pi*t + pi/4)')\nvelocity = position.derivative(t)\nacceleration = velocity.derivative(t)\n\n# Verify differential equation\nomega = expr('pi')\n# a = -ω²x\n",
        "nodejs": "const { symbol, expr } = require('mathhook-node');\n\n// Harmonic oscillator\nconst t = symbol('t');\nconst position = expr('2 * cos(pi*t + pi/4)');\nconst velocity = position.derivative(t);\nconst acceleration = velocity.derivative(t);\n\n// Verify: a = -ω²x\n"
      }
    }
  ],
  "use_cases": [
    "Geometry: circle area, circumference, spherical coordinates",
    "Calculus: limits, derivatives, integrals involving π and e",
    "Complex analysis: Euler's formula, complex exponentials",
    "Number theory: golden ratio, Fibonacci sequences",
    "Physics: harmonic motion, wave equations, quantum mechanics"
  ],
  "related_topics": [
    "core.expressions",
    "core.functions",
    "core.symbols-numbers",
    "advanced.complex-numbers"
  ],
  "performance": {
    "complexity": "O(1) for constant lookup and creation",
    "typical_time": "< 10ns for constant access"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}