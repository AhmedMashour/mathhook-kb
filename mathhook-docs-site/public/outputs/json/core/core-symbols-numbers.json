{
  "topic": "core.symbols-numbers",
  "title": "Symbols and Numbers",
  "description": "Symbols represent mathematical variables (x, y, θ, etc.) using efficient string interning.\nNumbers support integers, rationals, floats, and complex numbers with exact symbolic representation\nfor precise mathematical computation.\n",
  "code_refs": {
    "rust": "mathhook_core::expression::Symbol, mathhook_core::number::Number",
    "python": "mathhook.Symbol, mathhook.Number",
    "nodejs": "mathhook-node.Symbol, mathhook-node.Number"
  },
  "examples": [
    {
      "title": "Symbol Creation and Equality",
      "explanation": "Creating symbols with string interning for O(1) equality checks",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x1 = symbol!(x);\nlet x2 = symbol!(x);\nlet y = symbol!(y);\n\n// O(1) pointer comparison\nassert_eq!(x1, x2);\nassert_ne!(x1, y);\n",
        "python": "from mathhook import symbol\n\nx1 = symbol('x')\nx2 = symbol('x')\ny = symbol('y')\n\n# Fast equality check\nassert x1 == x2\nassert x1 != y\n",
        "nodejs": "const { symbol } = require('mathhook-node');\n\nconst x1 = symbol('x');\nconst x2 = symbol('x');\nconst y = symbol('y');\n\n// Fast equality check\nconsole.assert(x1.equals(x2));\nconsole.assert(!x1.equals(y));\n"
      }
    },
    {
      "title": "Exact Rational Arithmetic",
      "explanation": "Using rationals for exact fractional computation",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// Exact: 1/3\nlet third = Expression::rational(1, 3);\nlet result = expr!(3 * third);\nassert_eq!(result, Expression::integer(1));\n\n// Auto-reduction: 6/4 = 3/2\nlet frac = Expression::rational(6, 4);\nassert_eq!(frac, Expression::rational(3, 2));\n",
        "python": "from mathhook import Expression, expr\n\n# Exact: 1/3\nthird = Expression.rational(1, 3)\nresult = expr('3 * third')\nassert result == Expression.integer(1)\n\n# Auto-reduction: 6/4 = 3/2\nfrac = Expression.rational(6, 4)\nassert frac == Expression.rational(3, 2)\n",
        "nodejs": "const { Expression, expr } = require('mathhook-node');\n\n// Exact: 1/3\nconst third = Expression.rational(1, 3);\nconst result = expr('3 * third');\nconsole.assert(result.equals(Expression.integer(1)));\n\n// Auto-reduction: 6/4 = 3/2\nconst frac = Expression.rational(6, 4);\nconsole.assert(frac.equals(Expression.rational(3, 2)));\n"
      }
    },
    {
      "title": "Complex Numbers",
      "explanation": "Working with complex numbers and imaginary unit",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// 3 + 4i\nlet z = Expression::complex(\n    Expression::integer(3),\n    Expression::integer(4)\n);\n\n// Magnitude: |z| = sqrt(3^2 + 4^2) = 5\nlet magnitude = expr!(sqrt((3^2) + (4^2)));\nassert_eq!(magnitude.simplify(), Expression::integer(5));\n",
        "python": "from mathhook import Expression, expr\n\n# 3 + 4i\nz = Expression.complex(3, 4)\n\n# Magnitude: |z| = 5\nmagnitude = expr('sqrt(3^2 + 4^2)')\nassert magnitude.simplify() == Expression.integer(5)\n",
        "nodejs": "const { Expression, expr } = require('mathhook-node');\n\n// 3 + 4i\nconst z = Expression.complex(3, 4);\n\n// Magnitude: |z| = 5\nconst magnitude = expr('sqrt(3^2 + 4^2)');\nconsole.assert(magnitude.simplify().equals(Expression.integer(5)));\n"
      }
    }
  ],
  "article": {
    "content": "# Symbols and Numbers\n\nThis chapter covers the two fundamental building blocks of expressions: symbols (variables) and numbers.\n\n## Symbols\n\nSymbols represent mathematical variables like $$x$$, $$y$$, $$\\theta$$, etc.\n\n### Creating Symbols\n\n```rust\nuse mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet y = symbol!(y);\nlet theta = symbol!(theta);\n```\n\n### Symbol Equality\n\nSymbols with the same name are considered equal:\n\n```rust\nassert_eq!(symbol!(x), symbol!(x));\nassert_ne!(symbol!(x), symbol!(y));\n```\n\n### String Interning\n\nMathHook uses string interning for symbols, making equality checks O(1) pointer comparisons.\n\n## Why This Design?\n\n### Why String Interning for Symbols?\n\n**Design Decision**: Symbol names are stored in a global intern table, with symbols holding only a reference.\n\n**Why?**\n- **Fast equality**: Comparing two symbols is a single pointer comparison (O(1))\n- **Memory efficiency**: Symbol name \"x\" stored once, shared by all `symbol!(x)` instances\n- **Cache-friendly**: Symbols are just pointers (8 bytes on 64-bit systems)\n\n**Without Interning**: Every `symbol!(x)` would store its own copy of \"x\" and require string comparison (O(n))\n\n**Trade-off**: Global mutable state for intern table\n- Thread-safe using locks or lock-free data structures\n- One-time cost on first use of each symbol name\n- Benefit far outweighs cost (10-100x faster symbol comparison)\n\n**Example**:\n```rust\nlet x1 = symbol!(x);\nlet x2 = symbol!(x);\n// Same pointer internally - O(1) comparison\nassert_eq!(x1, x2);\n```\n\n**When This Matters**:\n- Pattern matching with many symbol comparisons\n- Substitution operations\n- Expression equality checking\n- Hash table lookups\n\n---\n\n## Numbers\n\nMathHook supports multiple number types for different use cases.\n\n### Integers\n\nArbitrary precision integers for exact computation:\n\n```rust\nlet n = Expression::integer(123456789);\nlet large = Expression::integer(9999999999999999999); // Arbitrary precision\n```\n\n### Rationals\n\nExact representation of fractions:\n\n```rust\nlet frac = Expression::rational(22, 7);  // 22/7 ≈ π\nlet half = Expression::rational(1, 2);   // 1/2\n\n// Always in reduced form\nlet six_fourths = Expression::rational(6, 4);  // Automatically becomes 3/2\n```\n\n### Floats\n\nFloating-point numbers for approximate computation:\n\n```rust\nlet pi_approx = Expression::float(3.14159265359);\nlet e_approx = Expression::float(2.71828182846);\n```\n\n**Warning**: Use floats only when approximation is acceptable. Prefer rationals for exact arithmetic.\n\n## Why Rational Numbers Over Floats?\n\n### Design Decision: Exact Rational Arithmetic\n\n**Why MathHook Uses Rationals for Symbolic Math**:\n\n**The Problem with Floats**:\n```rust\n// Using floats (WRONG for symbolic math)\nlet third = 0.33333333;\nlet result = 3.0 * third;\n// Result: 0.99999999 (imprecise)\n\n// Using rationals (CORRECT for symbolic math)\nlet third = Expression::rational(1, 3);\nlet result = expr!(3 * third);\n// Result: 1 (exact)\n```\n\n**Why?**\n- **Mathematical correctness**: `1/3` is exactly `1/3`, not an approximation\n- **Symbolic operations**: Algebra requires exactness (cannot lose precision)\n- **Accumulation prevention**: No rounding error buildup\n- **Comparison reliability**: Exact equality testing\n\n**When We Use Floats**:\n- Only for numerical approximation (explicit `.evalf()`)\n- Only when exact representation is impossible (e.g., transcendental results)\n- **NEVER** in symbolic operations\n\n**Real-World Example**:\n```rust\n// Solving x^2 - 2 = 0 symbolically\nlet x = symbol!(x);\nlet eq = expr!((x ^ 2) - 2);\nlet solutions = eq.solve(&x);\n// Solutions: [-√2, √2] (exact symbolic form)\n// NOT: [-1.414213562, 1.414213562] (approximate floats)\n```\n\n**Alternative Considered**: Always use floats (like numerical libraries)\n- **Pros**: Simpler implementation, predictable memory usage\n- **Cons**: Catastrophic for symbolic algebra (precision loss, equality breaks)\n- **Decision**: Exact arithmetic is non-negotiable for CAS\n\n**Why This Matters**:\n- Computer algebra requires exactness by definition\n- SymPy and Mathematica use same approach\n- Prevents subtle bugs from rounding errors\n- Enables reliable symbolic simplification\n\n**Performance Impact**:\n- Rational arithmetic is slower than float (2-10x)\n- Acceptable trade-off for correctness\n- Use `.evalf()` when you need speed and can tolerate approximation\n\n---\n\n### Why 16-Byte Number Type?\n\n**Design Decision**: The `Number` type is exactly 16 bytes.\n\n**Why?**\n- **Cache efficiency**: Two numbers fit in a 32-byte expression\n- **Tagged union**: Discriminant + data in 16 bytes\n- **Balance**: Small enough for cache, large enough for pointer + metadata\n\n**Structure**:\n```\n[1 byte: type tag] [15 bytes: data]\n- Integer: pointer to BigInt (8 bytes) + padding\n- Rational: two pointers to BigInt numerator/denominator (need clever packing)\n- Float: f64 (8 bytes) + padding\n- Complex: pointer to ComplexData (8 bytes) + padding\n```\n\n**Trade-off**: Arbitrary precision requires heap allocation\n- Small integers (i64) could fit inline, but design consistency favors uniform handling\n- Large integers/rationals use `BigInt` on heap (pointer stored in 16 bytes)\n\n**Alternative Considered**: Variable-size numbers\n- **Pros**: i64 could be inline (faster)\n- **Cons**: Variable size breaks expression size constraint\n- **Decision**: Uniform 16-byte size maintains expression size guarantee\n\n---\n\n### Complex Numbers\n\nComplex numbers with real and imaginary parts:\n\n```rust\n// 3 + 4i\nlet z = Expression::complex(\n    Expression::integer(3),\n    Expression::integer(4)\n);\n\n// Or using addition\nlet z = expr!(3 + (4 * Expression::i()));\n```\n\n## Number Operations\n\n### Arithmetic\n\n```rust\nlet a = Expression::integer(2);\nlet b = Expression::integer(3);\n\nlet sum = expr!(a + b);      // 5\nlet product = expr!(a * b);  // 6\nlet power = Expression::pow(a.clone(), b.clone());          // 8\n```\n\n### Exact vs Approximate\n\n```rust\n// Exact: Use rationals\nlet exact = Expression::rational(1, 3);\nlet tripled = expr!(exact * 3);\n// Result: 1 (exact)\n\n// Approximate: Use floats\nlet approx = Expression::float(0.333333);\nlet tripled_approx = expr!(approx * 3.0);\n// Result: 0.999999 (approximate)\n```\n\n## Type Conversions\n\n### To Float\n\n```rust\nlet rational = Expression::rational(1, 3);\nlet as_float = rational.to_float();  // 0.333...\n```\n\n### To Rational\n\n```rust\nlet float = Expression::float(0.5);\nlet as_rational = float.to_rational();  // 1/2 (if representable)\n```\n\n## Mathematical Constants\n\nPre-defined constants are available:\n\n```rust\nlet pi = Expression::pi();           // π\nlet e = Expression::e();             // e\nlet i = Expression::i();             // i (imaginary unit)\nlet phi = Expression::golden_ratio(); // φ = (1 + √5) / 2\nlet gamma = Expression::euler_gamma(); // γ (Euler-Mascheroni constant)\n```\n\n## Next Steps\n\n- [Functions](./functions.md)\n- [Constants](./constants.md)\n- [Mathematical Operations](../operations/simplification.md)\n"
  },
  "use_cases": [
    "Variable representation in algebraic expressions",
    "Exact fractional arithmetic avoiding floating-point errors",
    "Complex number computations in engineering and physics",
    "High-precision mathematical calculations"
  ],
  "related_topics": [
    "core.expressions",
    "core.constants",
    "core.functions"
  ],
  "performance": {
    "complexity": "O(1) for symbol creation/comparison, O(1) for number operations",
    "typical_time": "< 10ns for symbol operations, < 50ns for rational arithmetic"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}