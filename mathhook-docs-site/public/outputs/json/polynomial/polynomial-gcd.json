{
  "topic": "polynomial.gcd",
  "title": "GCD Algorithms",
  "description": "Multiple GCD (Greatest Common Divisor) algorithms for polynomials, optimized for different use cases\nincluding univariate, multivariate, and modular GCD using Zippel's algorithm.\n",
  "mathematical_definition": "For polynomials $f, g \\in R[x]$ over a ring $R$, the greatest common divisor $\\gcd(f, g)$ is the\nmonic polynomial $d$ of maximum degree such that:\n\n$$d \\mid f \\quad \\text{and} \\quad d \\mid g$$\n\nand for any other polynomial $h$ where $h \\mid f$ and $h \\mid g$, we have $h \\mid d$.\n\n**Euclidean Algorithm**: For univariate polynomials over a field:\n\n$$\\gcd(f, g) = \\begin{cases}\nf & \\text{if } g = 0 \\\\\n\\gcd(g, f \\bmod g) & \\text{otherwise}\n\\end{cases}$$\n\n**Zippel's Modular Algorithm**:\n1. Extract content: $f = c_f \\cdot f_p$, $g = c_g \\cdot g_p$\n2. Compute $\\gcd(f_p, g_p)$ in $\\mathbb{Z}_p[x]$ for prime $p$\n3. Use CRT to reconstruct $\\gcd$ in $\\mathbb{Z}[x]$\n",
  "code_refs": {
    "rust": "mathhook_core::polynomial::algorithms::gcd",
    "python": "mathhook.polynomial.algorithms.gcd",
    "nodejs": "mathhook.polynomial.algorithms.gcd"
  },
  "examples": [
    {
      "title": "General-Purpose GCD",
      "explanation": "Use PolynomialGcdOps trait for automatic algorithm selection",
      "code": {
        "rust": "use mathhook_core::core::polynomial::PolynomialGcdOps;\nuse mathhook_core::{expr, symbol};\n\nlet x = symbol!(x);\n\n// f = x^2 - 1 = (x-1)(x+1)\nlet f = expr!((x ^ 2) - 1);\n// g = x^2 - 2x + 1 = (x-1)^2\nlet g = expr!((x ^ 2) - (2 * x) + 1);\n\n// Compute GCD\nlet gcd = f.polynomial_gcd(&g).unwrap();\n// gcd = x - 1\n\n// Compute LCM\nlet lcm = f.polynomial_lcm(&g).unwrap();\n// lcm = (x-1)^2(x+1)\n",
        "python": "from mathhook import expr, symbol\nfrom mathhook.polynomial import PolynomialOps\n\nx = symbol('x')\n\n# f = x^2 - 1 = (x-1)(x+1)\nf = expr('x^2 - 1')\n# g = x^2 - 2x + 1 = (x-1)^2\ng = expr('x^2 - 2*x + 1')\n\n# Compute GCD\ngcd = f.polynomial_gcd(g)\n# gcd = x - 1\n\n# Compute LCM\nlcm = f.polynomial_lcm(g)\n# lcm = (x-1)^2(x+1)\n",
        "nodejs": "const { expr, symbol } = require('mathhook');\n\nconst x = symbol('x');\n\n// f = x^2 - 1 = (x-1)(x+1)\nconst f = expr('x^2 - 1');\n// g = x^2 - 2x + 1 = (x-1)^2\nconst g = expr('x^2 - 2*x + 1');\n\n// Compute GCD\nconst gcd = f.polynomialGcd(g);\n// gcd = x - 1\n\n// Compute LCM\nconst lcm = f.polynomialLcm(g);\n// lcm = (x-1)^2(x+1)\n"
      }
    },
    {
      "title": "Univariate Modular GCD with Cofactors",
      "explanation": "Returns GCD and cofactors for Bezout identity verification",
      "code": {
        "rust": "use mathhook_core::core::polynomial::algorithms::zippel_gcd::modular_gcd_univariate;\nuse mathhook_core::{expr, symbol};\n\nlet x = symbol!(x);\nlet f = expr!((x ^ 2) - 1);\nlet g = expr!(x - 1);\n\n// Returns (gcd, cofactor_f, cofactor_g)\nlet (gcd, cof_f, cof_g) = modular_gcd_univariate(&f, &g, &x).unwrap();\n\n// Verify: f = gcd * cof_f, g = gcd * cof_g\n",
        "python": "from mathhook import expr, symbol\nfrom mathhook.polynomial.algorithms import modular_gcd_univariate\n\nx = symbol('x')\nf = expr('x^2 - 1')\ng = expr('x - 1')\n\n# Returns (gcd, cofactor_f, cofactor_g)\ngcd, cof_f, cof_g = modular_gcd_univariate(f, g, x)\n\n# Verify: f = gcd * cof_f, g = gcd * cof_g\n",
        "nodejs": "const { expr, symbol } = require('mathhook');\nconst { modularGcdUnivariate } = require('mathhook/polynomial/algorithms');\n\nconst x = symbol('x');\nconst f = expr('x^2 - 1');\nconst g = expr('x - 1');\n\n// Returns (gcd, cofactor_f, cofactor_g)\nconst [gcd, cofF, cofG] = modularGcdUnivariate(f, g, x);\n\n// Verify: f = gcd * cofF, g = gcd * cofG\n"
      }
    },
    {
      "title": "Multivariate GCD with Zippel Algorithm",
      "explanation": "Compute GCD for polynomials in multiple variables",
      "code": {
        "rust": "use mathhook_core::core::polynomial::algorithms::zippel_gcd::{\n    multivariate_gcd_zippel,\n    MultivariateGcdConfig\n};\nuse mathhook_core::{expr, symbol};\n\nlet x = symbol!(x);\nlet y = symbol!(y);\n\n// f = x*y, g = x*y + x\nlet f = expr!(x * y);\nlet g = expr!((x * y) + x);\n\nlet config = MultivariateGcdConfig::default();\nlet (gcd, _, _) = multivariate_gcd_zippel(&f, &g, &[x, y], config).unwrap();\n// gcd = x\n",
        "python": "from mathhook import expr, symbol\nfrom mathhook.polynomial.algorithms import multivariate_gcd_zippel, MultivariateGcdConfig\n\nx = symbol('x')\ny = symbol('y')\n\n# f = x*y, g = x*y + x\nf = expr('x*y')\ng = expr('x*y + x')\n\nconfig = MultivariateGcdConfig()\ngcd, _, _ = multivariate_gcd_zippel(f, g, [x, y], config)\n# gcd = x\n",
        "nodejs": "const { expr, symbol } = require('mathhook');\nconst { multivariateGcdZippel, MultivariateGcdConfig } = require('mathhook/polynomial/algorithms');\n\nconst x = symbol('x');\nconst y = symbol('y');\n\n// f = x*y, g = x*y + x\nconst f = expr('x*y');\nconst g = expr('x*y + x');\n\nconst config = new MultivariateGcdConfig();\nconst [gcd, _, __] = multivariateGcdZippel(f, g, [x, y], config);\n// gcd = x\n"
      }
    },
    {
      "title": "Content and Primitive Part Decomposition",
      "explanation": "Fundamental operation for GCD computation",
      "code": {
        "rust": "use mathhook_core::core::polynomial::algorithms::zippel_gcd::{\n    extract_content,\n    primitive_part\n};\n\nlet coeffs = vec![6, 12, 18];  // 6 + 12x + 18x^2\n\n// Extract content (GCD of coefficients)\nlet content = extract_content(&coeffs);  // 6\n\n// Get primitive part\nlet (cont, pp) = primitive_part(&coeffs);  // (6, [1, 2, 3])\n",
        "python": "from mathhook.polynomial.algorithms import extract_content, primitive_part\n\ncoeffs = [6, 12, 18]  # 6 + 12x + 18x^2\n\n# Extract content (GCD of coefficients)\ncontent = extract_content(coeffs)  # 6\n\n# Get primitive part\ncont, pp = primitive_part(coeffs)  # (6, [1, 2, 3])\n",
        "nodejs": "const { extractContent, primitivePart } = require('mathhook/polynomial/algorithms');\n\nconst coeffs = [6, 12, 18];  // 6 + 12x + 18x^2\n\n// Extract content (GCD of coefficients)\nconst content = extractContent(coeffs);  // 6\n\n// Get primitive part\nconst [cont, pp] = primitivePart(coeffs);  // (6, [1, 2, 3])\n"
      }
    }
  ],
  "article": {
    "content": "MathHook provides multiple GCD (Greatest Common Divisor) algorithms for polynomials, optimized for different use cases.\n\n## Algorithm Selection Guide\n\n### Quick Decision Tree\n\n```\nNeed GCD of two polynomials?\n├─ Both are i64 integers? → integer_gcd(a, b)\n├─ Don't know the structure? → polynomial_gcd(&p1, &p2)\n├─ Single variable (x)? → univariate_gcd(&p1, &p2, &x)\n├─ Need cofactors too? → modular_gcd_univariate(&p1, &p2, &x)\n└─ Multiple variables (x, y, z)? → multivariate_gcd(&p1, &p2, &[x, y, z])\n```\n\n## Zippel's Modular GCD Algorithm\n\nFor performance-critical applications, the Zippel algorithm provides industrial-strength GCD computation using modular arithmetic.\n\n### How It Works\n\n1. **Content Extraction**: Separate integer content from primitive parts\n2. **Prime Selection**: Choose primes that don't divide leading coefficients\n3. **Modular GCD**: Compute GCD in Z_p[x] using Euclidean algorithm\n4. **CRT Reconstruction**: Combine results from multiple primes using Chinese Remainder Theorem\n5. **Trial Division**: Verify the result divides both inputs\n\n### Configuration Options\n\n- **max_eval_points**: Maximum number of evaluation points per variable\n- **use_sparse**: Whether to use sparse optimization\n- **starting_prime_idx**: Prime index to start with\n\n## Performance Characteristics\n\n| Algorithm | Complexity | Best For |\n|-----------|------------|----------|\n| Integer GCD | O(log(min(a,b))) | Small integers |\n| Univariate Modular | O(d^2) | Single variable polynomials |\n| Multivariate Zippel | O(d^n) | Sparse multivariate |\n| Groebner-based | Doubly exponential | Ideal membership |\n\nWhere `d` is degree and `n` is number of variables.\n"
  },
  "use_cases": [
    "Polynomial simplification via GCD extraction",
    "Computing LCM for rational function operations",
    "Modular arithmetic for efficient large polynomial GCD",
    "Multivariate polynomial system solving"
  ],
  "related_topics": [
    "polynomial.overview",
    "polynomial.finite-field",
    "polynomial.division"
  ],
  "performance": {
    "complexity": "O(d^2) for univariate, O(d^n) for multivariate",
    "typical_time": "1-10ms for degree 100 univariate polynomials"
  },
  "metadata": {
    "schema_version": "1.0",
    "last_updated": "2025-12-15T14:30:00Z"
  }
}