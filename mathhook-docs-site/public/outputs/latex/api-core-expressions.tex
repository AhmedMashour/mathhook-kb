\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

\title{ Core Expression System }
\author{MathHook CAS}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
The Expression type is the foundation of MathHook. Expressions are immutable,
32-byte cache-optimized structures representing mathematical constructs from
numbers to complex symbolic operations.

\end{abstract}




\section{Introduction}

# Core Expression System

## Overview

The `Expression` type is MathHook's core data structure, designed for:
- **Immutability**: Thread-safe, predictable behavior
- **Performance**: 32-byte size for cache optimization (2 per cache line)
- **Canonical Forms**: Automatic normalization for equality checking

## Expression Structure

Expressions use Rust enums for type-safe mathematical constructs:
- **Numbers**: Integer, Rational, Float, Complex
- **Variables**: Symbol
- **Operations**: Add, Mul, Pow
- **Functions**: Function calls (sin, cos, log, etc.)
- **Constants**: π, e, i, φ, γ
- **Matrices**: Matrix (noncommutative)
- **Relations**: Equation, Inequality

## Design Decisions

### Why 32 Bytes?
- Modern CPUs have 64-byte cache lines
- Two expressions fit perfectly in one cache line
- 3-5x faster operations in hot loops
- Critical for CAS workloads with millions of expression traversals

### Why Immutable?
- Thread safety without locks
- No hidden mutation surprises
- Compiler optimizations
- Traceable expression history

### Why Canonical Forms?
- Structural equality: y + x → x + y
- Flattening: (a + b) + c → Add(a, b, c)
- Identity removal: x + 0 → x
- Rational reduction: 6/4 → 3/2





\section{Examples}


\subsection{ Creating Expressions with Macros }

Use expr!() and symbol!() macros for ergonomic expression creation

\begin{lstlisting}
from mathhook import symbol, expr

x = symbol('x')
y = symbol('y')

# Basic arithmetic
sum_expr = x + y
product = x * y
power = x**2

# Complex nested expressions
from mathhook import sin, cos
complex_expr = sin(x**2) + cos(y**2)

\end{lstlisting}




\subsection{ Immutability and Operations }

All operations return new expressions, original unchanged

\begin{lstlisting}
expr = x + 1
doubled = expr * 2  # Returns new expression
# expr is unchanged - still x + 1

# Safe for concurrent use
import threading
shared_expr = x**2

\end{lstlisting}




\subsection{ Canonical Forms and Equality }

Automatic normalization ensures equivalent expressions are equal

\begin{lstlisting}
expr1 = x + y
expr2 = y + x
assert expr1 == expr2  # True - both normalized to x + y

# Flattening and identity removal
nested = (x + y) + z
identity = x + 0
assert identity.simplify() == x

\end{lstlisting}




\subsection{ Pattern Matching and Structure }

Work with expression structure using pattern matching

\begin{lstlisting}
from mathhook import Expression

# Python uses method introspection
if expr.is_add():
    terms = expr.get_terms()
    print(f"Sum with {len(terms)} terms")
elif expr.is_mul():
    factors = expr.get_factors()
    print(f"Product with {len(factors)} factors")
elif expr.is_pow():
    base, exp = expr.get_base_exp()
    print(f"Power: {base} ^ {exp}")

\end{lstlisting}







\end{document}
