\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

\title{ Groebner Bases }
\author{MathHook CAS}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Groebner bases are fundamental tools in computational algebraic geometry for working with polynomial ideals,
enabling ideal membership testing, polynomial system solving, variable elimination, and geometric theorem proving.

\end{abstract}


\section{Mathematical Definition}

\begin{equation}
**Groebner Basis Definition**: A set $G = \{g_1, \ldots, g_m\}$ is a Groebner basis for ideal $I$
with respect to monomial order $<$ if:

$$\langle \text{LT}(g_1), \ldots, \text{LT}(g_m) \rangle = \langle \text{LT}(I) \rangle$$

where $\text{LT}$ denotes the leading term and $\langle \cdot \rangle$ denotes the ideal generated.

**S-Polynomial**: The S-polynomial of $f$ and $g$ is:

$$S(f,g) = \frac{\text{lcm}(\text{LT}(f), \text{LT}(g))}{\text{LT}(f)} \cdot f - \frac{\text{lcm}(\text{LT}(f), \text{LT}(g))}{\text{LT}(g)} \cdot g$$

**Buchberger's Criterion**: $G$ is a Groebner basis if and only if for all pairs $g_i, g_j \in G$:

$$S(g_i, g_j) \xrightarrow{G}_+ 0$$

(i.e., $S(g_i, g_j)$ reduces to 0 modulo $G$)

**Monomial Orders**:
- **Lex**: $x^\alpha > x^\beta \iff$ first non-zero entry of $\alpha - \beta$ is positive
- **Grlex**: Total degree first, then lex
- **Grevlex**: Total degree first, then reverse lex from right

\end{equation}



\section{Introduction}

Groebner bases are a fundamental tool in computational algebraic geometry for working with polynomial ideals.

## Overview

A Groebner basis is a special generating set for a polynomial ideal that has many useful computational properties:

- **Ideal Membership Testing**: Determine if a polynomial belongs to an ideal
- **Polynomial System Solving**: Find common solutions to systems of polynomial equations
- **Variable Elimination**: Eliminate variables from polynomial systems
- **Geometric Theorem Proving**: Prove geometric theorems algebraically

## Monomial Orders

The choice of monomial order affects the structure of the Groebner basis:

| Order | Description | Use Case |
|-------|-------------|----------|
| `Lex` | Lexicographic | Variable elimination |
| `Grlex` | Graded lexicographic | Balanced computation |
| `Grevlex` | Graded reverse lexicographic | Efficient computation |

### Lexicographic Order (Lex)

Compares exponents from left to right:
- $x^2y > xy^2$ (2 > 1 in first position)
- $xy^3 > xz^5$ (y > z in second position)

Best for: Variable elimination, solving systems

### Graded Lexicographic (Grlex)

Compares total degree first, then lexicographic:
- $xy^2 > x^2$ (degree 3 > 2)
- $x^2 > xy$ (same degree, $x^2 > xy$ lexicographically)

Best for: Balanced trade-off between structure and efficiency

### Graded Reverse Lexicographic (Grevlex)

Compares total degree first, then reverse lexicographic from right:
- $xy^2 > x^2y$ (same degree, compare from right)

Best for: Efficient computation (often produces smaller bases)

## Buchberger's Algorithm

The classic algorithm for computing Groebner bases:

### Algorithm Steps

1. **Initialize**: Start with the input polynomials
2. **S-pairs**: For each pair of polynomials, compute the S-polynomial
3. **Reduce**: Reduce each S-polynomial by the current basis
4. **Add**: If reduction is non-zero, add to basis
5. **Repeat**: Continue until no new polynomials are added

## Applications

### Solving Polynomial Systems

Compute a Groebner basis with Lex order to get elimination ideals.

### Ideal Membership

Test if a polynomial belongs to an ideal by checking if its remainder under the
Groebner basis is zero.

### Elimination

With Lex order x > y > z, the Groebner basis contains polynomials in:
- Only z (elimination of x and y)
- y and z (elimination of x)
- x, y, and z





\section{Examples}


\subsection{ Basic Groebner Basis Computation }

Compute Groebner basis for a polynomial ideal

\begin{lstlisting}
from mathhook import expr, symbol
from mathhook.polynomial.groebner import GroebnerBasis, MonomialOrder

x = symbol('x')
y = symbol('y')

# Define polynomials: f1 = x - y, f2 = y^2 - 1
f1 = expr('x - y')
f2 = expr('y^2 - 1')

# Create Groebner basis
gb = GroebnerBasis(
    [f1, f2],
    [x, y],
    MonomialOrder.Lex
)

# Compute the basis
gb.compute()

print(f"Basis has {len(gb.basis)} polynomials")

\end{lstlisting}




\subsection{ Sparse Polynomial Representation }

Work with sparse polynomials for efficiency

\begin{lstlisting}
from mathhook import expr, symbol
from mathhook.polynomial.groebner import Monomial, expression_to_sparse_polynomial

# Create a monomial x^2 * y (exponents [2, 1])
mono = Monomial([2, 1])
assert mono.degree() == 3

# Convert expression to sparse polynomial
x = symbol('x')
y = symbol('y')
poly = expr('x^2 + y')

vars = [x, y]
sparse = expression_to_sparse_polynomial(poly, vars)

\end{lstlisting}




\subsection{ Polynomial Reduction }

Reduce polynomial by a set of polynomials (division algorithm)

\begin{lstlisting}
from mathhook.polynomial.groebner import poly_reduce, poly_reduce_completely

# Single-step reduction
reduced = poly_reduce(poly, basis, order)

# Complete reduction (until no further reduction possible)
fully_reduced = poly_reduce_completely(poly, basis, order)

\end{lstlisting}




\subsection{ Bidirectional Expression Conversion }

Convert between Expression and sparse polynomial representation

\begin{lstlisting}
from mathhook import expr, symbol
from mathhook.polynomial.groebner import (
    expression_to_sparse_polynomial,
    sparse_polynomial_to_expression
)

x = symbol('x')
y = symbol('y')
vars = [x, y]

# Expression to sparse
e = expr('x^2 + y')
sparse = expression_to_sparse_polynomial(e, vars)

# Sparse back to expression
back = sparse_polynomial_to_expression(sparse, vars)

\end{lstlisting}







\end{document}
