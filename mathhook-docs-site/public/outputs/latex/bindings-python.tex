\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

\title{ Python API Guide }
\author{MathHook CAS}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Complete guide to using MathHook from Python via PyO3 bindings.
Provides comprehensive documentation for the Python API including installation,
quick start, API reference, performance comparisons with SymPy, and integration patterns.

\end{abstract}




\section{Introduction}

# Python API Guide

Complete guide to using MathHook from Python via PyO3 bindings.

## Installation

```bash
pip install mathhook
```

**Requirements**:
- Python 3.8 or higher
- pip 20.0 or higher (for binary wheel support)

**Platform Support**:
- Linux (x86_64, aarch64)
- macOS (Intel, Apple Silicon)
- Windows (x86_64)

## Quick Start

```python
from mathhook import Symbol, parse, simplify

# Create symbols
x = Symbol('x')
y = Symbol('y')

# Build expressions
expr = x**2 + 2*x + 1

# Simplify
simplified = simplify(expr)
print(simplified)  # (x + 1)^2
```

## Why MathHook for Python?

### Performance Comparison

**100x Faster Than SymPy** for large expressions:

```python
import time
from mathhook import parse, simplify

# Large polynomial expression
expr_str = " + ".join([f"{i}*x**{i}" for i in range(100)])

# MathHook
start = time.time()
expr = parse(expr_str)
result = simplify(expr)
mathhook_time = time.time() - start

print(f"MathHook: {mathhook_time:.4f}s")
# Typical: MathHook 0.001s vs SymPy 0.1s (100x faster)
```

### When to Use MathHook vs SymPy

**Use MathHook when**:
- Performance is critical (real-time applications, large expressions)
- You need symbolic preprocessing for numerical simulations
- Working with expressions with >50 terms
- Building interactive applications (web, Jupyter with fast response)

**Use SymPy when**:
- Need advanced features: logic, sets, abstract algebra
- Educational prototyping (rich ecosystem)
- Assumption system is critical
- Working with small expressions where speed doesn't matter

**Use Both**:
- Prototype with SymPy, optimize with MathHook for production
- Use MathHook for hot loops, SymPy for one-time complex operations





\section{Examples}


\subsection{ Basic Symbol Creation and Expression Building }

Create symbols and build expressions using operator overloading

\begin{lstlisting}
from mathhook import Symbol

x = Symbol('x')
y = Symbol('y')

# Arithmetic operators
expr = x**2 + 2*x + 1
expr2 = (x + 1) * (x - 1)
expr3 = x / (x + 1)
expr4 = -x

\end{lstlisting}




\subsection{ Expression Simplification }

Simplify algebraic expressions using MathHook

\begin{lstlisting}
from mathhook import parse, simplify

expr = parse("x + x")
result = simplify(expr)  # 2*x

expr = parse("(x + 1) * (x - 1)")
result = simplify(expr)  # x^2 - 1

\end{lstlisting}




\subsection{ Symbolic Differentiation }

Compute derivatives symbolically

\begin{lstlisting}
from mathhook import Symbol, derivative

x = Symbol('x')
expr = x**3

# First derivative
df = derivative(expr, x)
print(df)  # 3*x^2

# Second derivative
d2f = derivative(expr, x, order=2)
print(d2f)  # 6*x

# Partial derivatives
y = Symbol('y')
expr = x**2 * y
df_dx = derivative(expr, x)  # 2*x*y
df_dy = derivative(expr, y)  # x^2

\end{lstlisting}




\subsection{ Equation Solving }

Solve algebraic equations symbolically

\begin{lstlisting}
from mathhook import Symbol, solve

x = Symbol('x')

# Linear equation: 2*x + 3 = 7
solutions = solve(2*x + 3, 7, x)
print(solutions)  # [x = 2]

# Quadratic equation: x^2 - 5*x + 6 = 0
solutions = solve(x**2 - 5*x + 6, 0, x)
print(solutions)  # [x = 2, x = 3]

# Multiple variables
y = Symbol('y')
solutions = solve([x + y - 5, x - y - 1], [x, y])
print(solutions)  # {x: 3, y: 2}

\end{lstlisting}




\subsection{ Integration with NumPy }

Convert symbolic expressions to NumPy functions for numerical evaluation

\begin{lstlisting}
import numpy as np
from mathhook import Symbol, lambdify

x = Symbol('x')
expr = x**2 + 2*x + 1

# Convert to NumPy-compatible function
f = lambdify(expr, [x], 'numpy')

# Evaluate on NumPy array
x_values = np.linspace(-5, 5, 100)
y_values = f(x_values)

# Use with NumPy operations
mean = np.mean(y_values)
std = np.std(y_values)

\end{lstlisting}




\subsection{ Evaluation with Context }

Advanced evaluation with custom contexts and variable substitutions

\begin{lstlisting}
from mathhook import PyExpression as Expression, EvalContext

x = Expression.symbol("x")
y = Expression.symbol("y")

# Formula: x² + 2xy + y²
expr = x.pow(Expression.integer(2)).add(
    Expression.integer(2).multiply(x).multiply(y)
).add(y.pow(Expression.integer(2)))

# Create numerical context with variable substitutions
ctx = EvalContext.numeric({
    "x": Expression.integer(3),
    "y": Expression.integer(4)
})

# Evaluate: (3)² + 2(3)(4) + (4)² = 9 + 24 + 16 = 49
result = expr.evaluate_with_context(ctx)
print(result)  # 49

# Symbolic evaluation (no numerical conversion)
ctx_symbolic = EvalContext.symbolic()
result_symbolic = expr.evaluate_with_context(ctx_symbolic)
print(result_symbolic)  # x^2 + 2*x*y + y^2 (still symbolic)

\end{lstlisting}







\end{document}
