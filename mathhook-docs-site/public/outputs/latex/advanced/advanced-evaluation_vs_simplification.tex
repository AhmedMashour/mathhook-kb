\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

\title{ Evaluation vs Simplification }
\author{MathHook CAS}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Understand the critical differences between evaluation (computing numerical results
with domain checking) and simplification (algebraic transformation) in MathHook's
symbolic engine. Knowing when to use each operation is essential for correct
mathematical computation.

\end{abstract}


\section{Mathematical Definition}

\begin{equation}
**Evaluation** maps expressions to numerical values:
$$\text{eval}: E \times \sigma \to \mathbb{R} \cup \mathbb{C} \cup \{\text{Error}\}$$
where $E$ is the set of expressions and $\sigma$ is a variable substitution.

**Simplification** maps expressions to equivalent canonical forms:
$$\text{simplify}: E \to E \quad \text{such that } \forall e \in E: e \equiv \text{simplify}(e)$$

\end{equation}



\section{Introduction}

# Evaluation vs Simplification

MathHook provides two fundamental operations for working with expressions:

1. **Evaluation** (`evaluate()`, `evaluate_with_context()`) - Compute numerical values
2. **Simplification** (`simplify()`) - Algebraic reduction

## The Key Principle

> **`evaluate()` ≠ `simplify()`** - They serve different purposes and should not be used interchangeably.

| Aspect | Evaluation | Simplification |
|--------|-----------|----------------|
| **Purpose** | Compute numerical values | Reduce algebraic complexity |
| **Input** | Expression (+ optional variables) | Expression only |
| **Output** | Numerical result or error | Simpler symbolic form |
| **Domain Checking** | ✅ Yes (catches mathematical errors) | ❌ No |
| **Substitution** | ✅ Yes (with context) | ❌ No |
| **Error Handling** | `Result<Expression, MathError>` | `Expression` |

## Core Concepts

### Evaluation: Numerical Computation

Evaluation converts symbolic expressions into concrete numerical values with
domain checking:

- **Domain Checking**: Catches mathematical errors (sqrt(-1), log(0), division by zero)
- **Recursive Evaluation**: Evaluates entire expression tree
- **Error Propagation**: Errors bubble up from nested expressions

### Simplification: Algebraic Reduction

Simplification transforms expressions into equivalent but simpler symbolic forms:

- **Algebraic Equivalence**: Output is mathematically equivalent to input
- **No Domain Checking**: Operates purely symbolically
- **Idempotency**: Simplifying twice yields the same result

## Decision Guide

### Use `evaluate()` when:
- You need a numerical result
- You want domain validation
- Expression contains only constants

### Use `evaluate_with_context()` when:
- Expression contains variables you need to substitute
- You want control over evaluation behavior
- You're solving equations or evaluating formulas

### Use `simplify()` when:
- You need algebraic reduction
- You want to reduce expression complexity
- You're preparing for symbolic operations

## Common Pitfalls

### ❌ Expecting Numbers from `simplify()`
```rust
let x = symbol!(x);
let result = expr!(x + x).simplify();
// Returns: 2*x (still symbolic, NOT a number!)
```

### ❌ Using `evaluate()` Without Substitution
```rust
let x = symbol!(x);
let result = expr!(x + 1).evaluate().unwrap();
// Returns: x + 1 (symbolic, can't substitute without context)
```

### ❌ Ignoring Domain Errors
```rust
let result = expr!(sqrt(-1)).evaluate().unwrap(); // PANIC!
// Always handle Result properly
```





\section{Examples}


\subsection{ Basic Evaluation vs Simplification }

Shows the fundamental difference between the two operations

\begin{lstlisting}
from mathhook import symbol, expr

# Simplify: algebraic reduction
x = symbol('x')
simplified = (x + x + x).simplify()
# Result: 3*x (still symbolic)

# Evaluate: numerical computation
result = expr('2 + 3').evaluate()
# Result: 5 (numerical value)

\end{lstlisting}




\subsection{ Evaluation with Variable Substitution }

Using evaluate_with_context for variable substitution

\begin{lstlisting}
from mathhook import symbol, expr, EvalContext

x = symbol('x')
y = symbol('y')

# Create context with variable values
ctx = EvalContext({'x': 3, 'y': 4})

# Evaluate x² + 2xy + y² at (x=3, y=4)
formula = x**2 + 2*x*y + y**2
result = formula.evaluate_with_context(ctx)
# Result: 49  (which is (3+4)²)

\end{lstlisting}




\subsection{ Domain Error Handling }

Evaluation catches mathematical domain errors

\begin{lstlisting}
from mathhook import expr, MathError

# sqrt(-1) triggers domain error
try:
    result = expr('sqrt(-1)').evaluate()
except MathError as e:
    print(f"Domain error: {e}")

# log(0) triggers domain error
try:
    result = expr('log(0)').evaluate()
except MathError as e:
    print(f"Domain error: {e}")

\end{lstlisting}




\subsection{ Simplification for Algebraic Manipulation }

Simplification applies algebraic identities without domain checking

\begin{lstlisting}
from mathhook import symbol, expr, simplify

x = symbol('x')

# Combine like terms
assert simplify(x + x + x) == 3*x

# Remove identity elements
assert simplify(x * 1) == x
assert simplify(x + 0) == x

# Zero propagation
assert simplify(0 * x) == 0

# Trigonometric identities
from mathhook import sin, cos
assert simplify(sin(x)**2 + cos(x)**2) == 1

\end{lstlisting}







\end{document}
