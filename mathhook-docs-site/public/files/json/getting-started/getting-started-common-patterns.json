{
  "topic": "getting-started.common-patterns",
  "title": "Common Patterns",
  "description": "Common patterns and best practices when using MathHook, including macro usage\nguidelines, polynomial construction, substitution patterns, function composition,\nmatrix operations, error handling, performance patterns, and educational features.\nIncludes detailed pitfalls to avoid.\n",
  "code_refs": {
    "rust": "mathhook::prelude",
    "python": "mathhook.Expression",
    "nodejs": "mathhook-node.Expression"
  },
  "examples": [
    {
      "title": "Macro Usage - Correct Patterns",
      "explanation": "When to use macros vs explicit API",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// ALWAYS use macros for symbols\nlet x = symbol!(x);  // NOT Symbol::new(\"x\")\n\n// Simple expressions - use macros\nlet expr = expr!(x + y);\nlet expr = expr!(2 * x);\nlet expr = expr!(x ^ 2);\n\n// Function calls - use macros\nlet expr = expr!(sin(x));\n",
        "python": "from mathhook import Expression\n\n# Python uses method chaining\nx = Expression.symbol('x')\ny = Expression.symbol('y')\n\nexpr = x.add(y)\nexpr = Expression.integer(2).mul(x)\nexpr = x.pow(2)\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\n// Node.js uses method chaining\nconst x = Expression.symbol('x');\nconst y = Expression.symbol('y');\n\nconst expr = x.add(y);\nconst expr2 = Expression.integer(2).mul(x);\nconst expr3 = x.pow(2);\n"
      }
    },
    {
      "title": "Runtime Variables - Explicit API Required",
      "explanation": "Why macros don't work with loop variables",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// WRONG - creates Symbol(\"i\"), not integer value\nfor i in 0..10 {\n    let expr = expr!(i);  // BAD!\n}\n\n// CORRECT - use explicit API for runtime variables\nfor i in 0..10 {\n    let term = Expression::integer(i);  // GOOD!\n}\n\n// CORRECT - programmatic construction\nlet x = symbol!(x);\nlet coefficients = vec![1, 2, 3];\nlet mut terms = Vec::new();\nfor i in 0..coefficients.len() {\n    let coeff = Expression::integer(coefficients[i]);\n    let x_expr = Expression::from(x.clone());\n    let power = Expression::integer(i as i64);\n    terms.push(Expression::mul(vec![coeff, Expression::pow(x_expr, power)]));\n}\nlet polynomial = Expression::add(terms);\n",
        "python": "from mathhook import Expression\n\n# Python doesn't have compile-time macros\n# Always use explicit API (which is fine)\n\nx = Expression.symbol('x')\ncoefficients = [1, 2, 3]\nterms = []\nfor i, coeff in enumerate(coefficients):\n    coeff_expr = Expression.integer(coeff)\n    power_expr = Expression.integer(i)\n    term = coeff_expr.mul(x.pow(power_expr))\n    terms.append(term)\npolynomial = Expression.add(terms)\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\n// Node.js doesn't have compile-time macros\n// Always use explicit API\n\nconst x = Expression.symbol('x');\nconst coefficients = [1, 2, 3];\nconst terms = [];\nfor (let i = 0; i < coefficients.length; i++) {\n    const coeffExpr = Expression.integer(coefficients[i]);\n    const powerExpr = Expression.integer(i);\n    const term = coeffExpr.mul(x.pow(powerExpr));\n    terms.push(term);\n}\nconst polynomial = Expression.add(terms);\n"
      }
    },
    {
      "title": "Building Polynomials - Dynamic Degree",
      "explanation": "Construct polynomials with runtime coefficients",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nfn build_polynomial(coefficients: &[i64], x: &Symbol) -> Expression {\n    let mut terms = Vec::new();\n    for (i, &coeff) in coefficients.iter().enumerate() {\n        let coeff_expr = Expression::integer(coeff);\n        let x_expr = Expression::from(x.clone());\n        let power = Expression::integer(i as i64);\n        let term = Expression::mul(vec![coeff_expr, Expression::pow(x_expr, power)]);\n        terms.push(term);\n    }\n    Expression::add(terms)\n}\n\nlet x = symbol!(x);\nlet poly = build_polynomial(&[1, -5, 6], &x);  // x^2 - 5x + 6\n",
        "python": "from mathhook import Expression\n\ndef build_polynomial(coefficients, x):\n    terms = []\n    for i, coeff in enumerate(coefficients):\n        coeff_expr = Expression.integer(coeff)\n        power = Expression.integer(i)\n        term = coeff_expr.mul(x.pow(power))\n        terms.append(term)\n    return Expression.add(terms)\n\nx = Expression.symbol('x')\npoly = build_polynomial([1, -5, 6], x)  # x^2 - 5x + 6\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nfunction buildPolynomial(coefficients: number[], x: Expression): Expression {\n    const terms = [];\n    for (let i = 0; i < coefficients.length; i++) {\n        const coeffExpr = Expression.integer(coefficients[i]);\n        const power = Expression.integer(i);\n        const term = coeffExpr.mul(x.pow(power));\n        terms.push(term);\n    }\n    return Expression.add(terms);\n}\n\nconst x = Expression.symbol('x');\nconst poly = buildPolynomial([1, -5, 6], x);  // x^2 - 5x + 6\n"
      }
    },
    {
      "title": "Substitution - Single and Multiple",
      "explanation": "Replace symbols with values",
      "code": {
        "rust": "use mathhook::prelude::*;\nuse std::collections::HashMap;\n\nlet x = symbol!(x);\nlet y = symbol!(y);\nlet expr = expr!(add: (x * y), x, y);\n\n// Single substitution\nlet mut vars = HashMap::new();\nvars.insert(\"x\".to_string(), Expression::integer(3));\nlet result = expr.substitute(&vars);\n\n// Multiple substitutions\nlet mut vars = HashMap::new();\nvars.insert(\"x\".to_string(), Expression::integer(2));\nvars.insert(\"y\".to_string(), Expression::integer(3));\nlet result = expr.substitute(&vars);\n",
        "python": "from mathhook import Expression\n\nx = Expression.symbol('x')\ny = Expression.symbol('y')\nexpr = x.mul(y).add(x).add(y)\n\n# Single substitution\nvars = {'x': Expression.integer(3)}\nresult = expr.substitute(vars)\n\n# Multiple substitutions\nvars = {'x': Expression.integer(2), 'y': Expression.integer(3)}\nresult = expr.substitute(vars)\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\nconst y = Expression.symbol('y');\nconst expr = x.mul(y).add(x).add(y);\n\n// Single substitution\nconst vars1 = new Map([['x', Expression.integer(3)]]);\nconst result1 = expr.substitute(vars1);\n\n// Multiple substitutions\nconst vars2 = new Map([\n    ['x', Expression.integer(2)],\n    ['y', Expression.integer(3)]\n]);\nconst result2 = expr.substitute(vars2);\n"
      }
    },
    {
      "title": "Function Composition",
      "explanation": "Compose functions by nesting",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// sin(cos(x)) - direct nesting\nlet composed = expr!(sin(cos(x)));\n\n// Or build step by step\nlet inner = expr!(cos(x));\nlet composed_alt = function!(sin, inner);\n\nprintln!(\"Composed function: {}\", composed);\n",
        "python": "from mathhook import Expression\n\nx = Expression.symbol('x')\n\n# Build step by step\ninner = Expression.function('cos', [x])\ncomposed = Expression.function('sin', [inner])\n\nprint(f\"Composed function: {composed}\")\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\n\n// Build step by step\nconst inner = Expression.function('cos', [x]);\nconst composed = Expression.function('sin', [inner]);\n\nconsole.log(`Composed function: ${composed.toString()}`);\n"
      }
    },
    {
      "title": "Performance - Bulk Operations",
      "explanation": "Efficient batch processing",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Simplify many expressions efficiently\nlet expressions = vec![\n    expr!(x + x),\n    expr!(x * 1),\n    expr!(add: (x ^ 2), (-(x ^ 2))),\n];\n\nlet simplified: Vec<_> = expressions\n    .iter()\n    .map(|e| e.simplify())\n    .collect();\n",
        "python": "from mathhook import Expression\n\nx = Expression.symbol('x')\n\n# Simplify many expressions\nexpressions = [\n    x.add(x),\n    x.mul(Expression.integer(1)),\n    x.pow(2).add(x.pow(2).neg())\n]\n\nsimplified = [e.simplify() for e in expressions]\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\n\n// Simplify many expressions\nconst expressions = [\n    x.add(x),\n    x.mul(Expression.integer(1)),\n    x.pow(2).add(x.pow(2).neg())\n];\n\nconst simplified = expressions.map(e => e.simplify());\n"
      }
    },
    {
      "title": "Performance - Caching Results",
      "explanation": "Cache frequently computed expressions",
      "code": {
        "rust": "use mathhook::prelude::*;\nuse std::collections::HashMap;\n\nlet x = symbol!(x);\nlet mut cache: HashMap<String, Expression> = HashMap::new();\n\nlet expr = expr!(x ^ 2);\nlet key = format!(\"{}\", expr);\n\nif let Some(cached) = cache.get(&key) {\n    println!(\"Using cached result\");\n} else {\n    let result = expr.simplify();\n    cache.insert(key, result.clone());\n}\n",
        "python": "from mathhook import Expression\n\nx = Expression.symbol('x')\ncache = {}\n\nexpr = x.pow(2)\nkey = str(expr)\n\nif key in cache:\n    print(\"Using cached result\")\nelse:\n    result = expr.simplify()\n    cache[key] = result\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\nconst x = Expression.symbol('x');\nconst cache = new Map<string, Expression>();\n\nconst expr = x.pow(2);\nconst key = expr.toString();\n\nif (cache.has(key)) {\n    console.log(\"Using cached result\");\n} else {\n    const result = expr.simplify();\n    cache.set(key, result);\n}\n"
      }
    },
    {
      "title": "Common Pitfall - Float Equality",
      "explanation": "Never use == for approximate values",
      "code": {
        "rust": "use mathhook::prelude::*;\n\n// WRONG - comparing floats directly\nlet val1: f64 = 3.14;\nlet val2: f64 = 3.14000000001;\n// if val1 == val2 { }  // BAD!\n\n// CORRECT - use epsilon comparison\nlet tolerance: f64 = 1e-10;\nif (val1 - val2).abs() < tolerance {\n    println!(\"Values are approximately equal\");\n}\n\n// OR use exact rationals for symbolic computation\nlet exact = Expression::rational(314, 100);  // Exact 3.14\n",
        "python": "from mathhook import Expression\n\n# WRONG - comparing floats directly\nval1 = 3.14\nval2 = 3.14000000001\n# if val1 == val2:  # BAD!\n\n# CORRECT - use epsilon comparison\ntolerance = 1e-10\nif abs(val1 - val2) < tolerance:\n    print(\"Values are approximately equal\")\n\n# OR use exact rationals\nexact = Expression.rational(314, 100)  # Exact 3.14\n",
        "nodejs": "import { Expression } from 'mathhook-node';\n\n// WRONG - comparing floats directly\nconst val1 = 3.14;\nconst val2 = 3.14000000001;\n// if (val1 === val2) { }  // BAD!\n\n// CORRECT - use epsilon comparison\nconst tolerance = 1e-10;\nif (Math.abs(val1 - val2) < tolerance) {\n    console.log(\"Values are approximately equal\");\n}\n\n// OR use exact rationals\nconst exact = Expression.rational(314, 100);  // Exact 3.14\n"
      }
    }
  ],
  "article": {
    "content": "# Common Patterns\n\nThis chapter covers common patterns and best practices when using MathHook.\n\n## Macro Usage Guidelines\n\n**ALWAYS use macros for:**\n- Symbol creation: `symbol!(x)` not `Symbol::new(\"x\")`\n- Simple expressions: `expr!(x + y)`\n- Function calls: `expr!(sin(x))`\n\n**Use explicit API for:**\n- Runtime/loop variables (macros see token 'i', not value)\n- Programmatic construction with runtime data\n- Dynamic polynomial building\n\n## Building Polynomials\n\n**Fixed Degree**: Use macros with `add:` helper\n**Dynamic Degree**: Use explicit API with loops\n\n## Substitution Patterns\n\nSingle or multiple variable substitution using HashMap.\n\n## Working with Functions\n\nCreate with `expr!` macro, `function!` macro, or `Expression::function()` for\nruntime function names. Compose functions by nesting.\n\n## Matrix Patterns\n\nCreate from vectors, identity matrices, zero matrices. Perform symbolic matrix\noperations.\n\n## Error Handling\n\nHandle parsing errors with `match` on `Result`. Handle solver errors by checking\nresult type.\n\n## Performance Patterns\n\n- Bulk operations: Use iterators and collect\n- Caching results: Store in HashMap keyed by string representation\n- Reuse expressions (immutable, cheap to clone)\n\n## Educational Patterns\n\nUse step-by-step explanations and derivative explanations for teaching.\n\n## Common Pitfalls\n\n1. **Runtime variables in macros**: Use explicit API for loop variables\n2. **Nested macro calls**: Use intermediate variables\n3. **Float equality**: Use epsilon comparison, not ==\n"
  },
  "use_cases": [
    "Learning MathHook best practices",
    "Avoiding common mistakes and pitfalls",
    "Writing efficient symbolic computation code",
    "Teaching proper symbolic math patterns"
  ],
  "related_topics": [
    "getting-started.quick-start",
    "getting-started.basic-usage",
    "core.expressions",
    "performance.architecture",
    "educational.step-by-step"
  ],
  "metadata": {
    "schema_version": "1.0"
  }
}