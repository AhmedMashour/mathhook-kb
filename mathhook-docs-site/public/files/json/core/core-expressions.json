{
  "topic": "core.expressions",
  "title": "Expressions",
  "description": "The Expression type is the foundation of MathHook. Expressions are represented as an enum\nwith variants for different mathematical constructs including numbers, variables, operations,\nfunctions, constants, matrices, and relations.\n",
  "code_refs": {
    "rust": "mathhook_core::expression::Expression",
    "python": "mathhook.Expression",
    "nodejs": "mathhook-node.Expression"
  },
  "examples": [
    {
      "title": "Basic Expression Creation with Macros",
      "explanation": "Using expr! and symbol! macros for ergonomic expression creation",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet y = symbol!(y);\n\n// Basic arithmetic\nlet sum = expr!(x + y);\nlet product = expr!(x * y);\nlet power = expr!(x ^ 2);\n\n// Complex expressions\nlet quadratic = expr!(a * x ^ 2 + b * x + c);\n",
        "python": "from mathhook import symbol, expr\n\nx = symbol('x')\ny = symbol('y')\n\n# Basic arithmetic\nsum_expr = expr('x + y')\nproduct = expr('x * y')\npower = expr('x^2')\n\n# Complex expressions\nquadratic = expr('a*x^2 + b*x + c')\n",
        "nodejs": "const { symbol, expr } = require('mathhook-node');\n\nconst x = symbol('x');\nconst y = symbol('y');\n\n// Basic arithmetic\nconst sum = expr('x + y');\nconst product = expr('x * y');\nconst power = expr('x^2');\n\n// Complex expressions\nconst quadratic = expr('a*x^2 + b*x + c');\n"
      }
    },
    {
      "title": "Canonical Form Normalization",
      "explanation": "Expressions are automatically normalized to canonical form",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet expr1 = expr!(x + y);\nlet expr2 = expr!(y + x);\n\n// Both normalized to same form\nassert_eq!(expr1, expr2);\n\n// Rationals reduced\nlet frac = Expression::rational(6, 4);\nassert_eq!(frac, Expression::rational(3, 2));\n",
        "python": "from mathhook import expr, Expression\n\nexpr1 = expr('x + y')\nexpr2 = expr('y + x')\n\n# Both normalized to same form\nassert expr1 == expr2\n\n# Rationals reduced\nfrac = Expression.rational(6, 4)\nassert frac == Expression.rational(3, 2)\n",
        "nodejs": "const { expr, Expression } = require('mathhook-node');\n\nconst expr1 = expr('x + y');\nconst expr2 = expr('y + x');\n\n// Both normalized to same form\nconsole.assert(expr1.equals(expr2));\n\n// Rationals reduced\nconst frac = Expression.rational(6, 4);\nconsole.assert(frac.equals(Expression.rational(3, 2)));\n"
      }
    },
    {
      "title": "Immutable Operations",
      "explanation": "All expression operations return new expressions without modifying originals",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet expr = expr!(x + 1);\nlet doubled = expr.mul(&expr!(2));\n\n// Original unchanged\nprintln!(\"Original: {}\", expr);  // x + 1\nprintln!(\"Doubled: {}\", doubled); // 2*(x + 1)\n",
        "python": "from mathhook import expr\n\noriginal = expr('x + 1')\ndoubled = original * 2\n\n# Original unchanged\nprint(f\"Original: {original}\")  # x + 1\nprint(f\"Doubled: {doubled}\")    # 2*(x + 1)\n",
        "nodejs": "const { expr } = require('mathhook-node');\n\nconst original = expr('x + 1');\nconst doubled = original.mul(2);\n\n// Original unchanged\nconsole.log(`Original: ${original}`);  // x + 1\nconsole.log(`Doubled: ${doubled}`);    // 2*(x + 1)\n"
      }
    }
  ],
  "article": {
    "content": "# Expressions\n\nThe `Expression` type is the foundation of MathHook. This chapter explains expression structure, creation, and manipulation.\n\n## Expression Structure\n\nExpressions in MathHook are represented as an enum with variants for different mathematical constructs:\n\n```rust\npub enum Expression {\n    // Numbers\n    Integer(i64),\n    Rational(Box<RationalData>),\n    Float(f64),\n    Complex(Box<ComplexData>),\n\n    // Variables\n    Symbol(Symbol),\n\n    // Operations\n    Add(Vec<Expression>),\n    Mul(Vec<Expression>),\n    Pow(Box<Expression>, Box<Expression>),\n\n    // Functions\n    Function(String, Vec<Expression>),\n\n    // Constants\n    Constant(ConstantType),\n\n    // Matrices\n    Matrix(Vec<Vec<Expression>>),\n\n    // Relations\n    Equation(Box<Expression>, Box<Expression>),\n\n    // Other variants...\n}\n```\n\n## Creating Expressions\n\n### Using Macros (Recommended)\n\nThe `expr!()` macro provides full mathematical syntax support:\n\n```rust\nuse mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Basic arithmetic\nlet sum = expr!(x + y);\nlet product = expr!(x * y);\nlet difference = expr!(x - y);  // Becomes x + (-1)*y\nlet quotient = expr!(x / y);    // Becomes x * y^(-1)\n\n// Power operations - three equivalent syntaxes\nlet power1 = expr!(x ^ 2);      // Caret notation (math-style)\nlet power2 = expr!(x ** 2);     // Double-star (Python-style)\nlet power3 = expr!(x.pow(2));   // Method call\n\n// Mathematical precedence (^ binds tighter than * and /)\nlet quadratic = expr!(a * x ^ 2 + b * x + c);  // Correctly parsed\n\n// Comparison operators\nlet eq = expr!(x == y);         // Equality\nlet lt = expr!(x < y);          // Less than\nlet gt = expr!(x > y);          // Greater than\nlet le = expr!(x <= y);         // Less or equal\nlet ge = expr!(x >= y);         // Greater or equal\n\n// Method calls\nlet abs_val = expr!(x.abs());           // Absolute value\nlet sqrt_val = expr!(x.sqrt());         // Square root\nlet simplified = expr!(x.simplify());   // Simplify expression\n\n// Function calls\nlet sin_val = expr!(sin(x));            // Unary function\nlet log_val = expr!(log(x, y));         // Binary function\n\n// Complex nested expressions\nlet complex = expr!(sin(x ^ 2) + cos(y ^ 2));\nlet expanded = expr!((x + 1) * (x - 1));\n```\n\n### Using Constructors\n\nFor runtime values or when macros aren't suitable:\n\n```rust\nuse mathhook::prelude::*;\n\nlet x = symbol!(x);\n\n// Direct constructors\nlet sum = Expression::add(vec![x.clone(), Expression::integer(1)]);\nlet product = Expression::mul(vec![x.clone(), Expression::integer(2)]);\nlet power = Expression::pow(x.clone(), Expression::integer(2));\n\n// Use for runtime variables (NOT expr! macro)\nfor i in 0..10 {\n    let term = Expression::integer(i);  // CORRECT\n    // NOT: expr!(i) - this creates symbol \"i\"\n}\n```\n\n## Expression Properties\n\n### Immutability\n\nExpressions are **immutable** after creation. All operations return new expressions:\n\n```rust\nlet expr = expr!(x + 1);\nlet doubled = expr.mul(&expr!(2));  // Returns new expression\n// `expr` is unchanged\n```\n\n### Memory Efficiency\n\nExpressions are designed to be 32 bytes to fit in CPU cache lines for optimal performance.\n\n## Why This Design?\n\n### Why 32-Byte Expression Size?\n\n**Design Decision**: MathHook's Expression type is constrained to exactly 32 bytes.\n\n**Why?**\n- Modern CPUs have 64-byte cache lines (standard on x86-64, ARM64)\n- Two expressions fit perfectly in one cache line\n- Cache-friendly data structures yield 3-5x faster operations in hot loops\n- This is critical for CAS workloads with millions of expression traversals\n\n**Trade-off**: Must use `Box<T>` for large nested structures\n- Recursive types (like `Pow(Box<Expression>, Box<Expression>)`) use heap allocation\n- Pointer indirection has small overhead, but cache benefits far outweigh it\n- For typical expression trees (depth < 50), the trade-off is heavily positive\n\n**Alternative Considered**: Variable-size expressions (like Python objects)\n- **Pros**: Simpler implementation, no size constraints\n- **Cons**: Poor cache locality, unpredictable performance, frequent cache misses\n- **Decision**: Performance predictability > implementation simplicity for CAS workload\n\n**When This Matters**:\n- Hot loops processing millions of expressions (simplification, pattern matching)\n- Recursive algorithms (symbolic differentiation, integration)\n- Less important: One-time parsing, display formatting, or educational explanations\n\n**Verification**:\n```rust\nuse std::mem::size_of;\nuse mathhook::Expression;\n\nassert_eq!(size_of::<Expression>(), 32);\n```\n\n**Performance Impact**: Benchmarks show 3-5x speedup on simplification and 2-3x on derivative computation compared to variable-size design.\n\n---\n\n### Why Immutable Expressions?\n\n**Design Decision**: Expressions cannot be modified after creation. All operations return new expressions.\n\n**Why?**\n- **Thread Safety**: Safe to share across threads without locks\n- **Correctness**: No hidden mutation surprises\n- **Optimization**: Compiler can optimize knowing values never change\n- **Debugging**: Expression history is traceable\n\n**Trade-off**: More allocations\n- Each operation creates new expressions\n- Mitigated by: reference counting (cheap clones), arena allocation for bulk operations\n- Benchmark: <100ns overhead per operation (negligible in practice)\n\n**Alternative Considered**: Mutable expressions with copy-on-write\n- **Pros**: Fewer allocations in some cases\n- **Cons**: Complex lifetime management, thread-safety issues, hard to reason about\n- **Decision**: Simplicity and safety > micro-optimization\n\n**Example**:\n```rust\nlet expr = expr!(x + 1);\nlet doubled = expr.mul(&expr!(2));\n// `expr` is unchanged, `doubled` is new expression\n// Safe to use both in parallel\n```\n\n---\n\n### Why Canonical Forms?\n\n**Design Decision**: MathHook automatically normalizes expressions to canonical form.\n\n**What is Canonical Form?**\n- `y + x` becomes `x + y` (sorted)\n- `(a + b) + c` becomes `Add(a, b, c)` (flattened)\n- `x + 0` becomes `x` (identity removed)\n- `6/4` becomes `3/2` (rationals reduced)\n\n**Why?**\n- **Equality checking**: Structurally equal expressions are always equal\n- **Simplification**: Canonical form is prerequisite for many simplification rules\n- **Consistency**: Same mathematical expression always has same representation\n- **Performance**: Pattern matching is faster on normalized expressions\n\n**Trade-off**: Small overhead on construction\n- Every `add()`, `mul()`, `pow()` normalizes\n- Typically <50ns per operation\n- Benefit: Avoid expensive normalization later during pattern matching\n\n**Example**:\n```rust\nlet expr1 = expr!(x + y);\nlet expr2 = expr!(y + x);\nassert_eq!(expr1, expr2);  // True - both normalized to x + y\n```\n\n**When This Matters**:\n- Expression equality checking (hash tables, caches)\n- Pattern matching in simplification rules\n- Zero detection (is expression mathematically zero?)\n\n---\n\n### Thread Safety\n\nExpressions are `Send + Sync`, making them safe to share across threads:\n\n```rust\nuse std::sync::Arc;\n\nlet expr = Arc::new(expr!(x ^ 2));\nlet expr_clone = Arc::clone(&expr);\n// Use in multiple threads safely\n```\n\n## Pattern Matching\n\nWork with expression structure using Rust's pattern matching:\n\n```rust\nmatch expr {\n    Expression::Add(terms) => {\n        println!(\"Sum with {} terms\", terms.len());\n    }\n    Expression::Mul(factors) => {\n        println!(\"Product with {} factors\", factors.len());\n    }\n    Expression::Pow(base, exp) => {\n        println!(\"Power: {} ^ {}\", base, exp);\n    }\n    Expression::Function(name, args) => {\n        println!(\"Function {} with {} args\", name, args.len());\n    }\n    _ => {}\n}\n```\n\n## Canonical Forms\n\nExpressions automatically maintain canonical forms:\n\n- **Commutative operations sorted**: $$y + x \\rightarrow x + y$$\n- **Associativity flattened**: $$(a + b) + c \\rightarrow a + b + c$$\n- **Identity elimination**: $$x + 0 \\rightarrow x$$, $$x * 1 \\rightarrow x$$\n- **Rationals reduced**: $$\\frac{6}{4} \\rightarrow \\frac{3}{2}$$\n\n## Common Operations\n\n### Simplification\n\n```rust\nlet expr = expr!(x + x);\nlet simplified = expr.simplify();\n// Result: 2*x\n```\n\n### Evaluation\n\n```rust\nlet x = symbol!(x);\nlet expr = expr!(x ^ 2);\nlet result = expr.substitute(&x, &expr!(3));\n// Result: 9\n```\n\n### Formatting\n\n```rust\nlet expr = expr!(x ^ 2);\n\nprintln!(\"Standard: {}\", expr);         // x^2\nprintln!(\"LaTeX: {}\", expr.to_latex()); // x^{2}\nprintln!(\"Wolfram: {}\", expr.to_wolfram()); // Power[x, 2]\n```\n\n## Next Steps\n\n- [Symbols and Numbers](./symbols-numbers.md)\n- [Functions](./functions.md)\n- [Mathematical Operations](../operations/simplification.md)\n"
  },
  "use_cases": [
    "Symbolic mathematics and computer algebra systems",
    "Automatic differentiation and calculus",
    "Mathematical education and step-by-step solutions",
    "Expression simplification and transformation"
  ],
  "related_topics": [
    "core.symbols-numbers",
    "core.functions",
    "core.pattern-matching",
    "operations.simplification"
  ],
  "performance": {
    "complexity": "O(1) for construction, O(n) for traversal",
    "typical_time": "< 50ns for creation, normalization"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}