{
  "topic": "polynomial.groebner",
  "title": "Groebner Bases",
  "description": "Groebner bases are fundamental tools in computational algebraic geometry for working with polynomial ideals,\nenabling ideal membership testing, polynomial system solving, variable elimination, and geometric theorem proving.\n",
  "mathematical_definition": "**Groebner Basis Definition**: A set $G = \\{g_1, \\ldots, g_m\\}$ is a Groebner basis for ideal $I$\nwith respect to monomial order $<$ if:\n\n$$\\langle \\text{LT}(g_1), \\ldots, \\text{LT}(g_m) \\rangle = \\langle \\text{LT}(I) \\rangle$$\n\nwhere $\\text{LT}$ denotes the leading term and $\\langle \\cdot \\rangle$ denotes the ideal generated.\n\n**S-Polynomial**: The S-polynomial of $f$ and $g$ is:\n\n$$S(f,g) = \\frac{\\text{lcm}(\\text{LT}(f), \\text{LT}(g))}{\\text{LT}(f)} \\cdot f - \\frac{\\text{lcm}(\\text{LT}(f), \\text{LT}(g))}{\\text{LT}(g)} \\cdot g$$\n\n**Buchberger's Criterion**: $G$ is a Groebner basis if and only if for all pairs $g_i, g_j \\in G$:\n\n$$S(g_i, g_j) \\xrightarrow{G}_+ 0$$\n\n(i.e., $S(g_i, g_j)$ reduces to 0 modulo $G$)\n\n**Monomial Orders**:\n- **Lex**: $x^\\alpha > x^\\beta \\iff$ first non-zero entry of $\\alpha - \\beta$ is positive\n- **Grlex**: Total degree first, then lex\n- **Grevlex**: Total degree first, then reverse lex from right\n",
  "code_refs": {
    "rust": "mathhook_core::polynomial::groebner",
    "python": "mathhook.polynomial.groebner",
    "nodejs": "mathhook.polynomial.groebner"
  },
  "examples": [
    {
      "title": "Basic Groebner Basis Computation",
      "explanation": "Compute Groebner basis for a polynomial ideal",
      "code": {
        "rust": "use mathhook_core::core::polynomial::groebner::{GroebnerBasis, MonomialOrder};\nuse mathhook_core::{expr, symbol};\n\nlet x = symbol!(x);\nlet y = symbol!(y);\n\n// Define polynomials: f1 = x - y, f2 = y^2 - 1\nlet f1 = expr!(x - y);\nlet f2 = expr!((y ^ 2) - 1);\n\n// Create Groebner basis\nlet mut gb = GroebnerBasis::new(\n    vec![f1, f2],\n    vec![x.clone(), y.clone()],\n    MonomialOrder::Lex\n);\n\n// Compute the basis\ngb.compute();\n\nprintln!(\"Basis has {} polynomials\", gb.basis.len());\n",
        "python": "from mathhook import expr, symbol\nfrom mathhook.polynomial.groebner import GroebnerBasis, MonomialOrder\n\nx = symbol('x')\ny = symbol('y')\n\n# Define polynomials: f1 = x - y, f2 = y^2 - 1\nf1 = expr('x - y')\nf2 = expr('y^2 - 1')\n\n# Create Groebner basis\ngb = GroebnerBasis(\n    [f1, f2],\n    [x, y],\n    MonomialOrder.Lex\n)\n\n# Compute the basis\ngb.compute()\n\nprint(f\"Basis has {len(gb.basis)} polynomials\")\n",
        "nodejs": "const { expr, symbol } = require('mathhook');\nconst { GroebnerBasis, MonomialOrder } = require('mathhook/polynomial/groebner');\n\nconst x = symbol('x');\nconst y = symbol('y');\n\n// Define polynomials: f1 = x - y, f2 = y^2 - 1\nconst f1 = expr('x - y');\nconst f2 = expr('y^2 - 1');\n\n// Create Groebner basis\nconst gb = new GroebnerBasis(\n    [f1, f2],\n    [x, y],\n    MonomialOrder.Lex\n);\n\n// Compute the basis\ngb.compute();\n\nconsole.log(`Basis has ${gb.basis.length} polynomials`);\n"
      }
    },
    {
      "title": "Sparse Polynomial Representation",
      "explanation": "Work with sparse polynomials for efficiency",
      "code": {
        "rust": "use mathhook_core::core::polynomial::groebner::{Monomial, expression_to_sparse_polynomial};\nuse mathhook_core::{expr, symbol};\n\n// Create a monomial x^2 * y (exponents [2, 1])\nlet mono = Monomial::new(vec![2, 1]);\nassert_eq!(mono.degree(), 3);\n\n// Convert expression to sparse polynomial\nlet x = symbol!(x);\nlet y = symbol!(y);\nlet poly = expr!((x ^ 2) + y);\n\nlet vars = vec![x, y];\nlet sparse = expression_to_sparse_polynomial(&poly, &vars);\n",
        "python": "from mathhook import expr, symbol\nfrom mathhook.polynomial.groebner import Monomial, expression_to_sparse_polynomial\n\n# Create a monomial x^2 * y (exponents [2, 1])\nmono = Monomial([2, 1])\nassert mono.degree() == 3\n\n# Convert expression to sparse polynomial\nx = symbol('x')\ny = symbol('y')\npoly = expr('x^2 + y')\n\nvars = [x, y]\nsparse = expression_to_sparse_polynomial(poly, vars)\n",
        "nodejs": "const { expr, symbol } = require('mathhook');\nconst { Monomial, expressionToSparsePolynomial } = require('mathhook/polynomial/groebner');\n\n// Create a monomial x^2 * y (exponents [2, 1])\nconst mono = new Monomial([2, 1]);\nassert(mono.degree() === 3);\n\n// Convert expression to sparse polynomial\nconst x = symbol('x');\nconst y = symbol('y');\nconst poly = expr('x^2 + y');\n\nconst vars = [x, y];\nconst sparse = expressionToSparsePolynomial(poly, vars);\n"
      }
    },
    {
      "title": "Polynomial Reduction",
      "explanation": "Reduce polynomial by a set of polynomials (division algorithm)",
      "code": {
        "rust": "use mathhook_core::core::polynomial::groebner::{\n    poly_reduce,\n    poly_reduce_completely\n};\n\n// Single-step reduction\nlet reduced = poly_reduce(&poly, &basis, &order);\n\n// Complete reduction (until no further reduction possible)\nlet fully_reduced = poly_reduce_completely(&poly, &basis, &order);\n",
        "python": "from mathhook.polynomial.groebner import poly_reduce, poly_reduce_completely\n\n# Single-step reduction\nreduced = poly_reduce(poly, basis, order)\n\n# Complete reduction (until no further reduction possible)\nfully_reduced = poly_reduce_completely(poly, basis, order)\n",
        "nodejs": "const { polyReduce, polyReduceCompletely } = require('mathhook/polynomial/groebner');\n\n// Single-step reduction\nconst reduced = polyReduce(poly, basis, order);\n\n// Complete reduction (until no further reduction possible)\nconst fullyReduced = polyReduceCompletely(poly, basis, order);\n"
      }
    },
    {
      "title": "Bidirectional Expression Conversion",
      "explanation": "Convert between Expression and sparse polynomial representation",
      "code": {
        "rust": "use mathhook_core::core::polynomial::groebner::{\n    expression_to_sparse_polynomial,\n    sparse_polynomial_to_expression\n};\nuse mathhook_core::{expr, symbol};\n\nlet x = symbol!(x);\nlet y = symbol!(y);\nlet vars = vec![x.clone(), y.clone()];\n\n// Expression to sparse\nlet expr = expr!((x ^ 2) + y);\nlet sparse = expression_to_sparse_polynomial(&expr, &vars).unwrap();\n\n// Sparse back to expression\nlet back = sparse_polynomial_to_expression(&sparse, &vars);\n",
        "python": "from mathhook import expr, symbol\nfrom mathhook.polynomial.groebner import (\n    expression_to_sparse_polynomial,\n    sparse_polynomial_to_expression\n)\n\nx = symbol('x')\ny = symbol('y')\nvars = [x, y]\n\n# Expression to sparse\ne = expr('x^2 + y')\nsparse = expression_to_sparse_polynomial(e, vars)\n\n# Sparse back to expression\nback = sparse_polynomial_to_expression(sparse, vars)\n",
        "nodejs": "const { expr, symbol } = require('mathhook');\nconst {\n    expressionToSparsePolynomial,\n    sparsePolynomialToExpression\n} = require('mathhook/polynomial/groebner');\n\nconst x = symbol('x');\nconst y = symbol('y');\nconst vars = [x, y];\n\n// Expression to sparse\nconst e = expr('x^2 + y');\nconst sparse = expressionToSparsePolynomial(e, vars);\n\n// Sparse back to expression\nconst back = sparsePolynomialToExpression(sparse, vars);\n"
      }
    }
  ],
  "article": {
    "content": "Groebner bases are a fundamental tool in computational algebraic geometry for working with polynomial ideals.\n\n## Overview\n\nA Groebner basis is a special generating set for a polynomial ideal that has many useful computational properties:\n\n- **Ideal Membership Testing**: Determine if a polynomial belongs to an ideal\n- **Polynomial System Solving**: Find common solutions to systems of polynomial equations\n- **Variable Elimination**: Eliminate variables from polynomial systems\n- **Geometric Theorem Proving**: Prove geometric theorems algebraically\n\n## Monomial Orders\n\nThe choice of monomial order affects the structure of the Groebner basis:\n\n| Order | Description | Use Case |\n|-------|-------------|----------|\n| `Lex` | Lexicographic | Variable elimination |\n| `Grlex` | Graded lexicographic | Balanced computation |\n| `Grevlex` | Graded reverse lexicographic | Efficient computation |\n\n### Lexicographic Order (Lex)\n\nCompares exponents from left to right:\n- $x^2y > xy^2$ (2 > 1 in first position)\n- $xy^3 > xz^5$ (y > z in second position)\n\nBest for: Variable elimination, solving systems\n\n### Graded Lexicographic (Grlex)\n\nCompares total degree first, then lexicographic:\n- $xy^2 > x^2$ (degree 3 > 2)\n- $x^2 > xy$ (same degree, $x^2 > xy$ lexicographically)\n\nBest for: Balanced trade-off between structure and efficiency\n\n### Graded Reverse Lexicographic (Grevlex)\n\nCompares total degree first, then reverse lexicographic from right:\n- $xy^2 > x^2y$ (same degree, compare from right)\n\nBest for: Efficient computation (often produces smaller bases)\n\n## Buchberger's Algorithm\n\nThe classic algorithm for computing Groebner bases:\n\n### Algorithm Steps\n\n1. **Initialize**: Start with the input polynomials\n2. **S-pairs**: For each pair of polynomials, compute the S-polynomial\n3. **Reduce**: Reduce each S-polynomial by the current basis\n4. **Add**: If reduction is non-zero, add to basis\n5. **Repeat**: Continue until no new polynomials are added\n\n## Applications\n\n### Solving Polynomial Systems\n\nCompute a Groebner basis with Lex order to get elimination ideals.\n\n### Ideal Membership\n\nTest if a polynomial belongs to an ideal by checking if its remainder under the\nGroebner basis is zero.\n\n### Elimination\n\nWith Lex order x > y > z, the Groebner basis contains polynomials in:\n- Only z (elimination of x and y)\n- y and z (elimination of x)\n- x, y, and z\n"
  },
  "use_cases": [
    "Solving systems of polynomial equations",
    "Testing ideal membership",
    "Variable elimination for geometric problems",
    "Automated geometric theorem proving"
  ],
  "related_topics": [
    "polynomial.overview",
    "polynomial.gcd",
    "polynomial.division"
  ],
  "performance": {
    "complexity": "Doubly exponential worst case, practical for small systems",
    "typical_time": "Milliseconds to seconds for 2-3 variables, degree <5"
  },
  "metadata": {
    "schema_version": "1.0",
    "last_updated": "2025-12-15T14:30:00Z"
  }
}