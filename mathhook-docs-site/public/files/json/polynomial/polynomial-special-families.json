{
  "topic": "polynomial.special-families",
  "title": "Special Polynomial Families",
  "description": "Classical orthogonal polynomial families including Legendre, Chebyshev (1st and 2nd kind),\nHermite, and Laguerre polynomials with both symbolic expansion and numerical evaluation capabilities.\n",
  "mathematical_definition": "**Orthogonal Polynomials**: A sequence $\\{P_n(x)\\}$ satisfying orthogonality relation:\n\n$$\\int_a^b P_n(x) P_m(x) w(x) \\, dx = 0 \\quad \\text{for } n \\neq m$$\n\nwhere $w(x)$ is the weight function on interval $[a, b]$.\n\n**Three-Term Recurrence**: All orthogonal polynomials satisfy:\n\n$$P_{n+1}(x) = (a_n x + b_n) P_n(x) - c_n P_{n-1}(x)$$\n\n**Family Definitions**:\n\n1. **Legendre**: Interval $[-1, 1]$, $w(x) = 1$\n   - Differential equation: $(1-x^2)P_n'' - 2xP_n' + n(n+1)P_n = 0$\n   - Recurrence: $P_{n+1} = \\frac{(2n+1)xP_n - nP_{n-1}}{n+1}$\n\n2. **Chebyshev (1st)**: Interval $[-1, 1]$, $w(x) = \\frac{1}{\\sqrt{1-x^2}}$\n   - Definition: $T_n(\\cos\\theta) = \\cos(n\\theta)$\n   - Recurrence: $T_{n+1} = 2xT_n - T_{n-1}$\n\n3. **Chebyshev (2nd)**: Interval $[-1, 1]$, $w(x) = \\sqrt{1-x^2}$\n   - Definition: $U_n(\\cos\\theta) = \\frac{\\sin((n+1)\\theta)}{\\sin\\theta}$\n   - Recurrence: $U_{n+1} = 2xU_n - U_{n-1}$\n\n4. **Hermite**: Interval $(-\\infty, \\infty)$, $w(x) = e^{-x^2}$\n   - Differential equation: $H_n'' - 2xH_n' + 2nH_n = 0$\n   - Rodriguez formula: $H_n(x) = (-1)^n e^{x^2} \\frac{d^n}{dx^n}(e^{-x^2})$\n   - Recurrence: $H_{n+1} = 2xH_n - 2nH_{n-1}$\n\n5. **Laguerre**: Interval $[0, \\infty)$, $w(x) = e^{-x}$\n   - Differential equation: $xL_n'' + (1-x)L_n' + nL_n = 0$\n   - Recurrence: $L_{n+1} = \\frac{(2n+1-x)L_n - nL_{n-1}}{n+1}$\n",
  "code_refs": {
    "rust": "mathhook_core::polynomial::special_families",
    "python": "mathhook.polynomial.special_families",
    "nodejs": "mathhook.polynomial.special_families"
  },
  "examples": [
    {
      "title": "Legendre Polynomials",
      "explanation": "Solutions to Legendre's differential equation",
      "code": {
        "rust": "use mathhook_core::core::polynomial::special_families::Legendre;\nuse mathhook_core::core::polynomial::special_families::OrthogonalPolynomial;\nuse mathhook_core::symbol;\n\nlet x = symbol!(x);\n\n// Symbolic expansion\nlet p0 = Legendre::polynomial(0, &x);  // 1\nlet p1 = Legendre::polynomial(1, &x);  // x\nlet p2 = Legendre::polynomial(2, &x);  // (3x^2 - 1)/2\n\n// Numerical evaluation\nlet val = Legendre::evaluate(2, 0.5);  // P_2(0.5) = -0.125\n\n// Recurrence: P_{n+1} = ((2n+1)x*P_n - n*P_{n-1}) / (n+1)\nlet (a, b, c) = Legendre::recurrence_coefficients(2);\n",
        "python": "from mathhook import symbol\nfrom mathhook.polynomial.special_families import Legendre\n\nx = symbol('x')\n\n# Symbolic expansion\np0 = Legendre.polynomial(0, x)  # 1\np1 = Legendre.polynomial(1, x)  # x\np2 = Legendre.polynomial(2, x)  # (3*x^2 - 1)/2\n\n# Numerical evaluation\nval = Legendre.evaluate(2, 0.5)  # P_2(0.5) = -0.125\n\n# Recurrence: P_{n+1} = ((2n+1)*x*P_n - n*P_{n-1}) / (n+1)\na, b, c = Legendre.recurrence_coefficients(2)\n",
        "nodejs": "const { symbol } = require('mathhook');\nconst { Legendre } = require('mathhook/polynomial/special_families');\n\nconst x = symbol('x');\n\n// Symbolic expansion\nconst p0 = Legendre.polynomial(0, x);  // 1\nconst p1 = Legendre.polynomial(1, x);  // x\nconst p2 = Legendre.polynomial(2, x);  // (3*x^2 - 1)/2\n\n// Numerical evaluation\nconst val = Legendre.evaluate(2, 0.5);  // P_2(0.5) = -0.125\n\n// Recurrence: P_{n+1} = ((2n+1)*x*P_n - n*P_{n-1}) / (n+1)\nconst [a, b, c] = Legendre.recurrenceCoefficients(2);\n"
      }
    },
    {
      "title": "Chebyshev Polynomials (First Kind)",
      "explanation": "Defined by T_n(cos(theta)) = cos(n*theta)",
      "code": {
        "rust": "use mathhook_core::core::polynomial::special_families::ChebyshevT;\nuse mathhook_core::core::polynomial::special_families::OrthogonalPolynomial;\nuse mathhook_core::symbol;\n\nlet x = symbol!(x);\n\n// Symbolic\nlet t0 = ChebyshevT::polynomial(0, &x);  // 1\nlet t1 = ChebyshevT::polynomial(1, &x);  // x\nlet t2 = ChebyshevT::polynomial(2, &x);  // 2x^2 - 1\n\n// Numerical\nlet val = ChebyshevT::evaluate(2, 0.5);  // T_2(0.5) = -0.5\n\n// Recurrence: T_{n+1} = 2x*T_n - T_{n-1}\n",
        "python": "from mathhook import symbol\nfrom mathhook.polynomial.special_families import ChebyshevT\n\nx = symbol('x')\n\n# Symbolic\nt0 = ChebyshevT.polynomial(0, x)  # 1\nt1 = ChebyshevT.polynomial(1, x)  # x\nt2 = ChebyshevT.polynomial(2, x)  # 2*x^2 - 1\n\n# Numerical\nval = ChebyshevT.evaluate(2, 0.5)  # T_2(0.5) = -0.5\n\n# Recurrence: T_{n+1} = 2*x*T_n - T_{n-1}\n",
        "nodejs": "const { symbol } = require('mathhook');\nconst { ChebyshevT } = require('mathhook/polynomial/special_families');\n\nconst x = symbol('x');\n\n// Symbolic\nconst t0 = ChebyshevT.polynomial(0, x);  // 1\nconst t1 = ChebyshevT.polynomial(1, x);  // x\nconst t2 = ChebyshevT.polynomial(2, x);  // 2*x^2 - 1\n\n// Numerical\nconst val = ChebyshevT.evaluate(2, 0.5);  // T_2(0.5) = -0.5\n\n// Recurrence: T_{n+1} = 2*x*T_n - T_{n-1}\n"
      }
    },
    {
      "title": "Hermite Polynomials",
      "explanation": "Solutions to Hermite's equation (physicist's convention)",
      "code": {
        "rust": "use mathhook_core::core::polynomial::special_families::Hermite;\nuse mathhook_core::core::polynomial::special_families::OrthogonalPolynomial;\nuse mathhook_core::symbol;\n\nlet x = symbol!(x);\n\n// Symbolic\nlet h0 = Hermite::polynomial(0, &x);  // 1\nlet h1 = Hermite::polynomial(1, &x);  // 2x\nlet h2 = Hermite::polynomial(2, &x);  // 4x^2 - 2\n\n// Numerical\nlet val = Hermite::evaluate(1, 0.5);  // H_1(0.5) = 1\n\n// Recurrence: H_{n+1} = 2x*H_n - 2n*H_{n-1}\n",
        "python": "from mathhook import symbol\nfrom mathhook.polynomial.special_families import Hermite\n\nx = symbol('x')\n\n# Symbolic\nh0 = Hermite.polynomial(0, x)  # 1\nh1 = Hermite.polynomial(1, x)  # 2*x\nh2 = Hermite.polynomial(2, x)  # 4*x^2 - 2\n\n# Numerical\nval = Hermite.evaluate(1, 0.5)  # H_1(0.5) = 1\n\n# Recurrence: H_{n+1} = 2*x*H_n - 2*n*H_{n-1}\n",
        "nodejs": "const { symbol } = require('mathhook');\nconst { Hermite } = require('mathhook/polynomial/special_families');\n\nconst x = symbol('x');\n\n// Symbolic\nconst h0 = Hermite.polynomial(0, x);  // 1\nconst h1 = Hermite.polynomial(1, x);  // 2*x\nconst h2 = Hermite.polynomial(2, x);  // 4*x^2 - 2\n\n// Numerical\nconst val = Hermite.evaluate(1, 0.5);  // H_1(0.5) = 1\n\n// Recurrence: H_{n+1} = 2*x*H_n - 2*n*H_{n-1}\n"
      }
    },
    {
      "title": "Laguerre Polynomials",
      "explanation": "Solutions to Laguerre's equation",
      "code": {
        "rust": "use mathhook_core::core::polynomial::special_families::Laguerre;\nuse mathhook_core::core::polynomial::special_families::OrthogonalPolynomial;\nuse mathhook_core::symbol;\n\nlet x = symbol!(x);\n\n// Symbolic\nlet l0 = Laguerre::polynomial(0, &x);  // 1\nlet l1 = Laguerre::polynomial(1, &x);  // 1 - x\nlet l2 = Laguerre::polynomial(2, &x);  // (x^2 - 4x + 2)/2\n\n// Numerical\nlet val = Laguerre::evaluate(1, 0.5);  // L_1(0.5) = 0.5\n\n// Recurrence: L_{n+1} = ((2n+1-x)*L_n - n*L_{n-1}) / (n+1)\n",
        "python": "from mathhook import symbol\nfrom mathhook.polynomial.special_families import Laguerre\n\nx = symbol('x')\n\n# Symbolic\nl0 = Laguerre.polynomial(0, x)  # 1\nl1 = Laguerre.polynomial(1, x)  # 1 - x\nl2 = Laguerre.polynomial(2, x)  # (x^2 - 4*x + 2)/2\n\n# Numerical\nval = Laguerre.evaluate(1, 0.5)  # L_1(0.5) = 0.5\n\n# Recurrence: L_{n+1} = ((2*n+1-x)*L_n - n*L_{n-1}) / (n+1)\n",
        "nodejs": "const { symbol } = require('mathhook');\nconst { Laguerre } = require('mathhook/polynomial/special_families');\n\nconst x = symbol('x');\n\n// Symbolic\nconst l0 = Laguerre.polynomial(0, x);  // 1\nconst l1 = Laguerre.polynomial(1, x);  // 1 - x\nconst l2 = Laguerre.polynomial(2, x);  // (x^2 - 4*x + 2)/2\n\n// Numerical\nconst val = Laguerre.evaluate(1, 0.5);  // L_1(0.5) = 0.5\n\n// Recurrence: L_{n+1} = ((2*n+1-x)*L_n - n*L_{n-1}) / (n+1)\n"
      }
    },
    {
      "title": "Variable Substitution",
      "explanation": "Use any variable symbol in polynomial generation",
      "code": {
        "rust": "use mathhook_core::core::polynomial::special_families::Legendre;\nuse mathhook_core::core::polynomial::special_families::OrthogonalPolynomial;\nuse mathhook_core::symbol;\n\n// Use variable t instead of x\nlet t = symbol!(t);\nlet p2_t = Legendre::polynomial(2, &t);\n// Result uses t: (3t^2 - 1)/2\n",
        "python": "from mathhook import symbol\nfrom mathhook.polynomial.special_families import Legendre\n\n# Use variable t instead of x\nt = symbol('t')\np2_t = Legendre.polynomial(2, t)\n# Result uses t: (3*t^2 - 1)/2\n",
        "nodejs": "const { symbol } = require('mathhook');\nconst { Legendre } = require('mathhook/polynomial/special_families');\n\n// Use variable t instead of x\nconst t = symbol('t');\nconst p2T = Legendre.polynomial(2, t);\n// Result uses t: (3*t^2 - 1)/2\n"
      }
    }
  ],
  "article": {
    "content": "MathHook provides access to classical orthogonal polynomial families with both symbolic expansion and numerical evaluation.\n\n## Supported Families\n\n| Family | Symbol | Interval | Weight Function |\n|--------|--------|----------|-----------------|\n| Legendre | P_n(x) | [-1, 1] | w(x) = 1 |\n| Chebyshev (1st) | T_n(x) | [-1, 1] | w(x) = 1/sqrt(1-x^2) |\n| Chebyshev (2nd) | U_n(x) | [-1, 1] | w(x) = sqrt(1-x^2) |\n| Hermite | H_n(x) | (-inf, inf) | w(x) = exp(-x^2) |\n| Laguerre | L_n(x) | [0, inf) | w(x) = exp(-x) |\n\n## The OrthogonalPolynomial Trait\n\nAll families implement a unified interface providing:\n- Symbolic polynomial generation\n- Numerical evaluation at specific points\n- Recurrence relation coefficients\n\n## Applications\n\n- **Numerical Integration**: Gaussian quadrature rules\n- **Spectral Methods**: Approximation and PDE solving\n- **Physics**: Quantum mechanics, electrostatics\n- **Signal Processing**: Filter design, approximation\n"
  },
  "use_cases": [
    "Numerical integration using Gaussian quadrature",
    "Spectral methods for solving PDEs",
    "Quantum mechanics wave function expansions",
    "Signal processing and approximation theory"
  ],
  "related_topics": [
    "polynomial.overview",
    "evaluation.function_evaluation"
  ],
  "performance": {
    "complexity": "O(n) for evaluation using recurrence relations",
    "typical_time": "Sub-millisecond for n < 100"
  },
  "metadata": {
    "schema_version": "1.0",
    "last_updated": "2025-12-15T14:30:00Z"
  }
}