{
  "topic": "operations.differentiation",
  "title": "Symbolic Differentiation",
  "description": "Symbolic differentiation in MathHook uses automatic differentiation with the chain rule, product rule, quotient rule, and function-specific derivative rules.\n",
  "mathematical_definition": "**Power Rule:**\n$$\\frac{d}{dx} x^n = n x^{n-1}$$\n\n**Product Rule:**\n$$\\frac{d}{dx} [f(x) \\cdot g(x)] = f'(x) \\cdot g(x) + f(x) \\cdot g'(x)$$\n\n**Quotient Rule:**\n$$\\frac{d}{dx} \\frac{f(x)}{g(x)} = \\frac{f'(x) \\cdot g(x) - f(x) \\cdot g'(x)}{[g(x)]^2}$$\n\n**Chain Rule:**\n$$\\frac{d}{dx} f(g(x)) = f'(g(x)) \\cdot g'(x)$$\n\n**Trigonometric Derivatives:**\n- $\\frac{d}{dx}\\sin(x) = \\cos(x)$\n- $\\frac{d}{dx}\\cos(x) = -\\sin(x)$\n- $\\frac{d}{dx}\\tan(x) = \\sec^2(x)$\n\n**Exponential and Logarithmic:**\n- $\\frac{d}{dx}e^x = e^x$\n- $\\frac{d}{dx}\\ln(x) = \\frac{1}{x}$\n",
  "code_refs": {
    "rust": "mathhook_core::calculus::derivatives::Derivative",
    "python": "mathhook.derivative",
    "nodejs": "mathhook.derivative"
  },
  "examples": [
    {
      "title": "Power Rule",
      "explanation": "d/dx(x^n) = n*x^(n-1)",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet expr = expr!(x ^ 5);\nlet deriv = expr.derivative(&x, 1);\n// Result: 5 * x^4\n",
        "python": "from mathhook import symbol, derivative\n\nx = symbol('x')\nexpr = x**5\nderiv = derivative(expr, x)\n# Result: 5 * x^4\n",
        "nodejs": "const { symbol, derivative } = require('mathhook');\n\nconst x = symbol('x');\nconst expr = x.pow(5);\nconst deriv = derivative(expr, x);\n// Result: 5 * x^4\n"
      }
    },
    {
      "title": "Product Rule",
      "explanation": "d/dx(f路g) = f'路g + f路g'",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet f = expr!(x ^ 2);\nlet g = expr!(x ^ 3);\nlet product = expr!(mul: f, g);  // x^2 * x^3\n\nlet deriv = product.derivative(&x, 1);\n// Result: 2*x * x^3 + x^2 * 3*x^2 = 5*x^4\n",
        "python": "from mathhook import symbol, derivative\n\nx = symbol('x')\nf = x**2\ng = x**3\nproduct = f * g\n\nderiv = derivative(product, x)\n# Result: 5*x^4\n",
        "nodejs": "const { symbol, derivative } = require('mathhook');\n\nconst x = symbol('x');\nconst product = x.pow(2).mul(x.pow(3));\nconst deriv = derivative(product, x);\n// Result: 5*x^4\n"
      }
    },
    {
      "title": "Chain Rule",
      "explanation": "d/dx(f(g(x))) = f'(g(x))路g'(x)",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet inner = expr!(x ^ 2);\nlet outer = expr!(sin(inner));  // sin(x^2)\n\nlet deriv = outer.derivative(&x, 1);\n// Result: cos(x^2) * 2*x\n",
        "python": "from mathhook import symbol, derivative, sin\n\nx = symbol('x')\ninner = x**2\nouter = sin(inner)  # sin(x^2)\n\nderiv = derivative(outer, x)\n# Result: cos(x^2) * 2*x\n",
        "nodejs": "const { symbol, derivative, parse } = require('mathhook');\n\nconst x = symbol('x');\nconst expr = parse('sin(x^2)');\nconst deriv = derivative(expr, x);\n// Result: cos(x^2) * 2*x\n"
      }
    },
    {
      "title": "Partial Derivatives",
      "explanation": "Multivariable differentiation",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet y = symbol!(y);\nlet expr = expr!((x ^ 2) * y);\n\n// Partial derivative with respect to x\nlet df_dx = expr.derivative(&x, 1);\n// Result: 2*x*y\n\n// Partial derivative with respect to y\nlet df_dy = expr.derivative(&y, 1);\n// Result: x^2\n",
        "python": "from mathhook import symbol, derivative\n\nx = symbol('x')\ny = symbol('y')\nexpr = x**2 * y\n\n# Partial derivative with respect to x\ndf_dx = derivative(expr, x)\n# Result: 2*x*y\n\n# Partial derivative with respect to y\ndf_dy = derivative(expr, y)\n# Result: x^2\n",
        "nodejs": "const { symbol, derivative } = require('mathhook');\n\nconst x = symbol('x');\nconst y = symbol('y');\nconst expr = x.pow(2).mul(y);\n\n// Partial derivative with respect to x\nconst df_dx = derivative(expr, x);\n// Result: 2*x*y\n\n// Partial derivative with respect to y\nconst df_dy = derivative(expr, y);\n// Result: x^2\n"
      }
    },
    {
      "title": "Higher-Order Derivatives",
      "explanation": "Second, third, or nth order derivatives",
      "code": {
        "rust": "use mathhook::prelude::*;\n\nlet x = symbol!(x);\nlet expr = expr!(x ^ 4);\n\n// First derivative: 4*x^3\nlet first = expr.derivative(&x, 1);\n\n// Second derivative: 12*x^2\nlet second = expr.derivative(&x, 2);\n\n// Third derivative: 24*x\nlet third = expr.derivative(&x, 3);\n\n// Fourth derivative: 24\nlet fourth = expr.derivative(&x, 4);\n",
        "python": "from mathhook import symbol, derivative\n\nx = symbol('x')\nexpr = x**4\n\n# First derivative: 4*x^3\nfirst = derivative(expr, x, order=1)\n\n# Second derivative: 12*x^2\nsecond = derivative(expr, x, order=2)\n\n# Third derivative: 24*x\nthird = derivative(expr, x, order=3)\n\n# Fourth derivative: 24\nfourth = derivative(expr, x, order=4)\n",
        "nodejs": "const { symbol, derivative } = require('mathhook');\n\nconst x = symbol('x');\nconst expr = x.pow(4);\n\n// First derivative: 4*x^3\nconst first = derivative(expr, x, { order: 1 });\n\n// Second derivative: 12*x^2\nconst second = derivative(expr, x, { order: 2 });\n"
      }
    }
  ],
  "use_cases": [
    "Calculus: Computing derivatives for analysis",
    "Physics: Velocity from position, acceleration from velocity",
    "Optimization: Finding critical points (f' = 0)",
    "Machine Learning: Backpropagation gradients"
  ],
  "related_topics": [
    "operations.integration",
    "operations.limits",
    "operations.series"
  ],
  "performance": {
    "complexity": "O(n) where n = expression tree size"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}