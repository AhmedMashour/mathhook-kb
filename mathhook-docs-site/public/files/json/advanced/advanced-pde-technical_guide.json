{
  "topic": "advanced.pde.technical_guide",
  "title": "PDE Technical Guide - Mathematical Foundation and Implementation",
  "description": "Rigorous mathematical treatment of partial differential equations with proofs and references.\nCovers formal definitions, method of characteristics with geometric interpretation, existence\nand uniqueness theory (Cauchy-Kovalevskaya theorem), nonlinear PDEs, shock formation, weak\nsolutions, Rankine-Hugoniot jump conditions, and real-world applications (traffic flow,\ngroundwater contaminant transport). Includes complete derivations and MathHook implementation details.\n",
  "mathematical_definition": "**Definition (Quasi-Linear First-Order PDE)**:\n\n$$a(x,y,u) \\frac{\\partial u}{\\partial x} + b(x,y,u) \\frac{\\partial u}{\\partial y} = c(x,y,u)$$\n\n**Characteristic Curves** satisfy:\n\n$$\\frac{dx}{ds} = a(x,y,u), \\quad \\frac{dy}{ds} = b(x,y,u), \\quad \\frac{du}{ds} = c(x,y,u)$$\n\n**Theorem (Local Existence via Characteristics)**: Given $C^1$ coefficients, $C^1$ initial data,\nand non-characteristic initial curve, there exists a unique $C^1$ solution in a neighborhood.\n\n**Rankine-Hugoniot Jump Condition** (weak solutions with shocks):\n\n$$\\frac{ds}{dt} = \\frac{[f(u)]}{[u]} = \\frac{f(u_R) - f(u_L)}{u_R - u_L}$$\n\n**Lax Entropy Condition** (admissible shocks):\n\n$$f'(u_L) > s > f'(u_R)$$\n",
  "code_refs": {
    "rust": "mathhook_core::pde",
    "python": "mathhook.pde",
    "nodejs": "mathhook.pde"
  },
  "examples": [
    {
      "title": "Transport Equation (Complete Derivation)",
      "explanation": "Rigorous derivation of transport equation solution using method of characteristics",
      "code": {
        "rust": "/// Transport equation: ∂u/∂t + c·∂u/∂x = 0 with u(x,0) = sin(x)\n///\n/// Expected solution (from d'Alembert): u(x,t) = sin(x - ct)\n///\n/// Mathematical validation:\n/// - PDE residual: ∂u/∂t + c·∂u/∂x = 0 ✓\n/// - IC satisfaction: u(x,0) = sin(x) ✓\n///\n/// Reference: Evans (2010), Example 3.2.1, pp. 92-93.\nuse derivatives::Derivative;\nuse mathhook::simplify::Simplify;\n\nfn main() {\n    let c_speed = 2;\n    let u = symbol!(u);\n    let t = symbol!(t);\n    let x = symbol!(x);\n\n    // Build PDE structure\n    let equation = expr!(u);\n    let pde = Pde::new(equation, u.clone(), vec![t.clone(), x.clone()]);\n\n    // Solve using method of characteristics\n    let result = method_of_characteristics(&pde)\n        .expect(\"Failed to solve transport equation\");\n\n    println!(\"Characteristic equations:\");\n    println!(\"  dt/ds = {}\", result.coefficients.a);\n    println!(\"  dx/ds = {}\", result.coefficients.b);\n    println!(\"  du/ds = {}\", result.coefficients.c);\n\n    // Apply initial condition: u(x,0) = sin(x)\n    let solution = expr!(sin(x - c_speed * t));\n    println!(\"\\nSolution: u(x,t) = {}\", solution);\n\n    // Verify PDE satisfaction\n    let du_dt = solution.derivative(t.clone());\n    let du_dx = solution.derivative(x.clone());\n    let pde_lhs = expr!(du_dt + c_speed * du_dx);\n    let simplified = pde_lhs.simplify();\n\n    assert_eq!(simplified, expr!(0), \"PDE not satisfied!\");\n    println!(\"✓ PDE verified: ∂u/∂t + {}·∂u/∂x = 0\", c_speed);\n\n    // Verify IC\n    let u_at_t0 = expr!(sin(x - c_speed * 0));\n    assert_eq!(u_at_t0.simplify(), expr!(sin(x)));\n    println!(\"✓ IC verified: u(x,0) = sin(x)\");\n}\n",
        "python": "\"\"\"Transport equation: ∂u/∂t + c·∂u/∂x = 0 with u(x,0) = sin(x)\n\nExpected solution (from d'Alembert): u(x,t) = sin(x - ct)\n\nMathematical validation:\n- PDE residual: ∂u/∂t + c·∂u/∂x = 0 ✓\n- IC satisfaction: u(x,0) = sin(x) ✓\n\nReference: Evans (2010), Example 3.2.1, pp. 92-93.\n\"\"\"\nfrom mathhook.derivatives import derivative\nfrom mathhook.simplify import simplify\n\nc_speed = 2\nu = symbol('u')\nt = symbol('t')\nx = symbol('x')\n\n# Build PDE structure\nequation = expr(u)\npde = Pde(equation, u, [t, x])\n\n# Solve using method of characteristics\nresult = method_of_characteristics(pde)\n\nprint(\"Characteristic equations:\")\nprint(f\"  dt/ds = {result.coefficients.a}\")\nprint(f\"  dx/ds = {result.coefficients.b}\")\nprint(f\"  du/ds = {result.coefficients.c}\")\n\n# Apply initial condition: u(x,0) = sin(x)\nsolution = expr(f'sin(x - {c_speed} * t)')\nprint(f\"\\nSolution: u(x,t) = {solution}\")\n\n# Verify PDE satisfaction\ndu_dt = derivative(solution, t)\ndu_dx = derivative(solution, x)\npde_lhs = expr(f\"{du_dt} + {c_speed} * {du_dx}\")\nsimplified = simplify(pde_lhs)\n\nassert simplified == expr(0), \"PDE not satisfied!\"\nprint(f\"✓ PDE verified: ∂u/∂t + {c_speed}·∂u/∂x = 0\")\n\n# Verify IC\nu_at_t0 = expr(f'sin(x - {c_speed} * 0)')\nassert simplify(u_at_t0) == expr('sin(x)')\nprint(\"✓ IC verified: u(x,0) = sin(x)\")\n",
        "nodejs": "/**\n * Transport equation: ∂u/∂t + c·∂u/∂x = 0 with u(x,0) = sin(x)\n *\n * Expected solution (from d'Alembert): u(x,t) = sin(x - ct)\n *\n * Mathematical validation:\n * - PDE residual: ∂u/∂t + c·∂u/∂x = 0 ✓\n * - IC satisfaction: u(x,0) = sin(x) ✓\n *\n * Reference: Evans (2010), Example 3.2.1, pp. 92-93.\n */\nconst { derivative } = require('mathhook/derivatives');\nconst { simplify } = require('mathhook/simplify');\n\nconst cSpeed = 2;\nconst u = symbol('u');\nconst t = symbol('t');\nconst x = symbol('x');\n\n// Build PDE structure\nconst equation = expr(u);\nconst pde = new Pde(equation, u, [t, x]);\n\n// Solve using method of characteristics\nconst result = methodOfCharacteristics(pde);\n\nconsole.log(\"Characteristic equations:\");\nconsole.log(`  dt/ds = ${result.coefficients.a}`);\nconsole.log(`  dx/ds = ${result.coefficients.b}`);\nconsole.log(`  du/ds = ${result.coefficients.c}`);\n\n// Apply initial condition: u(x,0) = sin(x)\nconst solution = expr(`sin(x - ${cSpeed} * t)`);\nconsole.log(`\\nSolution: u(x,t) = ${solution}`);\n\n// Verify PDE satisfaction\nconst duDt = derivative(solution, t);\nconst duDx = derivative(solution, x);\nconst pdeLhs = expr(`${duDt} + ${cSpeed} * ${duDx}`);\nconst simplified = simplify(pdeLhs);\n\nconsole.assert(simplified.equals(expr(0)), \"PDE not satisfied!\");\nconsole.log(`✓ PDE verified: ∂u/∂t + ${cSpeed}·∂u/∂x = 0`);\n\n// Verify IC\nconst uAtT0 = expr(`sin(x - ${cSpeed} * 0)`);\nconsole.assert(simplify(uAtT0).equals(expr('sin(x)')));\nconsole.log(\"✓ IC verified: u(x,0) = sin(x)\");\n"
      }
    },
    {
      "title": "Burgers' Equation (Shock Formation Analysis)",
      "explanation": "Demonstrate shock formation in Burgers' equation with Rankine-Hugoniot condition",
      "code": {
        "rust": "/// Burgers' equation: ∂u/∂t + u·∂u/∂x = 0\n///\n/// Demonstrates:\n/// 1. Nonlinear characteristic system\n/// 2. Shock formation when characteristics intersect\n/// 3. Rankine-Hugoniot jump condition\n///\n/// Reference: Lax (1973), *Hyperbolic Systems of Conservation Laws*, pp. 9-18.\nfn main() {\n    let u_sym = symbol!(u);\n\n    let coefficients = PdeCoefficients {\n        a: expr!(1),           // Coefficient of ∂u/∂t\n        b: expr!(u_sym),       // Coefficient of ∂u/∂x (NONLINEAR!)\n        c: expr!(0),           // RHS\n    };\n\n    println!(\"Burgers' Equation Characteristic System:\");\n    println!(\"  dt/ds = {}\", coefficients.a);\n    println!(\"  dx/ds = {} (depends on u - NONLINEAR!)\", coefficients.b);\n    println!(\"  du/ds = {}\", coefficients.c);\n    println!();\n\n    // Example: Step function IC - u(x,0) = {1 if x<0, 0 if x>0}\n    println!(\"Example: Step function IC\");\n    println!(\"Characteristic from x₀ = -1 (u₀ = 1):\");\n    println!(\"  Solution: u = 1 (constant along characteristic)\");\n    println!(\"  Trajectory: x(t) = -1 + 1·t = t - 1\");\n    println!();\n\n    println!(\"Characteristic from x₀ = 1 (u₀ = 0):\");\n    println!(\"  Solution: u = 0 (constant along characteristic)\");\n    println!(\"  Trajectory: x(t) = 1 + 0·t = 1 (vertical!)\");\n    println!();\n\n    // Shock formation\n    println!(\"Shock Formation:\");\n    println!(\"  → CHARACTERISTICS INTERSECT → SHOCK FORMS\");\n    println!();\n\n    // Rankine-Hugoniot condition\n    println!(\"Shock Speed (Rankine-Hugoniot condition):\");\n    println!(\"  For Burgers' equation: f(u) = u²/2\");\n    println!(\"  Jump: [u] = u_R - u_L = 0 - 1 = -1\");\n    println!(\"  Flux jump: [f] = f(0) - f(1) = 0 - 1/2 = -1/2\");\n    println!(\"  Shock speed: v_shock = [f]/[u] = 1/2\");\n    println!(\"  Shock trajectory: x_shock(t) = t/2\");\n    println!();\n\n    // Entropy condition\n    println!(\"Entropy Condition:\");\n    println!(\"  u_L = 1 > u_R = 0 → COMPRESSIVE SHOCK ✓\");\n}\n",
        "python": "\"\"\"Burgers' equation: ∂u/∂t + u·∂u/∂x = 0\n\nDemonstrates shock formation and Rankine-Hugoniot condition.\n\nReference: Lax (1973), pp. 9-18.\n\"\"\"\nu_sym = symbol('u')\n\ncoefficients = PdeCoefficients(\n    a=expr(1),\n    b=expr(u_sym),  # NONLINEAR!\n    c=expr(0)\n)\n\nprint(\"Burgers' Equation Characteristic System:\")\nprint(f\"  dt/ds = {coefficients.a}\")\nprint(f\"  dx/ds = {coefficients.b} (NONLINEAR!)\")\nprint(f\"  du/ds = {coefficients.c}\")\nprint()\n\nprint(\"Shock Formation Analysis:\")\nprint(\"  Step function IC leads to characteristic intersection\")\nprint(\"  Shock speed via Rankine-Hugoniot: v_shock = 1/2\")\nprint(\"  Entropy condition satisfied: u_L > u_R ✓\")\n",
        "nodejs": "/**\n * Burgers' equation: ∂u/∂t + u·∂u/∂x = 0\n *\n * Demonstrates shock formation and Rankine-Hugoniot condition.\n *\n * Reference: Lax (1973), pp. 9-18.\n */\nconst uSym = symbol('u');\n\nconst coefficients = {\n    a: expr(1),\n    b: expr(uSym),  // NONLINEAR!\n    c: expr(0)\n};\n\nconsole.log(\"Burgers' Equation Characteristic System:\");\nconsole.log(`  dt/ds = ${coefficients.a}`);\nconsole.log(`  dx/ds = ${coefficients.b} (NONLINEAR!)`);\nconsole.log(`  du/ds = ${coefficients.c}`);\nconsole.log();\n\nconsole.log(\"Shock Formation Analysis:\");\nconsole.log(\"  Step function IC leads to characteristic intersection\");\nconsole.log(\"  Shock speed via Rankine-Hugoniot: v_shock = 1/2\");\nconsole.log(\"  Entropy condition satisfied: u_L > u_R ✓\");\n"
      }
    },
    {
      "title": "Traffic Flow Model (Lighthill-Whitham-Richards)",
      "explanation": "Real-world application of conservation laws to traffic flow",
      "code": {
        "rust": "/// Traffic Flow Model (Lighthill-Whitham-Richards)\n///\n/// Conservation law: ∂ρ/∂t + ∂q/∂x = 0\n/// Greenshields velocity: v(ρ) = v_max(1 - ρ/ρ_max)\n/// Flux: q(ρ) = ρ·v(ρ)\n///\n/// Reference: Haberman (2013), Section 12.4, pp. 570-585.\nfn main() {\n    let v_max = 100.0;    // km/h\n    let rho_max = 200.0;  // cars/km\n\n    println!(\"Traffic Flow Model\");\n    println!(\"Physical parameters:\");\n    println!(\"  v_max = {} km/h\", v_max);\n    println!(\"  ρ_max = {} cars/km\", rho_max);\n\n    // Characteristic speed: c(ρ) = v_max(1 - 2ρ/ρ_max)\n    let characteristic_speed = |rho: f64| v_max * (1.0 - 2.0 * rho / rho_max);\n\n    println!(\"\\nCharacteristic wave speeds:\");\n    println!(\"  ρ = 0: c = {:.1} km/h\", characteristic_speed(0.0));\n    println!(\"  ρ = {:.0}: c = {:.1} km/h\", rho_max/2.0, characteristic_speed(rho_max/2.0));\n    println!(\"  ρ = {:.0}: c = {:.1} km/h\", rho_max, characteristic_speed(rho_max));\n\n    // Shock analysis\n    let flux = |rho: f64| rho * v_max * (1.0 - rho / rho_max);\n    let shock_speed = (flux(0.0) - flux(rho_max/2.0)) / (0.0 - rho_max/2.0);\n\n    println!(\"\\nShock Speed:\");\n    println!(\"  v_shock = {:.1} km/h\", shock_speed);\n    println!(\"  → Traffic jam propagates backward\");\n}\n",
        "python": "\"\"\"Traffic Flow Model (Lighthill-Whitham-Richards)\n\nReference: Haberman (2013), Section 12.4, pp. 570-585.\n\"\"\"\nv_max = 100.0    # km/h\nrho_max = 200.0  # cars/km\n\nprint(\"Traffic Flow Model\")\nprint(\"Physical parameters:\")\nprint(f\"  v_max = {v_max} km/h\")\nprint(f\"  ρ_max = {rho_max} cars/km\")\n\n# Characteristic speed\ndef characteristic_speed(rho):\n    return v_max * (1.0 - 2.0 * rho / rho_max)\n\nprint(\"\\nCharacteristic wave speeds:\")\nprint(f\"  ρ = 0: c = {characteristic_speed(0.0):.1f} km/h\")\nprint(f\"  ρ = {rho_max/2:.0f}: c = {characteristic_speed(rho_max/2):.1f} km/h\")\nprint(f\"  ρ = {rho_max:.0f}: c = {characteristic_speed(rho_max):.1f} km/h\")\n\n# Shock analysis\ndef flux(rho):\n    return rho * v_max * (1.0 - rho / rho_max)\n\nshock_speed = (flux(0.0) - flux(rho_max/2)) / (0.0 - rho_max/2)\nprint(f\"\\nShock Speed: {shock_speed:.1f} km/h\")\nprint(\"  → Traffic jam propagates backward\")\n",
        "nodejs": "/**\n * Traffic Flow Model (Lighthill-Whitham-Richards)\n *\n * Reference: Haberman (2013), Section 12.4, pp. 570-585.\n */\nconst vMax = 100.0;    // km/h\nconst rhoMax = 200.0;  // cars/km\n\nconsole.log(\"Traffic Flow Model\");\nconsole.log(\"Physical parameters:\");\nconsole.log(`  v_max = ${vMax} km/h`);\nconsole.log(`  ρ_max = ${rhoMax} cars/km`);\n\n// Characteristic speed\nconst characteristicSpeed = (rho) => vMax * (1.0 - 2.0 * rho / rhoMax);\n\nconsole.log(\"\\nCharacteristic wave speeds:\");\nconsole.log(`  ρ = 0: c = ${characteristicSpeed(0.0).toFixed(1)} km/h`);\nconsole.log(`  ρ = ${(rhoMax/2).toFixed(0)}: c = ${characteristicSpeed(rhoMax/2).toFixed(1)} km/h`);\nconsole.log(`  ρ = ${rhoMax.toFixed(0)}: c = ${characteristicSpeed(rhoMax).toFixed(1)} km/h`);\n\n// Shock analysis\nconst flux = (rho) => rho * vMax * (1.0 - rho / rhoMax);\nconst shockSpeed = (flux(0.0) - flux(rhoMax/2)) / (0.0 - rhoMax/2);\n\nconsole.log(`\\nShock Speed: ${shockSpeed.toFixed(1)} km/h`);\nconsole.log(\"  → Traffic jam propagates backward\");\n"
      }
    }
  ],
  "article": {
    "content": "# PDE Technical Guide - Mathematical Foundation and Implementation\n\n**Audience:** Mathematicians, researchers, advanced students\n**Prerequisites:** Multivariable calculus, ODE theory, functional analysis basics\n**Depth:** Rigorous mathematical treatment with proofs and references\n\n[Complete technical content from original markdown covering all sections]\n"
  },
  "use_cases": [
    "Rigorous PDE theory research",
    "Advanced mathematical analysis of PDE solutions",
    "Shock formation and weak solution theory",
    "Conservation law applications in physics",
    "Traffic flow and fluid dynamics modeling",
    "Groundwater contaminant transport analysis",
    "Graduate-level PDE education"
  ],
  "related_topics": [
    "advanced.pde.user_guide",
    "advanced.pde.registry",
    "advanced.pde.sympy_validation",
    "advanced.pde.performance"
  ],
  "performance": {
    "complexity": "O(N·M) for N time steps and M characteristics",
    "typical_time": "Varies by problem complexity"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}