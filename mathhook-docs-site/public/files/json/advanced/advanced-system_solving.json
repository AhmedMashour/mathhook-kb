{
  "topic": "advanced.system_solving",
  "title": "System of Equations Solving",
  "description": "Solve systems of equations (linear and nonlinear) with multiple unknowns\nusing substitution, elimination, matrix methods, and Newton's method for\nnonlinear systems.\n",
  "mathematical_definition": "Linear system matrix form: $$Ax = b$$\nwhere $A$ is coefficient matrix, $x$ is unknown vector, $b$ is constant vector\n\nSolution (unique): $$x = A^{-1}b$$ when $\\det(A) \\neq 0$\n\nLeast squares (overdetermined): $$x_{LS} = (A^T A)^{-1} A^T b$$\n",
  "code_refs": {
    "rust": "mathhook_core::solvers::system",
    "python": "mathhook.solvers.system",
    "nodejs": "mathhook.solvers.system"
  },
  "examples": [
    {
      "title": "Linear System (2×2)",
      "explanation": "Solve { 2x + y = 5, x - y = 1 }",
      "code": {
        "rust": "let x = symbol!(x);\nlet y = symbol!(y);\n\n// Method 1: Equations as list\nlet solver = SystemSolver::new();\nlet equations = vec![\n    expr!(2*x + y - 5),\n    expr!(x - y - 1),\n];\nlet vars = vec![x.clone(), y.clone()];\n\nlet solution = solver.solve_system(&equations, &vars);\n// Result: { x = 2, y = 1 }\n\n// Method 2: Matrix form Ax = b\nlet A = Expression::matrix(vec![\n    vec![expr!(2), expr!(1)],\n    vec![expr!(1), expr!(-1)],\n]);\nlet b = Expression::matrix(vec![\n    vec![expr!(5)],\n    vec![expr!(1)],\n]);\n\nlet solution_matrix = expr!(A^(-1) * b);\n// Result: [[2], [1]]\n",
        "python": "from sympy import symbols, solve, Matrix\n\nx, y = symbols('x y')\n\n# Method 1: Equations\nequations = [2*x + y - 5, x - y - 1]\nsolution = solve(equations, [x, y])\n# Result: {x: 2, y: 1}\n\n# Method 2: Matrix form\nA = Matrix([[2, 1], [1, -1]])\nb = Matrix([[5], [1]])\nsolution_matrix = A.inv() * b\n# Result: Matrix([[2], [1]])\n",
        "nodejs": "const x = symbol('x');\nconst y = symbol('y');\n\n// Equations\nconst equations = [\n    sub(add(mul(2, x), y), 5),\n    sub(sub(x, y), 1)\n];\n\nconst solution = solve(equations, [x, y]);\n// Result: {x: 2, y: 1}\n\n// Matrix form\nconst A = matrix([[2, 1], [1, -1]]);\nconst b = matrix([[5], [1]]);\nconst sol = A.inv().mul(b);\n"
      }
    },
    {
      "title": "Nonlinear System",
      "explanation": "Solve { x^2 + y^2 = 25, x + y = 5 }",
      "code": {
        "rust": "let x = symbol!(x);\nlet y = symbol!(y);\n\n// Step 1: Solve linear for y: y = 5 - x\n// Step 2: Substitute into nonlinear\nlet substituted = expr!(x^2 + (5 - x)^2 - 25);\n// Simplifies to: 2x^2 - 10x = 0 → x(x - 5) = 0\n\n// Solutions: x = 0 or x = 5\n// Corresponding y values: y = 5 or y = 0\n// Two solutions: (0, 5) and (5, 0)\n",
        "python": "from sympy import symbols, solve\n\nx, y = symbols('x y')\n\nequations = [x**2 + y**2 - 25, x + y - 5]\nsolutions = solve(equations, [x, y])\n# Result: [(0, 5), (5, 0)]\n",
        "nodejs": "const x = symbol('x');\nconst y = symbol('y');\n\nconst equations = [\n    sub(add(pow(x, 2), pow(y, 2)), 25),\n    sub(add(x, y), 5)\n];\n\nconst solutions = solve(equations, [x, y]);\n// Result: [[0, 5], [5, 0]]\n"
      }
    },
    {
      "title": "Three Variables",
      "explanation": "Solve { x + y + z = 6, 2x - y + z = 3, x + 2y - z = 2 }",
      "code": {
        "rust": "let x = symbol!(x);\nlet y = symbol!(y);\nlet z = symbol!(z);\n\n// Matrix form\nlet A = Expression::matrix(vec![\n    vec![expr!(1), expr!(1), expr!(1)],\n    vec![expr!(2), expr!(-1), expr!(1)],\n    vec![expr!(1), expr!(2), expr!(-1)],\n]);\n\nlet b = Expression::matrix(vec![\n    vec![expr!(6)],\n    vec![expr!(3)],\n    vec![expr!(2)],\n]);\n\nlet solution = expr!(A^(-1) * b);\n// Result: x = 1, y = 2, z = 3\n",
        "python": "from sympy import symbols, solve, Matrix\n\nx, y, z = symbols('x y z')\n\nA = Matrix([[1, 1, 1], [2, -1, 1], [1, 2, -1]])\nb = Matrix([[6], [3], [2]])\n\nsolution = A.inv() * b\n# Result: Matrix([[1], [2], [3]])\n",
        "nodejs": "const [x, y, z] = symbols(['x', 'y', 'z']);\n\nconst A = matrix([[1, 1, 1], [2, -1, 1], [1, 2, -1]]);\nconst b = matrix([[6], [3], [2]]);\n\nconst solution = A.inv().mul(b);\n"
      }
    },
    {
      "title": "Overdetermined System (Least Squares)",
      "explanation": "More equations than unknowns: find best approximate solution",
      "code": {
        "rust": "// System: { x + y = 1, 2x + 2y = 3, x - y = 0 }\n// Inconsistent! Use least squares.\n\nlet A = Expression::matrix(vec![\n    vec![expr!(1), expr!(1)],\n    vec![expr!(2), expr!(2)],\n    vec![expr!(1), expr!(-1)],\n]);\n\nlet b = Expression::matrix(vec![\n    vec![expr!(1)],\n    vec![expr!(3)],\n    vec![expr!(0)],\n]);\n\n// Least squares: (A^T A)^(-1) A^T b\nlet AT = expr!(transpose(A));\nlet ATA = expr!(AT * A);\nlet ATA_inv = expr!(ATA^(-1));\nlet ATb = expr!(AT * b);\n\nlet x_ls = expr!(ATA_inv * ATb);\n// Result: Best approximate solution\n",
        "python": "from sympy import Matrix\n\nA = Matrix([[1, 1], [2, 2], [1, -1]])\nb = Matrix([[1], [3], [0]])\n\n# Least squares\nx_ls = (A.T * A).inv() * A.T * b\n",
        "nodejs": "const A = matrix([[1, 1], [2, 2], [1, -1]]);\nconst b = matrix([[1], [3], [0]]);\n\n// Least squares\nconst AT = A.transpose();\nconst x_ls = AT.mul(A).inv().mul(AT).mul(b);\n"
      }
    }
  ],
  "use_cases": [
    "Physics: Coupled oscillators, force balance",
    "Economics: Equilibrium models, supply-demand",
    "Engineering: Structural analysis, control systems",
    "Chemistry: Reaction networks, stoichiometry"
  ],
  "related_topics": [
    "advanced.matrices",
    "operations.solving",
    "advanced.noncommutative_algebra",
    "operations.substitution"
  ],
  "performance": {
    "complexity": "O(n^3) for n×n systems",
    "typical_time": "< 1ms for 3×3, seconds for 100×100"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}