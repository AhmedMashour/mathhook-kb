{
  "topic": "advanced.pde.sympy_validation",
  "title": "SymPy Validation Workflow",
  "description": "SymPy serves as the authoritative reference for validating MathHook PDE solvers. With 15+ years\nof development, extensive test coverage, and academic validation, SymPy provides a reliable\nbaseline for comparing solution structures, eigenvalues, and boundary condition satisfaction.\nThis workflow is used internally for validation only; public documentation cites textbooks.\n",
  "mathematical_definition": "Validation criteria for PDE solutions:\n\n1. **Solution Structure Match**: Both implementations produce equivalent forms\n2. **Eigenvalue Formula**: $$\\lambda_n = \\left(\\frac{n\\pi}{L}\\right)^2$$ matches numerically\n3. **Boundary Conditions**: $$u(0,t) = 0, \\quad u(L,t) = 0$$ satisfied\n4. **Temporal Behavior**: $$\\exp(-\\lambda_n \\alpha t)$$ matches across implementations\n",
  "code_refs": {
    "rust": "mathhook_core::pde::validation",
    "python": "mathhook.pde.validation",
    "nodejs": "mathhook.pde.validation"
  },
  "examples": [
    {
      "title": "Heat Equation Validation",
      "explanation": "Compare MathHook solution with SymPy reference for heat equation",
      "code": {
        "rust": "#[test]\nfn test_heat_vs_sympy_dirichlet() {\n    // MathHook solution\n    let result = solve_heat_1d(...)?;\n\n    // SymPy reference (computed offline)\n    let expected_lambda_1 = 9.8696;  // π²\n\n    // Validate eigenvalue\n    let lambda_1 = result.eigenvalues[0].evaluate()?;\n    assert!((lambda_1 - expected_lambda_1).abs() < 1e-4);\n}\n",
        "python": "def test_heat_vs_sympy_dirichlet():\n    # MathHook solution (via Python bindings)\n    result = solve_heat_1d(...)\n\n    # SymPy reference\n    expected_lambda_1 = 9.8696  # π²\n\n    # Validate eigenvalue\n    lambda_1 = result.eigenvalues[0].evaluate()\n    assert abs(lambda_1 - expected_lambda_1) < 1e-4\n",
        "nodejs": "test('heat equation matches SymPy', () => {\n    // MathHook solution\n    const result = solveHeat1d(...);\n\n    // SymPy reference\n    const expectedLambda1 = 9.8696;  // π²\n\n    // Validate eigenvalue\n    const lambda1 = result.eigenvalues[0].evaluate();\n    expect(Math.abs(lambda1 - expectedLambda1)).toBeLessThan(1e-4);\n});\n"
      }
    },
    {
      "title": "Eigenvalue Scaling Validation",
      "explanation": "Test eigenvalue scaling with different domain lengths",
      "code": {
        "rust": "#[test]\nfn test_heat_eigenvalues_scaling() {\n    // L = 1: λ₁ = π²\n    // L = 2: λ₁ = (π/2)² = π²/4\n    // L = 0.5: λ₁ = (π/0.5)² = 4π²\n\n    let L = 2.0;\n    let result = solve_heat_1d_with_length(L)?;\n    let expected = std::f64::consts::PI.powi(2) / 4.0;\n    assert!((result.eigenvalues[0].evaluate()? - expected).abs() < 1e-4);\n}\n",
        "python": "def test_heat_eigenvalues_scaling():\n    # L = 1: λ₁ = π²\n    # L = 2: λ₁ = (π/2)² = π²/4\n    # L = 0.5: λ₁ = (π/0.5)² = 4π²\n\n    L = 2.0\n    result = solve_heat_1d_with_length(L)\n    expected = (math.pi ** 2) / 4.0\n    assert abs(result.eigenvalues[0].evaluate() - expected) < 1e-4\n",
        "nodejs": "test('heat eigenvalues scale correctly', () => {\n    // L = 1: λ₁ = π²\n    // L = 2: λ₁ = (π/2)² = π²/4\n    // L = 0.5: λ₁ = (π/0.5)² = 4π²\n\n    const L = 2.0;\n    const result = solveHeat1dWithLength(L);\n    const expected = (Math.PI ** 2) / 4.0;\n    expect(Math.abs(result.eigenvalues[0].evaluate() - expected)).toBeLessThan(1e-4);\n});\n"
      }
    },
    {
      "title": "Wave Equation Frequency Validation",
      "explanation": "Verify wave equation frequencies against SymPy",
      "code": {
        "rust": "#[test]\nfn test_wave_frequencies_vs_sympy() {\n    let c = 340.0;  // m/s (speed of sound)\n    let L = 1.0;    // m\n\n    let result = solve_wave_1d(...)?;\n\n    // SymPy: ω_n = n*π*c/L\n    let omega_1 = std::f64::consts::PI * c / L;\n    let f_1 = omega_1 / (2.0 * std::f64::consts::PI);  // Frequency in Hz\n\n    // MathHook eigenvalues: λ_n = (nπ/L)²\n    // ω_n = c*√λ_n = c*nπ/L\n    let lambda_1 = result.eigenvalues[0].evaluate()?;\n    let omega_mathhook = c * lambda_1.sqrt();\n\n    assert!((omega_mathhook - omega_1).abs() < 1e-6);\n}\n",
        "python": "def test_wave_frequencies_vs_sympy():\n    c = 340.0  # m/s (speed of sound)\n    L = 1.0    # m\n\n    result = solve_wave_1d(...)\n\n    # SymPy: ω_n = n*π*c/L\n    omega_1 = math.pi * c / L\n    f_1 = omega_1 / (2.0 * math.pi)  # Frequency in Hz\n\n    # MathHook eigenvalues: λ_n = (nπ/L)²\n    # ω_n = c*√λ_n = c*nπ/L\n    lambda_1 = result.eigenvalues[0].evaluate()\n    omega_mathhook = c * math.sqrt(lambda_1)\n\n    assert abs(omega_mathhook - omega_1) < 1e-6\n",
        "nodejs": "test('wave equation frequencies match SymPy', () => {\n    const c = 340.0;  // m/s (speed of sound)\n    const L = 1.0;    // m\n\n    const result = solveWave1d(...);\n\n    // SymPy: ω_n = n*π*c/L\n    const omega1 = Math.PI * c / L;\n    const f1 = omega1 / (2.0 * Math.PI);  // Frequency in Hz\n\n    // MathHook eigenvalues: λ_n = (nπ/L)²\n    // ω_n = c*√λ_n = c*nπ/L\n    const lambda1 = result.eigenvalues[0].evaluate();\n    const omegaMathhook = c * Math.sqrt(lambda1);\n\n    expect(Math.abs(omegaMathhook - omega1)).toBeLessThan(1e-6);\n});\n"
      }
    }
  ],
  "article": {
    "content": "# SymPy Validation Workflow\n\n## Why SymPy is the Reference Implementation\n\n**SymPy** (`~/Documents/work/math/sympy/`) is the **authoritative reference** for validating MathHook PDE solvers for the following reasons:\n\n1. **Mature and Battle-Tested**: SymPy's PDE solving has been developed and refined over 15+ years\n2. **Extensive Test Suite**: Thousands of test cases covering edge cases\n3. **Academic Validation**: Used in research and education worldwide\n4. **Well-Documented**: Clear mathematical foundations and algorithms\n5. **Python MCP Available**: Can be queried programmatically for validation\n\n**Important**: SymPy is used **internally** for validation only. Public documentation cites textbooks and papers, NOT SymPy.\n\n## Validation Workflow\n\n### Step 1: Define Problem in Both Systems\n\nDefine the same PDE problem in both MathHook (Rust) and SymPy (Python) to enable comparison.\n\n### Step 2: Compare Solution Structure\n\n**Validation criteria**:\n- ✅ Structure matches (sine modes, exponential decay)\n- ✅ Eigenvalue formula matches: $\\lambda_n = (n\\pi/L)^2$\n- ✅ Both use symbolic coefficients\n- ✅ Temporal behavior matches: $\\exp(-\\lambda_n \\alpha t)$\n\n### Step 3: Verify Eigenvalues Numerically\n\nCompare computed eigenvalues with high precision (typically < 1e-4 relative error).\n\n### Step 4: Validate Boundary Condition Satisfaction\n\nSymPy can verify BC satisfaction through symbolic substitution. MathHook returns symbolic\nsolutions that can be validated manually or programmatically.\n\n## Validation Test Cases\n\n### Heat Equation\n\n**Test 1: Dirichlet BCs, constant IC**\n- Verify eigenvalue: λ₁ = π² ≈ 9.8696\n- Check solution structure matches SymPy\n\n**Test 2: Different domain lengths**\n- L = 1: λ₁ = π²\n- L = 2: λ₁ = (π/2)² = π²/4\n- L = 0.5: λ₁ = (π/0.5)² = 4π²\n\n### Wave Equation\n\n**Test 1: Standing wave frequencies**\n- Compare angular frequencies: ω_n = n*π*c/L\n- Verify relationship: ω_n = c*√λ_n\n\n### Laplace Equation\n\n**Test 1: Rectangular domain eigenvalues**\n- Verify 2D eigenvalue formula: λₙ = (nπ/a)²\n\n## Known Differences (Acceptable)\n\n### 1. Coefficient Representation\n\n**SymPy**: Uses `Sum()` with index notation\n```python\nSum(C_n * sin(n*pi*x/L) * exp(-n²*pi²*alpha*t/L²), (n, 1, oo))\n```\n\n**MathHook**: Expands finite sum explicitly\n```rust\nA_1*sin(π*x)*exp(-π²*α*t) + A_2*sin(2π*x)*exp(-4π²*α*t) + ...\n```\n\n**Why acceptable**: Both representations are mathematically equivalent. MathHook finite sum is more practical for numerical evaluation.\n\n### 2. Variable Naming\n\n**SymPy**: Uses function notation `u(x,t)`\n\n**MathHook**: Uses symbol `u` with independent variables as context\n\n**Why acceptable**: Notational difference only; mathematical content identical.\n\n### 3. Symbolic vs Numerical Coefficients\n\n**Both return symbolic coefficients** for Fourier series. SymPy requires separate `fourier_series()` call; MathHook plans integration in Phase 2.\n\n**Why acceptable**: Both defer coefficient computation to avoid integration challenges.\n\n## Validation Checklist\n\nBefore claiming a PDE solver is correct:\n\n1. ✅ **Solution structure** matches SymPy (sine/cosine modes, exp/sinh/cosh temporal)\n2. ✅ **Eigenvalue formula** matches SymPy (verified numerically)\n3. ✅ **Boundary conditions** satisfied when substituted\n4. ✅ **Initial conditions** structure correct (even if coefficients symbolic)\n5. ✅ **Edge cases** tested (different domain lengths, BCs)\n6. ✅ **Known limitations** documented (Neumann BCs, non-homogeneous BCs, etc.)\n\n## SymPy MCP Integration\n\n**Available via MCP**: SymPy can be queried programmatically for validation.\n\n**Example workflow**:\n1. Agent implements new MathHook PDE solver\n2. Agent queries SymPy MCP for reference solution\n3. Agent compares eigenvalues, solution structure\n4. Agent verifies BCs/ICs satisfied\n5. Agent documents any acceptable differences\n6. Agent adds regression tests\n\n**Important**: SymPy MCP is for **internal validation**, NOT cited in public documentation.\n\n## Mathematical References (For Public Documentation)\n\nWhen documenting PDE solvers, cite these instead of SymPy:\n\n1. **Strauss, Walter A.** *Partial Differential Equations: An Introduction*, 2nd ed.\n2. **Evans, Lawrence C.** *Partial Differential Equations*, 2nd ed.\n3. **Haberman, Richard** *Applied Partial Differential Equations*, 5th ed.\n\n## Summary\n\n**SymPy Validation Workflow**:\n1. Implement solver in MathHook\n2. Compare solution structure with SymPy\n3. Verify eigenvalues numerically\n4. Test BC/IC satisfaction\n5. Document acceptable differences\n6. Add regression tests\n\n**Validation Criteria**:\n- ✅ Structure matches\n- ✅ Eigenvalues match (numerical verification)\n- ✅ BCs/ICs satisfied\n- ⚠️ Symbolic coefficients acceptable (both implementations)\n"
  },
  "use_cases": [
    "Internal validation of MathHook PDE solver correctness",
    "Regression testing against reference implementation",
    "Cross-validation of eigenvalue computations",
    "Verification of boundary condition satisfaction",
    "Quality assurance for PDE solution structures"
  ],
  "related_topics": [
    "advanced.pde.registry",
    "advanced.pde.performance",
    "advanced.pde.technical_guide",
    "advanced.pde.user_guide"
  ],
  "performance": {
    "complexity": "O(n)",
    "typical_time": "Varies by test complexity"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}