{
  "topic": "api.parser.latex",
  "title": "LaTeX Parsing and Mathematical Notation",
  "description": "Parse and generate LaTeX notation for mathematical expressions. Full bidirectional\nsupport: LaTeX → Expression and Expression → LaTeX. Automatic type inference for\nmatrix symbols (\\mathbf{A}), operator symbols (\\hat{p}), and implicit multiplication.\n",
  "code_refs": {
    "rust": "mathhook_core::parser::{Parser, ParserConfig}",
    "python": "mathhook.parser.parse_latex",
    "nodejs": "mathhook.parser.parseLatex"
  },
  "examples": [
    {
      "title": "Basic LaTeX Parsing",
      "explanation": "Parse standard mathematical expressions",
      "code": {
        "rust": "use mathhook::parser::{Parser, ParserConfig};\n\nlet parser = Parser::new(ParserConfig::default());\n\n// Basic arithmetic\nlet expr = parser.parse(r\"2 + 3 \\cdot 4\")?;  // 2 + 3*4\n\n// Fractions\nlet expr = parser.parse(r\"\\frac{x^2 + 1}{x - 1}\")?;\n\n// Functions\nlet expr = parser.parse(r\"\\sin(x) + \\cos(y)\")?;\n\n// Square roots\nlet expr = parser.parse(r\"\\sqrt{x^2 + y^2}\")?;\n\n// Exponents\nlet expr = parser.parse(r\"e^{-x^2}\")?;  // Gaussian\n",
        "python": "from mathhook.parser import parse_latex\n\n# Basic arithmetic\nexpr = parse_latex(r\"2 + 3 \\cdot 4\")  # 2 + 3*4\n\n# Fractions\nexpr = parse_latex(r\"\\frac{x^2 + 1}{x - 1}\")\n\n# Functions\nexpr = parse_latex(r\"\\sin(x) + \\cos(y)\")\n\n# Square roots\nexpr = parse_latex(r\"\\sqrt{x^2 + y^2}\")\n\n# Exponents\nexpr = parse_latex(r\"e^{-x^2}\")\n",
        "nodejs": "import { parseLatex } from 'mathhook';\n\n// Basic arithmetic\nconst expr = parseLatex(String.raw`2 + 3 \\cdot 4`);\n\n// Fractions\nconst expr2 = parseLatex(String.raw`\\frac{x^2 + 1}{x - 1}`);\n\n// Functions\nconst expr3 = parseLatex(String.raw`\\sin(x) + \\cos(y)`);\n\n// Square roots\nconst expr4 = parseLatex(String.raw`\\sqrt{x^2 + y^2}`);\n"
      }
    },
    {
      "title": "Greek Letters and Constants",
      "explanation": "Parse Greek symbols and mathematical constants",
      "code": {
        "rust": "use mathhook::parser::Parser;\n\nlet parser = Parser::new(ParserConfig::default());\n\n// Greek symbols (lowercase)\nlet expr = parser.parse(r\"\\alpha + \\beta + \\gamma\")?;\n\n// Greek symbols (uppercase functions)\nlet expr = parser.parse(r\"\\Gamma(n)\")?;  // Gamma function\n\n// Mathematical constants\nlet expr = parser.parse(r\"\\pi r^2\")?;          // π*r²\nlet expr = parser.parse(r\"e^{i\\pi} + 1\")?;     // Euler's identity\nlet expr = parser.parse(r\"\\phi = \\frac{1+\\sqrt{5}}{2}\")?;  // Golden ratio\n",
        "python": "from mathhook.parser import parse_latex\n\n# Greek symbols\nexpr = parse_latex(r\"\\alpha + \\beta + \\gamma\")\n\n# Gamma function\nexpr = parse_latex(r\"\\Gamma(n)\")\n\n# Constants\nexpr = parse_latex(r\"\\pi r^2\")\nexpr = parse_latex(r\"e^{i\\pi} + 1\")\nexpr = parse_latex(r\"\\phi = \\frac{1+\\sqrt{5}}{2}\")\n",
        "nodejs": "import { parseLatex } from 'mathhook';\n\n// Greek symbols\nconst expr = parseLatex(String.raw`\\alpha + \\beta + \\gamma`);\n\n// Gamma function\nconst expr2 = parseLatex(String.raw`\\Gamma(n)`);\n\n// Constants\nconst expr3 = parseLatex(String.raw`\\pi r^2`);\nconst expr4 = parseLatex(String.raw`e^{i\\pi} + 1`);\n"
      }
    },
    {
      "title": "Matrix and Operator Symbols",
      "explanation": "Automatic type inference from LaTeX notation",
      "code": {
        "rust": "use mathhook::parser::Parser;\n\nlet parser = Parser::new(ParserConfig::default());\n\n// Matrix symbols (bold, noncommutative)\nlet expr = parser.parse(r\"\\mathbf{A} \\mathbf{B}\")?;\n// Creates: symbol!(A; matrix) * symbol!(B; matrix)\n\n// Operator symbols (quantum mechanics)\nlet expr = parser.parse(r\"\\hat{p} \\hat{x}\")?;\n// Creates: symbol!(p; operator) * symbol!(x; operator)\n\n// Mixed scalar and matrix\nlet expr = parser.parse(r\"x \\mathbf{A}\")?;\n// Creates: symbol!(x) * symbol!(A; matrix)\n",
        "python": "from mathhook.parser import parse_latex\n\n# Matrix symbols (automatic inference)\nexpr = parse_latex(r\"\\mathbf{A} \\mathbf{B}\")\n# Creates matrix symbols A, B\n\n# Operator symbols\nexpr = parse_latex(r\"\\hat{p} \\hat{x}\")\n# Creates operator symbols p, x\n\n# Mixed\nexpr = parse_latex(r\"x \\mathbf{A}\")\n",
        "nodejs": "import { parseLatex } from 'mathhook';\n\n// Matrix symbols\nconst expr = parseLatex(String.raw`\\mathbf{A} \\mathbf{B}`);\n\n// Operator symbols\nconst expr2 = parseLatex(String.raw`\\hat{p} \\hat{x}`);\n\n// Mixed scalar and matrix\nconst expr3 = parseLatex(String.raw`x \\mathbf{A}`);\n"
      }
    },
    {
      "title": "Generating LaTeX Output",
      "explanation": "Convert expressions back to LaTeX",
      "code": {
        "rust": "use mathhook::prelude::*;\nuse mathhook::formatter::latex::LaTeXFormatter;\n\nlet x = symbol!(x);\n\n// Simple expression\nlet expr = expr!(x^2 / 2);\nlet latex = expr.to_latex(None)?;\n// Returns: \"\\frac{x^{2}}{2}\"\n\n// Matrix expression\nlet A = symbol!(A; matrix);\nlet B = symbol!(B; matrix);\nlet expr = expr!(A * B);\nlet latex = expr.to_latex(None)?;\n// Returns: \"\\mathbf{A}\\mathbf{B}\"\n\n// Complex expression\nlet expr = expr!(sin(x) + cos(x^2));\nlet latex = expr.to_latex(None)?;\n// Returns: \"\\sin\\left(x\\right) + \\cos\\left(x^{2}\\right)\"\n",
        "python": "from mathhook import symbol\nfrom mathhook.formatter import to_latex\n\nx = symbol('x')\n\n# Simple expression\nexpr = x**2 / 2\nlatex = to_latex(expr)\n# Returns: \"\\frac{x^{2}}{2}\"\n\n# Matrix expression\nA = symbol('A', matrix=True)\nB = symbol('B', matrix=True)\nexpr = A * B\nlatex = to_latex(expr)\n# Returns: \"\\mathbf{A}\\mathbf{B}\"\n",
        "nodejs": "import { symbol, parse, toLatex } from 'mathhook';\n\nconst x = symbol('x');\n\n// Simple expression\nconst expr = parse('x^2 / 2');\nconst latex = toLatex(expr);\n// Returns: \"\\frac{x^{2}}{2}\"\n\n// Matrix expression\nconst A = symbol('A', { type: 'matrix' });\nconst B = symbol('B', { type: 'matrix' });\nconst expr2 = parse('A * B');\nconst latex2 = toLatex(expr2);\n// Returns: \"\\mathbf{A}\\mathbf{B}\"\n"
      }
    },
    {
      "title": "Implicit Multiplication",
      "explanation": "Automatic insertion of multiplication operators",
      "code": {
        "rust": "use mathhook::parser::Parser;\n\nlet parser = Parser::new(ParserConfig::default());\n\n// Number-variable: 2x → 2*x\nlet expr = parser.parse(\"2x\")?;\n\n// Parentheses: (a)(b) → a*b\nlet expr = parser.parse(\"(a)(b)\")?;\n\n// Functions: sin(x)cos(y) → sin(x)*cos(y)\nlet expr = parser.parse(r\"\\sin(x)\\cos(y)\")?;\n\n// Mixed: 2πr → 2*π*r\nlet expr = parser.parse(r\"2\\pi r\")?;\n",
        "python": "from mathhook.parser import parse_latex\n\n# Implicit multiplication handled automatically\nexpr = parse_latex(\"2x\")           # 2*x\nexpr = parse_latex(\"(a)(b)\")       # a*b\nexpr = parse_latex(r\"\\sin(x)\\cos(y)\")  # sin(x)*cos(y)\nexpr = parse_latex(r\"2\\pi r\")      # 2*π*r\n",
        "nodejs": "import { parseLatex } from 'mathhook';\n\n// Implicit multiplication\nconst expr = parseLatex(\"2x\");           // 2*x\nconst expr2 = parseLatex(\"(a)(b)\");      // a*b\nconst expr3 = parseLatex(String.raw`\\sin(x)\\cos(y)`);  // sin(x)*cos(y)\nconst expr4 = parseLatex(String.raw`2\\pi r`);  // 2*π*r\n"
      }
    },
    {
      "title": "Calculus Notation",
      "explanation": "Parse derivatives, integrals, limits",
      "code": {
        "rust": "use mathhook::parser::Parser;\n\nlet parser = Parser::new(ParserConfig::default());\n\n// Derivative notation\nlet expr = parser.parse(r\"\\frac{d}{dx} x^2\")?;\n\n// Integral notation\nlet expr = parser.parse(r\"\\int x^2 \\, dx\")?;\n\n// Definite integral\nlet expr = parser.parse(r\"\\int_0^1 x^2 \\, dx\")?;\n\n// Limit notation\nlet expr = parser.parse(r\"\\lim_{x \\to 0} \\frac{\\sin(x)}{x}\")?;\n\n// Summation\nlet expr = parser.parse(r\"\\sum_{i=1}^{n} i^2\")?;\n",
        "python": "from mathhook.parser import parse_latex\n\n# Derivative\nexpr = parse_latex(r\"\\frac{d}{dx} x^2\")\n\n# Integral\nexpr = parse_latex(r\"\\int x^2 \\, dx\")\n\n# Definite integral\nexpr = parse_latex(r\"\\int_0^1 x^2 \\, dx\")\n\n# Limit\nexpr = parse_latex(r\"\\lim_{x \\to 0} \\frac{\\sin(x)}{x}\")\n\n# Summation\nexpr = parse_latex(r\"\\sum_{i=1}^{n} i^2\")\n",
        "nodejs": "import { parseLatex } from 'mathhook';\n\n// Derivative\nconst expr = parseLatex(String.raw`\\frac{d}{dx} x^2`);\n\n// Integral\nconst expr2 = parseLatex(String.raw`\\int x^2 \\, dx`);\n\n// Definite integral\nconst expr3 = parseLatex(String.raw`\\int_0^1 x^2 \\, dx`);\n\n// Limit\nconst expr4 = parseLatex(String.raw`\\lim_{x \\to 0} \\frac{\\sin(x)}{x}`);\n"
      }
    }
  ],
  "article": {
    "content": "# LaTeX Parsing and Notation\n\n## Overview\n\nMathHook provides comprehensive LaTeX support:\n- **Bidirectional**: Parse LaTeX → Expression, Expression → LaTeX\n- **Type Inference**: `\\mathbf{A}` creates matrix symbols, `\\hat{p}` creates operators\n- **Implicit Multiplication**: Handles `2x`, `\\pi x`, `(a)(b)` correctly\n- **150+ Commands**: Functions, symbols, operators, calculus notation\n\n## Architecture\n\n### Two-Stage Processing\n\n**1. Lexer (Token Generation)**:\n- Inserts implicit multiplication tokens (`2x` → `2*x`)\n- Classifies tokens (number, identifier, function, operator)\n- O(1) HashMap lookups for LaTeX commands (`\\sin`, `\\pi`, `\\alpha`)\n\n**2. Parser (LALRPOP Grammar)**:\n- LR(1) parser with operator precedence\n- Right-associative exponentiation: `2^3^4` → `2^(3^4)`\n- Context-aware function resolution\n\n### Performance\n- >100K simple expressions/second\n- Thread-local caching for common expressions\n- Zero-copy string processing where possible\n\n## Supported LaTeX\n\n### Greek Letters\n- Lowercase: `\\alpha`, `\\beta`, `\\gamma`, ..., `\\omega`\n- Uppercase: `\\Gamma`, `\\Delta`, `\\Theta`, ..., `\\Omega`\n\n### Mathematical Constants\n- `\\pi`: π (pi)\n- `e`: Euler's number\n- `\\phi`: Golden ratio\n- `i`: Imaginary unit\n\n### Fractions and Roots\n- `\\frac{a}{b}`: Fractions\n- `\\sqrt{x}`: Square root\n- `\\sqrt[n]{x}`: nth root\n\n### Trigonometric Functions\n- `\\sin`, `\\cos`, `\\tan`, `\\cot`, `\\sec`, `\\csc`\n- `\\arcsin`, `\\arccos`, `\\arctan`\n- `\\sinh`, `\\cosh`, `\\tanh`\n\n### Calculus Notation\n- `\\int`: Integral\n- `\\frac{d}{dx}`: Derivative\n- `\\lim`: Limit\n- `\\sum`: Summation\n- `\\prod`: Product\n\n### Matrix Notation\n- `\\mathbf{A}`: Matrix symbol (bold, noncommutative)\n- `\\hat{p}`: Operator symbol (quantum mechanics)\n- `\\begin{matrix}...\\end{matrix}`: Matrix construction\n"
  },
  "use_cases": [
    "Academic publishing: Generate LaTeX for papers and textbooks",
    "Educational tools: Parse student LaTeX input for grading",
    "Web applications: Render mathematical expressions from LaTeX",
    "Documentation: Convert symbolic computations to publication-ready format",
    "Interoperability: Exchange expressions with LaTeX-based systems"
  ],
  "related_topics": [
    "api.parser.wolfram",
    "api.parser.custom",
    "api.core.expressions",
    "api.advanced.noncommutative_algebra"
  ],
  "performance": {
    "complexity": "O(n) for n-character LaTeX string"
  },
  "metadata": {
    "schema_version": "1.0"
  }
}