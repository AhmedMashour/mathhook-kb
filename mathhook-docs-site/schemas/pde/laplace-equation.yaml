topic: pde.laplace-equation
title: The Laplace Equation
description: |
  The Laplace equation is a fundamental elliptic PDE describing steady-state phenomena
  such as electrostatic potential, gravitational potential, and steady-state heat distribution.
  It represents equilibrium with no time dependence.

mathematical_definition: |
  $$\nabla^2 u = 0$$

  where $u$ is the potential function and $\nabla^2$ is the Laplacian operator.

  In 2D: $$\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = 0$$

  In 3D: $$\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2} = 0$$

code_refs:
  rust: mathhook_core::pde::laplace_equation
  python: mathhook.pde.laplace_equation
  nodejs: mathhook.pde.laplaceEquation

quick_reference:
  standard_form: "$\\nabla^2 u = 0$"
  type: "Elliptic PDE (steady-state, no time dependence)"
  principle: "Potential satisfies local averaging property"
  solution_methods:
    - "Separation of variables (rectangular, cylindrical, spherical coordinates)"
    - "Green's function method"
    - "Conformal mapping (2D)"
    - "Numerical methods (finite difference, finite element, boundary element)"
  key_properties:
    - "Maximum principle: extrema occur only on boundary"
    - "Mean value property: value = average over any sphere"
    - "Uniqueness: solution determined by boundary conditions"
    - "Harmonic functions: smooth and infinitely differentiable"

examples:
  - title: "2D Laplace Equation on Rectangle"
    explanation: |
      Solve Laplace equation on rectangle $[0,a] \times [0,b]$ with Dirichlet boundary conditions.

      Problem:
      $$\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} = 0$$

      Boundary conditions:
      - $u(0,y) = 0$
      - $u(a,y) = 0$
      - $u(x,0) = 0$
      - $u(x,b) = f(x)$ (non-zero top boundary)

      Solution:
      $$u(x,y) = \sum_{n=1}^{\infty} b_n \frac{\sinh(n\pi y/a)}{\sinh(n\pi b/a)} \sin\left(\frac{n\pi x}{a}\right)$$

      where $b_n = \frac{2}{a}\int_0^a f(x)\sin\left(\frac{n\pi x}{a}\right)dx$

    code:
      python: |
        from mathhook import pde, symbols, expr

        x, y, a, b = symbols('x y a b')
        u = pde.Function('u', [x, y])

        # Laplace equation
        laplace_eq = pde.laplace_equation(u, [x, y])

        # Boundary conditions
        bc_left = u.subs(x, 0) == 0
        bc_right = u.subs(x, a) == 0
        bc_bottom = u.subs(y, 0) == 0
        bc_top = u.subs(y, b) == expr('sin(pi*x/a)')  # Example: sine on top

        # Solve using separation of variables
        solution = pde.solve_laplace(
            laplace_eq,
            boundary_conditions={
                'left': bc_left,
                'right': bc_right,
                'bottom': bc_bottom,
                'top': bc_top
            },
            domain={'x': (0, a), 'y': (0, b)},
            method='separation_of_variables'
        )

        print(f"Solution: {solution}")

        # Evaluate at specific point
        u_center = solution.subs({x: a/2, y: b/2})
        print(f"u(a/2, b/2) = {u_center}")

      rust: |
        use mathhook::pde::*;

        let [x, y, a, b] = symbols![x, y, a, b];

        // Laplace equation
        let laplace_eq = LaplaceEquation::new(2); // 2D

        // Boundary conditions
        let bc = BoundaryConditions::rectangle()
            .left(expr!(0))
            .right(expr!(0))
            .bottom(expr!(0))
            .top(expr!(sin(pi * x / a)));

        // Solve
        let solution = laplace_eq.solve_separation_variables(
            &bc,
            Domain::rectangular((expr!(0), a), (expr!(0), b))
        );

        println!("Solution: {}", solution);

      nodejs: |
        const { pde, symbols, expr } = require('mathhook');

        const [x, y, a, b] = symbols('x', 'y', 'a', 'b');

        const solution = pde.solveLaplace({
          dimensions: 2,
          domain: { x: [0, a], y: [0, b] },
          boundaryConditions: {
            left: 0,
            right: 0,
            bottom: 0,
            top: expr('sin(pi*x/a)')
          },
          method: 'separationOfVariables'
        });

        const uCenter = solution.subs({ x: a/2, y: b/2 });
        console.log(`u(a/2, b/2) = ${uCenter}`);

    expected_output: |
      For $f(x) = \sin(\pi x/a)$, only $n=1$ term survives:
      $$u(x,y) = \frac{\sinh(\pi y/a)}{\sinh(\pi b/a)} \sin\left(\frac{\pi x}{a}\right)$$

  - title: "Polar Coordinates: Disk with Dirichlet Boundary"
    explanation: |
      Solve Laplace equation inside disk of radius $R$ with boundary condition $u(R,\theta) = f(\theta)$.

      In polar coordinates:
      $$\frac{1}{r}\frac{\partial}{\partial r}\left(r\frac{\partial u}{\partial r}\right) + \frac{1}{r^2}\frac{\partial^2 u}{\partial \theta^2} = 0$$

      General solution:
      $$u(r,\theta) = a_0 + \sum_{n=1}^{\infty} r^n(a_n\cos(n\theta) + b_n\sin(n\theta))$$

      For boundary $u(R,\theta) = f(\theta)$:
      $$u(r,\theta) = \frac{a_0}{2} + \sum_{n=1}^{\infty} \left(\frac{r}{R}\right)^n[a_n\cos(n\theta) + b_n\sin(n\theta)]$$

      where:
      - $a_0 = \frac{1}{\pi}\int_0^{2\pi} f(\theta)d\theta$
      - $a_n = \frac{1}{\pi}\int_0^{2\pi} f(\theta)\cos(n\theta)d\theta$
      - $b_n = \frac{1}{\pi}\int_0^{2\pi} f(\theta)\sin(n\theta)d\theta$

    code:
      python: |
        from mathhook import pde, symbols, expr
        import numpy as np

        r, theta, R = symbols('r theta R')

        # Laplace in polar coordinates
        laplace_polar = pde.laplace_polar(r, theta)

        # Boundary condition (example: theta)
        boundary_func = theta  # u(R, theta) = theta

        # Solve using Fourier series
        solution = pde.solve_laplace_disk(
            radius=R,
            boundary_condition=boundary_func,
            max_modes=50
        )

        print(f"Solution: {solution}")

        # Poisson integral formula (alternative)
        def poisson_kernel(r_val, theta_val, theta_prime, R_val):
            """Poisson kernel for disk"""
            numerator = R_val**2 - r_val**2
            denominator = R_val**2 - 2*R_val*r_val*np.cos(theta_val - theta_prime) + r_val**2
            return numerator / denominator

        def evaluate_disk_solution(f_boundary, r_val, theta_val, R_val):
            """Evaluate using Poisson integral formula"""
            from scipy.integrate import quad

            def integrand(theta_prime):
                kernel = poisson_kernel(r_val, theta_val, theta_prime, R_val)
                return f_boundary(theta_prime) * kernel

            result, _ = quad(integrand, 0, 2*np.pi)
            return result / (2*np.pi)

        # Example evaluation
        u_center = evaluate_disk_solution(
            lambda t: t,  # boundary = theta
            r_val=0,
            theta_val=0,
            R_val=1.0
        )
        print(f"u(0, 0) = {u_center}")  # Should be π (average of boundary)

      rust: |
        use mathhook::pde::*;

        let [r, theta, R] = symbols![r, theta, R];

        // Laplace in polar coordinates
        let laplace_polar = LaplaceEquation::polar();

        // Boundary condition
        let bc = expr!(theta);  // u(R, theta) = theta

        // Solve
        let solution = laplace_polar.solve_disk(R, bc, 50);

        // Evaluate at center (should be average of boundary)
        let u_center = solution.substitute(&r, &expr!(0));

      nodejs: |
        const { pde, symbols, expr } = require('mathhook');

        const [r, theta, R] = symbols('r', 'theta', 'R');

        const solution = pde.solveLaplaceDisk({
          radius: R,
          boundaryCondition: theta,
          maxModes: 50
        });

        // Poisson integral formula
        const uCenter = pde.poissonIntegral({
          boundaryFunction: theta,
          r: 0,
          theta: 0,
          R: 1
        });

    expected_output: |
      For $f(\theta) = \theta$:
      $$u(r,\theta) = \pi + 2\sum_{n=1}^{\infty} \frac{(-1)^{n+1}}{n}\left(\frac{r}{R}\right)^n \sin(n\theta)$$

      At center: $u(0,\theta) = \pi$ (average of boundary values)

  - title: "Spherical Harmonics: 3D Laplace on Sphere"
    explanation: |
      Solve Laplace equation outside or inside a sphere using spherical coordinates.

      In spherical coordinates $(r,\theta,\phi)$:
      $$\frac{1}{r^2}\frac{\partial}{\partial r}\left(r^2\frac{\partial u}{\partial r}\right) + \frac{1}{r^2\sin\theta}\frac{\partial}{\partial \theta}\left(\sin\theta\frac{\partial u}{\partial \theta}\right) + \frac{1}{r^2\sin^2\theta}\frac{\partial^2 u}{\partial \phi^2} = 0$$

      General solution:
      $$u(r,\theta,\phi) = \sum_{l=0}^{\infty}\sum_{m=-l}^{l} \left[A_{lm}r^l + B_{lm}r^{-(l+1)}\right] Y_l^m(\theta,\phi)$$

      where $Y_l^m$ are spherical harmonics.

    code:
      python: |
        from mathhook import pde, symbols, special

        r, theta, phi, R = symbols('r theta phi R')

        # Spherical harmonics basis
        Y_lm = special.spherical_harmonic

        # Laplace equation in spherical coordinates
        laplace_spherical = pde.laplace_spherical(r, theta, phi)

        # Example: Exterior problem with boundary u(R, theta, phi) = cos(theta)
        # Note: cos(theta) = sqrt(4*pi/3) * Y_1^0(theta, phi)

        # Solution outside sphere (r > R)
        def solve_exterior_sphere(R_val, l_max=10):
            """Solve Laplace equation exterior to sphere"""
            solution_terms = []

            for l in range(l_max + 1):
                for m in range(-l, l + 1):
                    # Coefficient from boundary condition
                    A_lm = compute_coefficient(l, m, R_val)

                    # Exterior solution: decays as r^(-(l+1))
                    term = A_lm * (R_val**(2*l+1) / r**(l+1)) * Y_lm(l, m, theta, phi)
                    solution_terms.append(term)

            return sum(solution_terms)

        # For boundary = cos(theta) = Y_1^0 (up to normalization):
        # Only l=1, m=0 term survives
        solution = expr('(R^3 / r^2) * cos(theta)')
        print(f"Solution: {solution}")

      rust: |
        use mathhook::pde::*;
        use mathhook::special::spherical_harmonic;

        let [r, theta, phi, R] = symbols![r, theta, phi, R];

        // Laplace in spherical coordinates
        let laplace = LaplaceEquation::spherical();

        // Boundary condition (example: cos(theta) = dipole field)
        let bc = expr!(cos(theta));

        // Solve exterior problem
        let solution = laplace.solve_exterior_sphere(R, bc, l_max: 10);

        // For dipole: u(r, theta, phi) = (R^3/r^2) * cos(theta)

      nodejs: |
        const { pde, symbols, expr } = require('mathhook');

        const [r, theta, phi, R] = symbols('r', 'theta', 'phi', 'R');

        const solution = pde.solveLaplaceSphere({
          radius: R,
          region: 'exterior',
          boundaryCondition: expr('cos(theta)'),
          maxDegree: 10
        });

        console.log(`Solution: ${solution}`);

    expected_output: |
      For boundary $u(R,\theta,\phi) = \cos\theta$ (dipole field):
      $$u(r,\theta,\phi) = \frac{R^3}{r^2}\cos\theta \quad (r > R)$$

      This is the electrostatic potential outside a grounded conducting sphere in a uniform field.

article:
  sections:
    - heading: "Physical Interpretation and Applications"
      content: |
        The Laplace equation describes steady-state (time-independent) potential fields:

        **Electrostatics**: $\nabla^2 \phi = 0$ where $\phi$ is electric potential in charge-free regions

        **Gravitation**: $\nabla^2 \Phi = 0$ where $\Phi$ is gravitational potential in mass-free regions

        **Steady-state heat**: $\nabla^2 T = 0$ where $T$ is temperature at equilibrium

        **Fluid flow**: $\nabla^2 \psi = 0$ where $\psi$ is stream function for irrotational, incompressible flow

        **Solutions (harmonic functions)** represent:
        - Equilibrium configurations (minimal energy)
        - Smooth interpolation between boundary values
        - Potential fields with no sources or sinks

    - heading: "Maximum Principle"
      content: |
        **Strong Maximum Principle**: If $u$ is harmonic in a connected domain $\Omega$, then:

        1. Maximum and minimum occur on the boundary $\partial\Omega$
        2. If $u$ attains maximum (or minimum) at an interior point, then $u$ is constant

        **Physical interpretation**: In equilibrium, temperature/potential cannot have interior extrema
        - hottest/coldest points are on boundary
        - highest/lowest potential is on boundary

        **Consequences**:
        - Uniqueness of solutions (given boundary conditions)
        - Comparison principles
        - Stability: small changes in boundary → small changes in solution

    - heading: "Mean Value Property"
      content: |
        For harmonic function $u$, the value at any point equals the average over any sphere
        (or circle in 2D) centered at that point:

        **3D**: $$u(x_0) = \frac{1}{4\pi R^2}\int_{|x-x_0|=R} u(x)dS$$

        **2D**: $$u(x_0) = \frac{1}{2\pi R}\int_{|x-x_0|=R} u(x)ds$$

        **Interpretation**: Harmonic functions are "perfectly balanced" - value at any point
        is average of nearby values.

        **Converse**: If a function satisfies mean value property, it is harmonic.

    - heading: "Separation of Variables"
      content: |
        Coordinate systems aligned with domain geometry:

        **Rectangular (Cartesian)**: $u(x,y,z) = X(x)Y(y)Z(z)$
        - Natural for rectangular domains
        - Leads to sine/cosine expansions

        **Cylindrical**: $u(r,\theta,z) = R(r)\Theta(\theta)Z(z)$
        - Natural for cylindrical geometries
        - Leads to Bessel functions + Fourier series

        **Spherical**: $u(r,\theta,\phi) = R(r)Y(\theta,\phi)$
        - Natural for spherical geometries
        - Leads to spherical harmonics

        Each coordinate system produces orthogonal function expansions suited to the geometry.

    - heading: "Green's Functions"
      content: |
        The fundamental solution of Laplace equation:

        **3D**: $$G(x,x_0) = -\frac{1}{4\pi|x-x_0|}$$

        **2D**: $$G(x,x_0) = -\frac{1}{2\pi}\ln|x-x_0|$$

        **Physical meaning**: Potential from point source at $x_0$

        **Green's representation formula** (solution in terms of boundary values):
        $$u(x) = \int_{\partial\Omega} \left[u(y)\frac{\partial G}{\partial n}(x,y) - G(x,y)\frac{\partial u}{\partial n}(y)\right]dS_y$$

        where $\frac{\partial}{\partial n}$ is normal derivative.

        This expresses solution as superposition of point source contributions from boundary.

    - heading: "Conformal Mapping (2D)"
      content: |
        In 2D, conformal maps preserve harmonic functions:

        **Theorem**: If $f: \Omega_1 \to \Omega_2$ is conformal (analytic and one-to-one), and
        $u$ is harmonic in $\Omega_2$, then $u \circ f$ is harmonic in $\Omega_1$.

        **Strategy**:
        1. Map complex domain $\Omega$ to simple domain (disk, half-plane, rectangle)
        2. Solve Laplace equation in simple domain
        3. Map solution back to original domain

        **Common mappings**:
        - Möbius transforms: map circles to circles
        - Joukowsky transform: airfoil shapes
        - Schwarz-Christoffel: polygons to half-plane

    - heading: "Numerical Methods"
      content: |
        **Finite Difference**:
        5-point stencil (2D):
        $$u_{i,j} = \frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}}{4}$$

        Solve linear system $Au = b$ where $A$ is sparse.

        **Finite Element Method**:
        - Variational formulation: minimize energy functional
        - Handles complex geometries and mixed boundary conditions
        - Adaptive mesh refinement

        **Boundary Element Method**:
        - Only discretize boundary (not interior)
        - Uses Green's function representation
        - Efficient for exterior problems

        **Multigrid methods**: Fast iterative solvers ($O(n)$ complexity)

use_cases:
  - "Electrostatics: Electric potential from charged conductors"
  - "Gravitation: Gravitational potential in planetary systems"
  - "Steady-state heat conduction: Temperature distribution at equilibrium"
  - "Fluid dynamics: Potential flow around airfoils and obstacles"
  - "Image processing: Poisson image editing and seamless cloning"
  - "Finance: Optimal stopping and free boundary problems"

related_topics:
  - pde.heat-equation
  - pde.wave-equation
  - pde.poisson-equation
  - calculus.fourier-series
  - special_functions.spherical-harmonics

references:
  - title: "Partial Differential Equations"
    author: "Lawrence C. Evans"
    year: 2010
    publisher: "American Mathematical Society"
  - title: "Elliptic Partial Differential Equations of Second Order"
    author: "David Gilbarg and Neil S. Trudinger"
    year: 2001
    publisher: "Springer"
  - title: "A Course in Modern Mathematical Physics: Groups, Hilbert Space and Differential Geometry"
    author: "Peter Szekeres"
    year: 2004
    publisher: "Cambridge University Press"

performance:
  complexity: "O(n³) for direct solve of linear system, O(n) for multigrid, O(n²log n) for FFT-based methods"
  typical_time: "< 100ms for analytical solution with 50 Fourier modes, 100ms-10s for numerical solution depending on grid size"
  benchmarks:
    analytical_rectangular: "80ms for 50×50 mode expansion"
    analytical_disk: "60ms for 100 Fourier modes"
    finite_difference_2d: "200ms for 100×100 grid (iterative solver)"
    finite_element_2d: "2s for 10000 elements with adaptive refinement"
