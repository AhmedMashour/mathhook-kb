topic: pde.wave-equation
title: The Wave Equation
description: |
  The wave equation is a fundamental hyperbolic PDE describing wave propagation
  in vibrating strings, sound, light, and other wave phenomena. It models how
  disturbances propagate through space and time.

mathematical_definition: |
  $$\frac{\partial^2 u}{\partial t^2} = c^2 \nabla^2 u$$

  where $u(x,t)$ is displacement, $c$ is wave speed, and $\nabla^2$ is the Laplacian.

  In 1D: $$\frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2 u}{\partial x^2}$$

code_refs:
  rust: mathhook_core::pde::wave_equation
  python: mathhook.pde.wave_equation
  nodejs: mathhook.pde.waveEquation

quick_reference:
  standard_form: "$\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u$"
  type: "Hyperbolic PDE (second-order in both space and time)"
  principle: "Disturbances propagate at constant speed $c$"
  solution_methods:
    - "d'Alembert's formula (1D traveling waves)"
    - "Separation of variables (standing waves)"
    - "Method of characteristics"
    - "Fourier transform"
    - "Numerical methods (finite difference, spectral)"
  key_properties:
    - "Finite propagation speed: disturbances travel at speed $c$"
    - "Energy conservation: total energy constant over time"
    - "Reversibility: can run backwards in time"
    - "Superposition: sum of solutions is a solution"

examples:
  - title: "1D Wave Equation: d'Alembert's Solution"
    explanation: |
      The general solution of the 1D wave equation on infinite domain is:
      $$u(x,t) = f(x - ct) + g(x + ct)$$

      where $f$ and $g$ are arbitrary functions representing right-moving and
      left-moving waves.

      For initial conditions $u(x,0) = \phi(x)$ and $u_t(x,0) = \psi(x)$:
      $$u(x,t) = \frac{\phi(x-ct) + \phi(x+ct)}{2} + \frac{1}{2c}\int_{x-ct}^{x+ct} \psi(s)ds$$

    code:
      python: |
        from mathhook import pde, symbols, expr
        import numpy as np

        x, t, c = symbols('x t c')

        # Define initial displacement and velocity
        phi = expr('exp(-x^2)')  # Initial shape (Gaussian)
        psi = expr('0')          # Initially at rest

        # d'Alembert solution
        solution = pde.dalembert_solution(phi, psi, c)
        print(f"Solution: {solution}")

        # Evaluate at specific point and time
        u_val = solution.subs({x: 1.0, t: 0.5, c: 1.0})
        print(f"u(1.0, 0.5) = {u_val}")

        # Numerical evaluation
        def evaluate_wave(x_val, t_val, c_val=1.0):
            """Evaluate d'Alembert solution numerically"""
            # Right-moving and left-moving components
            f_right = np.exp(-(x_val - c_val*t_val)**2)
            f_left = np.exp(-(x_val + c_val*t_val)**2)
            return (f_right + f_left) / 2

        # Create animation data
        x_vals = np.linspace(-5, 5, 200)
        for t_val in [0, 0.5, 1.0, 1.5, 2.0]:
            u_vals = [evaluate_wave(x, t_val) for x in x_vals]
            print(f"t = {t_val}: wave split into two pulses")

      rust: |
        use mathhook::pde::*;
        use mathhook::{expr, symbol};

        let [x, t, c] = symbols![x, t, c];

        // Initial conditions
        let phi = expr!(exp(-x^2));  // Initial displacement
        let psi = expr!(0);          // Initial velocity

        // d'Alembert solution
        let wave_eq = WaveEquation::new(c.clone());
        let solution = wave_eq.dalembert_solution(&phi, &psi);

        println!("Solution: {}", solution);

        // Evaluate at point
        let u_val = solution
            .substitute(&x, &expr!(1.0))
            .substitute(&t, &expr!(0.5))
            .substitute(&c, &expr!(1.0))
            .evaluate();

      nodejs: |
        const { pde, symbols, expr } = require('mathhook');

        const [x, t, c] = symbols('x', 't', 'c');

        // Initial conditions
        const phi = expr('exp(-x^2)');
        const psi = expr('0');

        // d'Alembert solution
        const solution = pde.dalembertSolution(phi, psi, c);
        console.log(`Solution: ${solution}`);

        // Evaluate
        const uVal = solution
          .subs(x, 1.0)
          .subs(t, 0.5)
          .subs(c, 1.0);
        console.log(`u(1.0, 0.5) = ${uVal}`);

    expected_output: |
      $$u(x,t) = \frac{e^{-(x-ct)^2} + e^{-(x+ct)^2}}{2}$$

      The initial Gaussian pulse splits into two equal pulses traveling in opposite directions.

  - title: "Vibrating String with Fixed Ends"
    explanation: |
      A string of length $L$ with fixed ends satisfies:

      PDE: $\frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2 u}{\partial x^2}$, $0 < x < L$

      Boundary conditions: $u(0,t) = 0$, $u(L,t) = 0$

      Initial conditions: $u(x,0) = f(x)$, $u_t(x,0) = g(x)$

      Solution (standing wave expansion):
      $$u(x,t) = \sum_{n=1}^{\infty} \left[a_n \cos\left(\frac{n\pi ct}{L}\right) + b_n \sin\left(\frac{n\pi ct}{L}\right)\right] \sin\left(\frac{n\pi x}{L}\right)$$

      where:
      - $a_n = \frac{2}{L}\int_0^L f(x)\sin\left(\frac{n\pi x}{L}\right)dx$
      - $b_n = \frac{2}{n\pi c}\int_0^L g(x)\sin\left(\frac{n\pi x}{L}\right)dx$

    code:
      python: |
        from mathhook import pde, symbols, expr

        x, t, L, c = symbols('x t L c')
        u = pde.Function('u', [x, t])

        # Wave equation
        wave_eq = pde.wave_equation(u, x, t, c)

        # Fixed boundary conditions
        bc1 = u.subs(x, 0) == 0
        bc2 = u.subs(x, L) == 0

        # Initial displacement (plucked string shape)
        ic_displacement = u.subs(t, 0) == expr('x*(L-x)')

        # Initial velocity (released from rest)
        ic_velocity = u.diff(t).subs(t, 0) == 0

        # Solve using separation of variables
        solution = pde.solve_wave_equation(
            wave_eq,
            boundary_conditions=[bc1, bc2],
            initial_conditions={
                'displacement': ic_displacement,
                'velocity': ic_velocity
            },
            domain={'x': (0, L), 't': (0, float('inf'))},
            method='separation_of_variables'
        )

        print(f"Solution (standing waves): {solution}")

        # Extract fundamental frequency
        fundamental = solution.get_mode(n=1)
        print(f"Fundamental mode: {fundamental}")
        print(f"Frequency: {c/(2*L)} Hz")

      rust: |
        use mathhook::pde::*;

        let [x, t, L, c] = symbols![x, t, L, c];

        // Wave equation setup
        let wave_eq = WaveEquation::new(c.clone());

        // Boundary conditions (fixed ends)
        let bc = BoundaryConditions::dirichlet(vec![
            (expr!(0), expr!(0)),
            (L.clone(), expr!(0)),
        ]);

        // Initial conditions
        let ic_displacement = expr!(x * (L - x));
        let ic_velocity = expr!(0);

        // Solve
        let solution = wave_eq.solve_separation_variables(
            &bc,
            &InitialConditions::new(ic_displacement, ic_velocity),
            Domain::rectangular((expr!(0), L), (expr!(0), expr!(inf)))
        );

        // Extract modes
        let fundamental = solution.mode(1);
        println!("Fundamental frequency: π*c/L");

      nodejs: |
        const { pde, symbols, expr } = require('mathhook');

        const [x, t, L, c] = symbols('x', 't', 'L', 'c');

        const solution = pde.solveWaveEquation({
          c,
          domain: { x: [0, L], t: [0, Infinity] },
          boundaryConditions: 'dirichlet_zero',
          initialDisplacement: expr('x*(L-x)'),
          initialVelocity: expr('0'),
          method: 'separationOfVariables'
        });

        const fundamental = solution.getMode(1);
        console.log(`Fundamental: ${fundamental}`);

    expected_output: |
      $$u(x,t) = \sum_{n=1,3,5,...} \frac{8L^2}{n^3\pi^3} \cos\left(\frac{n\pi ct}{L}\right) \sin\left(\frac{n\pi x}{L}\right)$$

      Only odd harmonics appear (symmetric initial shape).
      Fundamental frequency: $f_1 = c/(2L)$

  - title: "2D Wave Equation: Vibrating Membrane"
    explanation: |
      A rectangular membrane $[0,a] \times [0,b]$ with fixed edges:

      PDE: $\frac{\partial^2 u}{\partial t^2} = c^2 \left(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\right)$

      Solution:
      $$u(x,y,t) = \sum_{m=1}^{\infty}\sum_{n=1}^{\infty} \left[A_{mn}\cos(\omega_{mn}t) + B_{mn}\sin(\omega_{mn}t)\right] \sin\left(\frac{m\pi x}{a}\right)\sin\left(\frac{n\pi y}{b}\right)$$

      where $\omega_{mn} = c\pi\sqrt{(m/a)^2 + (n/b)^2}$ are the natural frequencies.

    code:
      python: |
        from mathhook import pde, symbols

        x, y, t, a, b, c = symbols('x y t a b c')

        # 2D wave equation
        wave_eq_2d = pde.wave_equation_2d(c)

        # Fixed boundary
        bc = pde.BoundaryConditions.dirichlet_rectangle(
            x_range=(0, a),
            y_range=(0, b),
            value=0
        )

        # Initial displacement (center struck)
        ic_disp = expr('sin(pi*x/a) * sin(pi*y/b)')
        ic_vel = expr('0')

        solution = pde.solve_wave_equation_2d(
            wave_eq_2d,
            boundary_conditions=bc,
            initial_displacement=ic_disp,
            initial_velocity=ic_vel
        )

        # Natural frequencies
        freqs = pde.natural_frequencies_2d(c, a, b, max_mode=5)
        print(f"Natural frequencies: {freqs}")

      rust: |
        use mathhook::pde::*;

        let [x, y, t, a, b, c] = symbols![x, y, t, a, b, c];

        let wave_eq = WaveEquation2D::new(c);

        let bc = BoundaryConditions::dirichlet_rectangle(
            (expr!(0), a.clone()),
            (expr!(0), b.clone()),
            expr!(0)
        );

        let ic = InitialConditions::new(
            expr!(sin(pi * x / a) * sin(pi * y / b)),
            expr!(0)
        );

        let solution = wave_eq.solve_separation_variables(&bc, &ic);

        // Natural frequencies: ω_mn = c*π*sqrt((m/a)^2 + (n/b)^2)
        let freqs = wave_eq.natural_frequencies(&a, &b, 5);

      nodejs: |
        const { pde, symbols, expr } = require('mathhook');

        const [x, y, t, a, b, c] = symbols('x', 'y', 't', 'a', 'b', 'c');

        const solution = pde.solveWaveEquation2D({
          c,
          domain: { x: [0, a], y: [0, b] },
          boundaryConditions: 'dirichlet_zero',
          initialDisplacement: expr('sin(pi*x/a) * sin(pi*y/b)'),
          initialVelocity: expr('0')
        });

        const freqs = pde.naturalFrequencies2D(c, a, b, { maxMode: 5 });

    expected_output: |
      For $(m,n) = (1,1)$ mode:
      $$u(x,y,t) = \cos\left(c\pi\sqrt{\frac{1}{a^2}+\frac{1}{b^2}}t\right) \sin\left(\frac{\pi x}{a}\right)\sin\left(\frac{\pi y}{b}\right)$$

      Fundamental frequency: $\omega_{11} = c\pi\sqrt{1/a^2 + 1/b^2}$

article:
  sections:
    - heading: "Physical Interpretation"
      content: |
        The wave equation describes oscillatory motion with finite propagation speed:

        - **$u(x,t)$**: Displacement from equilibrium
        - **$c$**: Wave speed (depends on medium properties)
        - **$\frac{\partial^2 u}{\partial t^2}$**: Acceleration
        - **$\nabla^2 u$**: Spatial curvature (restoring force)

        **Physical examples**:
        - Vibrating strings and membranes (musical instruments)
        - Sound waves in air and solids
        - Electromagnetic waves (light)
        - Water surface waves (shallow water approximation)
        - Seismic waves in Earth's crust

        **Wave speed formula**:
        - String: $c = \sqrt{T/\rho}$ where $T$ is tension, $\rho$ is linear mass density
        - Sound: $c = \sqrt{\gamma P/\rho}$ where $\gamma$ is heat capacity ratio, $P$ is pressure
        - Electromagnetic: $c = 1/\sqrt{\mu_0\epsilon_0}$ (speed of light in vacuum)

    - heading: "d'Alembert's Formula (1D Traveling Waves)"
      content: |
        The general solution of the 1D wave equation is:
        $$u(x,t) = f(x - ct) + g(x + ct)$$

        **Interpretation**:
        - $f(x - ct)$: Right-moving wave (shape $f$ traveling right at speed $c$)
        - $g(x + ct)$: Left-moving wave (shape $g$ traveling left at speed $c$)

        **For initial conditions** $u(x,0) = \phi(x)$ and $u_t(x,0) = \psi(x)$:
        $$u(x,t) = \frac{\phi(x-ct) + \phi(x+ct)}{2} + \frac{1}{2c}\int_{x-ct}^{x+ct} \psi(s)ds$$

        **Key property**: Information at $(x,t)$ depends only on interval $[x-ct, x+ct]$ at $t=0$
        (domain of dependence). This reflects finite propagation speed.

    - heading: "Separation of Variables (Standing Waves)"
      content: |
        For bounded domains with boundary conditions, assume $u(x,t) = X(x)T(t)$:

        **Step 1**: Substitute into wave equation:
        $$X(x)T''(t) = c^2 X''(x)T(t)$$

        **Step 2**: Separate:
        $$\frac{T''(t)}{c^2 T(t)} = \frac{X''(x)}{X(x)} = -\lambda$$

        **Step 3**: Solve spatial eigenvalue problem:
        $$X''(x) + \lambda X(x) = 0$$
        with boundary conditions to find $\lambda_n$ and $X_n(x)$

        **Step 4**: Solve temporal ODE:
        $$T''(t) + c^2\lambda_n T(t) = 0$$
        giving $T_n(t) = A_n\cos(\omega_n t) + B_n\sin(\omega_n t)$ where $\omega_n = c\sqrt{\lambda_n}$

        **Step 5**: General solution (standing waves):
        $$u(x,t) = \sum_{n} \left[A_n\cos(\omega_n t) + B_n\sin(\omega_n t)\right]X_n(x)$$

        These are standing waves with fixed spatial patterns $X_n(x)$ oscillating at frequencies $\omega_n$.

    - heading: "Energy Conservation"
      content: |
        The wave equation conserves total energy:
        $$E(t) = \frac{1}{2}\int \left[\left(\frac{\partial u}{\partial t}\right)^2 + c^2|\nabla u|^2\right]dx$$

        where:
        - Kinetic energy: $\frac{1}{2}\int (u_t)^2 dx$
        - Potential energy: $\frac{c^2}{2}\int |\nabla u|^2 dx$

        **Conservation law**: $\frac{dE}{dt} = 0$ (energy remains constant over time)

        **Physical meaning**: Energy flows between kinetic and potential forms but total energy
        is conserved (no dissipation in the ideal wave equation).

        **Energy flux** (energy flow across boundaries):
        $$F = -c^2 u_t \nabla u$$

    - heading: "Finite Propagation Speed"
      content: |
        Unlike the heat equation (infinite propagation speed), waves have finite propagation speed $c$.

        **Domain of dependence**: Solution at $(x,t)$ depends only on data within distance $ct$
        from $x$ at $t=0$.

        **Range of influence**: Initial data at $x_0$ affects only points within distance $ct$
        from $x_0$ at time $t$.

        **Sharp wavefronts**: Discontinuities in initial data propagate as sharp wavefronts,
        unlike heat equation which smooths immediately.

        **Huygens' principle** (odd spatial dimensions): Wavefronts are sharp with no trailing
        disturbance. In even dimensions, waves leave a wake.

    - heading: "Method of Characteristics"
      content: |
        The 1D wave equation can be factored as:
        $$\left(\frac{\partial}{\partial t} - c\frac{\partial}{\partial x}\right)\left(\frac{\partial}{\partial t} + c\frac{\partial}{\partial x}\right)u = 0$$

        **Characteristic curves**: Lines $x - ct = \text{const}$ and $x + ct = \text{const}$ in spacetime

        **Characteristic variables**:
        - $\xi = x - ct$ (right-moving characteristics)
        - $\eta = x + ct$ (left-moving characteristics)

        In $(\xi, \eta)$ coordinates, wave equation becomes:
        $$\frac{\partial^2 u}{\partial \xi \partial \eta} = 0$$

        Solution: $u = f(\xi) + g(\eta) = f(x-ct) + g(x+ct)$ (d'Alembert form)

    - heading: "Numerical Methods"
      content: |
        **Finite Difference (Explicit)**:
        $$u_i^{n+1} = 2u_i^n - u_i^{n-1} + \left(\frac{c\Delta t}{\Delta x}\right)^2 (u_{i+1}^n - 2u_i^n + u_{i-1}^n)$$

        **CFL condition** (stability): $c\frac{\Delta t}{\Delta x} \leq 1$

        Physical meaning: time step must be small enough that wave doesn't cross more than one
        spatial grid cell.

        **Spectral methods**: Represent solution as Fourier series, excellent for smooth solutions

        **Finite element methods**: Handle complex geometries and boundary conditions

        **Symplectic integrators**: Preserve energy conservation in long-time simulations

use_cases:
  - "Acoustics: Sound propagation in air, water, and solids"
  - "Musical instruments: String and membrane vibrations (guitar, drums)"
  - "Electromagnetics: Radio waves, light propagation"
  - "Seismology: Earthquake wave propagation through Earth"
  - "Structural engineering: Building vibrations and resonance"
  - "Quantum mechanics: Schrödinger equation (wave-like behavior)"

related_topics:
  - pde.heat-equation
  - pde.laplace-equation
  - calculus.fourier-series
  - numerical.finite-difference
  - physics.acoustics

references:
  - title: "Partial Differential Equations"
    author: "Lawrence C. Evans"
    year: 2010
    publisher: "American Mathematical Society"
  - title: "The Wave Equation"
    author: "A. G. Webster"
    year: 1927
    publisher: "Dover Publications"
  - title: "Mathematical Methods for Physics and Engineering"
    author: "Riley, Hobson, and Bence"
    year: 2006
    publisher: "Cambridge University Press"

performance:
  complexity: "O(n²) for separation of variables with n modes in 1D, O(n⁴) for 2D with n×n modes, O(mn) for finite difference with m time steps and n spatial points"
  typical_time: "< 50ms for analytical solution with 50 modes, 500ms-5s for numerical solution on 1000 grid points"
  benchmarks:
    analytical_1d: "30ms for 100 modes"
    dalembert_formula: "10ms for evaluation at 1000 points"
    numerical_explicit_1d: "500ms for 1000 spatial points, 10000 time steps"
    numerical_2d: "5s for 100×100 grid, 1000 time steps"
