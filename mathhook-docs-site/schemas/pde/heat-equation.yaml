topic: pde.heat-equation
title: The Heat Equation
description: |
  The heat equation is a fundamental parabolic PDE describing heat diffusion and
  other diffusion processes. It models how temperature distributes over time and space.

mathematical_definition: |
  $$\frac{\partial u}{\partial t} = \alpha \nabla^2 u$$

  where $u(x,t)$ is temperature, $\alpha$ is thermal diffusivity, and $\nabla^2$ is the Laplacian.

  In 1D: $$\frac{\partial u}{\partial t} = \alpha \frac{\partial^2 u}{\partial x^2}$$

code_refs:
  rust: mathhook_core::pde::heat_equation
  python: mathhook.pde.heat_equation
  nodejs: mathhook.pde.heatEquation

quick_reference:
  standard_form: "$\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u$"
  type: "Parabolic PDE (second-order in space, first-order in time)"
  principle: "Heat flows from hot to cold regions"
  solution_methods:
    - "Separation of variables (for simple geometries)"
    - "Fourier series expansion"
    - "Fundamental solution (Green's function)"
    - "Numerical methods (finite difference, finite element)"
  key_properties:
    - "Maximum principle: temperature cannot have interior extrema"
    - "Smoothing effect: solutions become infinitely smooth for $t > 0$"
    - "Irreversibility: cannot uniquely determine initial conditions from final state"

examples:
  - title: "1D Heat Equation with Dirichlet Boundary Conditions"
    explanation: |
      Solve the heat equation on a rod of length $L$ with fixed temperatures
      at both ends:

      PDE: $\frac{\partial u}{\partial t} = \alpha \frac{\partial^2 u}{\partial x^2}$, $0 < x < L$, $t > 0$

      Boundary conditions: $u(0,t) = 0$, $u(L,t) = 0$

      Initial condition: $u(x,0) = f(x)$

      Solution using separation of variables:
      $$u(x,t) = \sum_{n=1}^{\infty} b_n \sin\left(\frac{n\pi x}{L}\right) e^{-\alpha (n\pi/L)^2 t}$$

      where $b_n = \frac{2}{L}\int_0^L f(x)\sin\left(\frac{n\pi x}{L}\right)dx$

    code:
      python: |
        from mathhook import pde, symbols, expr

        # Define variables
        x, t, L, alpha = symbols('x t L alpha')
        u = pde.Function('u', [x, t])

        # Define PDE
        heat_eq = pde.heat_equation(u, x, t, alpha)

        # Boundary conditions
        bc1 = u.subs(x, 0) == 0
        bc2 = u.subs(x, L) == 0

        # Initial condition (example: sine wave)
        ic = u.subs(t, 0) == expr('sin(pi*x/L)')

        # Solve using separation of variables
        solution = pde.solve_heat_equation(
            heat_eq,
            boundary_conditions=[bc1, bc2],
            initial_condition=ic,
            domain={'x': (0, L), 't': (0, float('inf'))},
            method='separation_of_variables'
        )

        print(f"Solution: {solution}")
        # Result: sum of exponentially decaying sine modes

      rust: |
        use mathhook::pde::*;
        use mathhook::{expr, symbol};

        // Define variables
        let x = symbol!(x);
        let t = symbol!(t);
        let L = symbol!(L);
        let alpha = symbol!(alpha);

        // Create heat equation
        let heat_eq = HeatEquation::new(alpha);

        // Define boundary conditions
        let bc = BoundaryConditions::dirichlet(vec![
            (expr!(0), expr!(0)),  // u(0,t) = 0
            (L.clone(), expr!(0)), // u(L,t) = 0
        ]);

        // Define initial condition
        let ic = InitialCondition::new(expr!(sin(pi * x / L)));

        // Solve
        let solution = heat_eq.solve_separation_variables(
            &bc,
            &ic,
            Domain::rectangular((expr!(0), L), (expr!(0), expr!(inf)))
        );

        println!("Solution: {}", solution);

      nodejs: |
        const { pde, symbols, expr } = require('mathhook');

        // Define variables
        const [x, t, L, alpha] = symbols('x', 't', 'L', 'alpha');
        const u = pde.function('u', [x, t]);

        // Create heat equation
        const heatEq = pde.heatEquation(u, x, t, alpha);

        // Boundary conditions
        const bc1 = u.subs(x, 0).eq(0);
        const bc2 = u.subs(x, L).eq(0);

        // Initial condition
        const ic = u.subs(t, 0).eq(expr('sin(pi*x/L)'));

        // Solve
        const solution = pde.solveHeatEquation(heatEq, {
          boundaryConditions: [bc1, bc2],
          initialCondition: ic,
          domain: { x: [0, L], t: [0, Infinity] },
          method: 'separationOfVariables'
        });

        console.log(`Solution: ${solution}`);

    expected_output: |
      $$u(x,t) = \frac{2}{L}\sum_{n=1}^{\infty} \left(\int_0^L \sin\left(\frac{m\pi x}{L}\right)\sin\left(\frac{n\pi x}{L}\right)dx\right) \sin\left(\frac{n\pi x}{L}\right) e^{-\alpha (n\pi/L)^2 t}$$

      For initial condition $u(x,0) = \sin(\pi x/L)$, only $n=1$ term survives:
      $$u(x,t) = \sin\left(\frac{\pi x}{L}\right) e^{-\alpha (\pi/L)^2 t}$$

  - title: "2D Heat Equation on Rectangle"
    explanation: |
      Solve the 2D heat equation on a rectangular domain $[0,a] \times [0,b]$
      with zero boundary conditions.

      PDE: $\frac{\partial u}{\partial t} = \alpha \left(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\right)$

      Solution:
      $$u(x,y,t) = \sum_{m=1}^{\infty}\sum_{n=1}^{\infty} b_{mn} \sin\left(\frac{m\pi x}{a}\right)\sin\left(\frac{n\pi y}{b}\right) e^{-\alpha\left[(m\pi/a)^2 + (n\pi/b)^2\right]t}$$

    code:
      python: |
        from mathhook import pde, symbols

        x, y, t, a, b, alpha = symbols('x y t a b alpha')
        u = pde.Function('u', [x, y, t])

        # 2D heat equation
        heat_eq_2d = pde.heat_equation_2d(u, x, y, t, alpha)

        # Zero boundary conditions on rectangle
        bc = pde.BoundaryConditions.dirichlet_rectangle(
            x_range=(0, a),
            y_range=(0, b),
            value=0
        )

        # Initial condition (example: product of sines)
        ic = u.at(t=0) == expr('sin(pi*x/a) * sin(pi*y/b)')

        solution = pde.solve_heat_equation_2d(
            heat_eq_2d,
            boundary_conditions=bc,
            initial_condition=ic,
            method='separation_of_variables'
        )

      rust: |
        use mathhook::pde::*;

        let [x, y, t, a, b, alpha] = symbols![x, y, t, a, b, alpha];

        let heat_eq = HeatEquation2D::new(alpha);

        let bc = BoundaryConditions::dirichlet_rectangle(
            (expr!(0), a.clone()),
            (expr!(0), b.clone()),
            expr!(0)
        );

        let ic = expr!(sin(pi * x / a) * sin(pi * y / b));

        let solution = heat_eq.solve_separation_variables(&bc, &ic);

      nodejs: |
        const { pde, symbols, expr } = require('mathhook');

        const [x, y, t, a, b, alpha] = symbols('x', 'y', 't', 'a', 'b', 'alpha');

        const solution = pde.solveHeatEquation2D({
          alpha,
          domain: { x: [0, a], y: [0, b] },
          boundaryConditions: 'dirichlet_zero',
          initialCondition: expr('sin(pi*x/a) * sin(pi*y/b)')
        });

    expected_output: |
      For $u(x,y,0) = \sin(\pi x/a)\sin(\pi y/b)$:
      $$u(x,y,t) = \sin\left(\frac{\pi x}{a}\right)\sin\left(\frac{\pi y}{b}\right) e^{-\alpha\left[(\pi/a)^2 + (\pi/b)^2\right]t}$$

  - title: "Fundamental Solution (Green's Function)"
    explanation: |
      The fundamental solution of the 1D heat equation is:
      $$G(x,t) = \frac{1}{\sqrt{4\pi\alpha t}} e^{-x^2/(4\alpha t)}$$

      This is the solution with initial condition $u(x,0) = \delta(x)$ (Dirac delta).

      For arbitrary initial condition $f(x)$, the solution is:
      $$u(x,t) = \int_{-\infty}^{\infty} G(x-y,t)f(y)dy = \frac{1}{\sqrt{4\pi\alpha t}} \int_{-\infty}^{\infty} e^{-(x-y)^2/(4\alpha t)} f(y)dy$$

    code:
      python: |
        from mathhook import pde, symbols, expr
        import numpy as np

        x, t, alpha = symbols('x t alpha')

        # Fundamental solution
        G = pde.heat_kernel(x, t, alpha)
        print(f"Green's function: {G}")
        # Result: 1/sqrt(4*pi*alpha*t) * exp(-x^2/(4*alpha*t))

        # Solution for initial condition f(x)
        def solve_with_convolution(f_func, x_val, t_val, alpha_val):
            """Solve heat equation using convolution with Green's function"""
            from scipy.integrate import quad

            def integrand(y):
                kernel = (1/np.sqrt(4*np.pi*alpha_val*t_val)) * \
                         np.exp(-(x_val - y)**2 / (4*alpha_val*t_val))
                return kernel * f_func(y)

            result, error = quad(integrand, -np.inf, np.inf)
            return result

        # Example: Gaussian initial condition
        f = lambda x: np.exp(-x**2)
        u_at_point = solve_with_convolution(f, x_val=0.5, t_val=0.1, alpha_val=1.0)
        print(f"u(0.5, 0.1) = {u_at_point}")

      rust: |
        use mathhook::pde::*;

        let [x, t, alpha] = symbols![x, t, alpha];

        // Fundamental solution
        let greens = HeatEquation::fundamental_solution(x, t, alpha);
        // Result: 1/sqrt(4*pi*alpha*t) * exp(-x^2/(4*alpha*t))

        // Solve with convolution
        let initial_condition = expr!(exp(-x^2));
        let solution = HeatEquation::convolve_with_kernel(
            greens,
            initial_condition,
            alpha
        );

      nodejs: |
        const { pde, symbols, expr } = require('mathhook');

        const [x, t, alpha] = symbols('x', 't', 'alpha');

        // Fundamental solution
        const G = pde.heatKernel(x, t, alpha);
        console.log(`Green's function: ${G}`);

        // Convolution solution
        const ic = expr('exp(-x^2)');
        const solution = pde.convolveHeatKernel(G, ic, { x, t, alpha });

    expected_output: |
      Green's function:
      $$G(x,t) = \frac{1}{\sqrt{4\pi\alpha t}} e^{-x^2/(4\alpha t)}$$

      For $f(x) = e^{-x^2}$:
      $$u(x,t) = \frac{1}{\sqrt{1+4\alpha t}} e^{-x^2/(1+4\alpha t)}$$

article:
  sections:
    - heading: "Physical Interpretation"
      content: |
        The heat equation models diffusion processes where:

        - **$u(x,t)$**: Temperature at position $x$ and time $t$
        - **$\alpha$**: Thermal diffusivity (material property)
        - **$\nabla^2 u$**: Laplacian measures spatial curvature of temperature

        **Physical principle**: Heat flows from regions of high curvature to low curvature,
        smoothing out temperature variations over time.

        **Examples beyond heat transfer**:
        - Diffusion of chemicals in solution
        - Spread of biological populations
        - Option pricing in finance (Black-Scholes equation)
        - Image processing (Gaussian blur)

    - heading: "Separation of Variables Method"
      content: |
        For simple geometries with homogeneous boundary conditions:

        **Step 1**: Assume $u(x,t) = X(x)T(t)$

        **Step 2**: Substitute into PDE:
        $$X(x)T'(t) = \alpha X''(x)T(t)$$

        **Step 3**: Separate variables:
        $$\frac{T'(t)}{\alpha T(t)} = \frac{X''(x)}{X(x)} = -\lambda$$

        where $\lambda$ is the separation constant.

        **Step 4**: Solve two ODEs:
        - Spatial: $X''(x) + \lambda X(x) = 0$ with boundary conditions
        - Temporal: $T'(t) + \alpha\lambda T(t) = 0$

        **Step 5**: Find eigenvalues $\lambda_n$ and eigenfunctions $X_n(x)$ from spatial problem

        **Step 6**: General solution is superposition:
        $$u(x,t) = \sum_{n} c_n X_n(x) e^{-\alpha\lambda_n t}$$

        **Step 7**: Determine coefficients $c_n$ from initial condition using orthogonality

    - heading: "Fourier Series Solutions"
      content: |
        For 1D heat equation on $[0,L]$ with Dirichlet boundary conditions:

        **Eigenvalues**: $\lambda_n = (n\pi/L)^2$, $n = 1,2,3,...$

        **Eigenfunctions**: $X_n(x) = \sin(n\pi x/L)$

        **General solution**:
        $$u(x,t) = \sum_{n=1}^{\infty} b_n \sin\left(\frac{n\pi x}{L}\right) e^{-\alpha (n\pi/L)^2 t}$$

        **Fourier coefficients** from initial condition $f(x)$:
        $$b_n = \frac{2}{L}\int_0^L f(x)\sin\left(\frac{n\pi x}{L}\right)dx$$

        **Key observations**:
        - Higher frequency modes ($n$ large) decay faster
        - Long-time behavior dominated by $n=1$ mode
        - Solution becomes smoother as $t \to \infty$

    - heading: "Maximum Principle"
      content: |
        **Strong Maximum Principle**: If $u(x,t)$ solves the heat equation in a region,
        then the maximum and minimum of $u$ occur either:
        1. At the initial time ($t = 0$)
        2. On the spatial boundary

        **Physical interpretation**: Temperature cannot have local maxima or minima in the
        interior of the domain - heat always flows to eliminate temperature extremes.

        **Consequences**:
        - Uniqueness of solutions
        - Comparison principles for solutions
        - Stability estimates
        - Temperature bounds from boundary data

    - heading: "Fundamental Solution and Green's Function"
      content: |
        The fundamental solution (heat kernel) is:
        $$G(x,t) = \frac{1}{(4\pi\alpha t)^{n/2}} e^{-|x|^2/(4\alpha t)}$$

        where $n$ is the spatial dimension.

        **Properties**:
        - $G(x,t) \to \delta(x)$ as $t \to 0^+$
        - $\int G(x,t)dx = 1$ for all $t > 0$ (conservation)
        - Gaussian spreading with variance $\sigma^2 = 2\alpha t$

        **Convolution solution** for initial value problem:
        $$u(x,t) = \int G(x-y,t)f(y)dy$$

        This represents the superposition of heat kernels centered at each point of the
        initial distribution.

    - heading: "Numerical Methods"
      content: |
        **Finite Difference Methods**:

        Explicit (Forward Euler):
        $$u_i^{n+1} = u_i^n + \frac{\alpha \Delta t}{(\Delta x)^2}(u_{i+1}^n - 2u_i^n + u_{i-1}^n)$$

        Stability condition: $\frac{\alpha \Delta t}{(\Delta x)^2} \leq \frac{1}{2}$

        Implicit (Backward Euler):
        $$u_i^{n+1} - \frac{\alpha \Delta t}{(\Delta x)^2}(u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}) = u_i^n$$

        Unconditionally stable, requires solving linear system.

        Crank-Nicolson (average of explicit and implicit):
        Better accuracy, unconditionally stable.

        **Finite Element Methods**: Handle complex geometries and boundary conditions.

        **Spectral Methods**: Exponential convergence for smooth solutions.

use_cases:
  - "Heat conduction: Temperature distribution in solids"
  - "Chemical diffusion: Concentration of reactants spreading in solution"
  - "Financial mathematics: Black-Scholes equation for option pricing"
  - "Image processing: Gaussian smoothing and edge detection"
  - "Biology: Population spread and chemical signaling"
  - "Materials science: Grain growth and phase transitions"

related_topics:
  - pde.wave-equation
  - pde.laplace-equation
  - pde.diffusion-advection
  - calculus.fourier-series
  - numerical.finite-difference

references:
  - title: "Partial Differential Equations"
    author: "Lawrence C. Evans"
    year: 2010
    publisher: "American Mathematical Society"
  - title: "The Heat Equation"
    author: "D.V. Widder"
    year: 1975
    publisher: "Academic Press"
  - title: "Fourier Series and Boundary Value Problems"
    author: "James Ward Brown and Ruel V. Churchill"
    year: 2011
    publisher: "McGraw-Hill"

performance:
  complexity: "O(n³) for separation of variables with n modes, O(mn) for numerical finite difference with m time steps and n spatial points"
  typical_time: "< 100ms for analytical solution with 50 Fourier modes, 1-10s for numerical solution on 100×100 grid"
  benchmarks:
    analytical_1d: "50ms for 100 Fourier modes"
    numerical_explicit: "200ms for 100 spatial points, 1000 time steps"
    numerical_implicit: "1.5s for 100×100 2D grid, 500 time steps"
